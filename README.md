# Automated Test Execution Report

## Table of Contents
- [Introduction](#introduction)
- [Summary](#summary)
  - [Total tests per language](#total-tests-per-language)
  - [Summary table](#result-table)
- [Test by language](#tests-by-language)
- [Test by feature](#tests-by-feature)
- [Test by type](#tests-by-type)


## Introduction

This report provides a Test Suite for procedural language in PostgreSQL created using our Test Generation tool.

## Summary

- **Tests Passed**: `555`
- **Tests Failed**: `219`
- **Total Number of Tests**: `774`

### Total tests per language: 

| Language   |   Working Tests |   Failing Tests |   Total Tests |
|:-----------|----------------:|----------------:|--------------:|
| plpgsql    |              85 |               1 |            86 |
| plv8       |              85 |               1 |            86 |
| plcsharp   |              79 |               7 |            86 |
| plpython3u |              77 |               9 |            86 |
| plr        |              77 |               9 |            86 |
| plfsharp   |              56 |              30 |            86 |
| pllua      |              45 |              41 |            86 |
| plperl     |              41 |              45 |            86 |
| pltcl      |              10 |              76 |            86 |

### Total tests per type:

### Type: float4

| Language | Working Tests | Failing Tests | Total Tests |
|---|---:|---:|---:|
| plcsharp | 79 | 7 | 86 |
| plfsharp | 56 | 30 | 86 |
| plpython3u | 77 | 9 | 86 |
| plv8 | 85 | 1 | 86 |
| plpgsql | 85 | 1 | 86 |
| plr | 77 | 9 | 86 |
| plperl | 41 | 45 | 86 |
| pllua | 45 | 41 | 86 |
| pltcl | 10 | 76 | 86 |



### Result table:

## 

| Feature | [plpgsql](#plpgsql) | [plv8](#plv8) | [plcsharp](#plcsharp) | [plpython3u](#plpython3u) | [plr](#plr) | [plfsharp](#plfsharp) | [pllua](#pllua) | [plperl](#plperl) | [pltcl](#pltcl) |
|---|---|---|---|---|---|---|---|---|---|
| [calculate_median_of_two_float4](#calculate_median_of_two_float4) | [✅](#plpgsql_calculate_median_of_two_float4✅) | [✅](#plv8_calculate_median_of_two_float4✅) | [✅](#plcsharp_calculate_median_of_two_float4✅) | [✅](#plpython3u_calculate_median_of_two_float4✅) | [✅](#plr_calculate_median_of_two_float4✅) | [✅](#plfsharp_calculate_median_of_two_float4✅) | [❌](#pllua_calculate_median_of_two_float4❌) | [✅](#plperl_calculate_median_of_two_float4✅) | [❌](#pltcl_calculate_median_of_two_float4❌) |
| [find_nearest_multiple_float4](#find_nearest_multiple_float4) | [✅](#plpgsql_find_nearest_multiple_float4✅) | [✅](#plv8_find_nearest_multiple_float4✅) | [✅](#plcsharp_find_nearest_multiple_float4✅) | [✅](#plpython3u_find_nearest_multiple_float4✅) | [❌](#plr_find_nearest_multiple_float4❌) | [❌](#plfsharp_find_nearest_multiple_float4❌) | [❌](#pllua_find_nearest_multiple_float4❌) | [❌](#plperl_find_nearest_multiple_float4❌) | [❌](#pltcl_find_nearest_multiple_float4❌) |
| [subtract_float4_values](#subtract_float4_values) | [✅](#plpgsql_subtract_float4_values✅) | [✅](#plv8_subtract_float4_values✅) | [✅](#plcsharp_subtract_float4_values✅) | [✅](#plpython3u_subtract_float4_values✅) | [✅](#plr_subtract_float4_values✅) | [✅](#plfsharp_subtract_float4_values✅) | [✅](#pllua_subtract_float4_values✅) | [❌](#plperl_subtract_float4_values❌) | [❌](#pltcl_subtract_float4_values❌) |
| [clamp_value](#clamp_value) | [✅](#plpgsql_clamp_value✅) | [✅](#plv8_clamp_value✅) | [✅](#plcsharp_clamp_value✅) | [✅](#plpython3u_clamp_value✅) | [✅](#plr_clamp_value✅) | [✅](#plfsharp_clamp_value✅) | [❌](#pllua_clamp_value❌) | [✅](#plperl_clamp_value✅) | [❌](#pltcl_clamp_value❌) |
| [calculate_float4_with_exponential_notation](#calculate_float4_with_exponential_notation) | [✅](#plpgsql_calculate_float4_with_exponential_notation✅) | [✅](#plv8_calculate_float4_with_exponential_notation✅) | [✅](#plcsharp_calculate_float4_with_exponential_notation✅) | [✅](#plpython3u_calculate_float4_with_exponential_notation✅) | [✅](#plr_calculate_float4_with_exponential_notation✅) | [✅](#plfsharp_calculate_float4_with_exponential_notation✅) | [❌](#pllua_calculate_float4_with_exponential_notation❌) | [❌](#plperl_calculate_float4_with_exponential_notation❌) | [❌](#pltcl_calculate_float4_with_exponential_notation❌) |
| [compute_tangent](#compute_tangent) | [✅](#plpgsql_compute_tangent✅) | [✅](#plv8_compute_tangent✅) | [✅](#plcsharp_compute_tangent✅) | [✅](#plpython3u_compute_tangent✅) | [✅](#plr_compute_tangent✅) | [❌](#plfsharp_compute_tangent❌) | [❌](#pllua_compute_tangent❌) | [✅](#plperl_compute_tangent✅) | [❌](#pltcl_compute_tangent❌) |
| [calculate_slope](#calculate_slope) | [✅](#plpgsql_calculate_slope✅) | [✅](#plv8_calculate_slope✅) | [✅](#plcsharp_calculate_slope✅) | [✅](#plpython3u_calculate_slope✅) | [✅](#plr_calculate_slope✅) | [❌](#plfsharp_calculate_slope❌) | [❌](#pllua_calculate_slope❌) | [❌](#plperl_calculate_slope❌) | [❌](#pltcl_calculate_slope❌) |
| [calculate_float4_ratio_and_sum](#calculate_float4_ratio_and_sum) | [✅](#plpgsql_calculate_float4_ratio_and_sum✅) | [✅](#plv8_calculate_float4_ratio_and_sum✅) | [✅](#plcsharp_calculate_float4_ratio_and_sum✅) | [✅](#plpython3u_calculate_float4_ratio_and_sum✅) | [✅](#plr_calculate_float4_ratio_and_sum✅) | [✅](#plfsharp_calculate_float4_ratio_and_sum✅) | [❌](#pllua_calculate_float4_ratio_and_sum❌) | [❌](#plperl_calculate_float4_ratio_and_sum❌) | [❌](#pltcl_calculate_float4_ratio_and_sum❌) |
| [calculate_arithmetic_progression_sum](#calculate_arithmetic_progression_sum) | [✅](#plpgsql_calculate_arithmetic_progression_sum✅) | [✅](#plv8_calculate_arithmetic_progression_sum✅) | [✅](#plcsharp_calculate_arithmetic_progression_sum✅) | [✅](#plpython3u_calculate_arithmetic_progression_sum✅) | [✅](#plr_calculate_arithmetic_progression_sum✅) | [✅](#plfsharp_calculate_arithmetic_progression_sum✅) | [✅](#pllua_calculate_arithmetic_progression_sum✅) | [❌](#plperl_calculate_arithmetic_progression_sum❌) | [❌](#pltcl_calculate_arithmetic_progression_sum❌) |
| [calculate_float4_ratio](#calculate_float4_ratio) | [✅](#plpgsql_calculate_float4_ratio✅) | [✅](#plv8_calculate_float4_ratio✅) | [✅](#plcsharp_calculate_float4_ratio✅) | [✅](#plpython3u_calculate_float4_ratio✅) | [✅](#plr_calculate_float4_ratio✅) | [✅](#plfsharp_calculate_float4_ratio✅) | [✅](#pllua_calculate_float4_ratio✅) | [❌](#plperl_calculate_float4_ratio❌) | [❌](#pltcl_calculate_float4_ratio❌) |
| [calculate_float4_exponential_decay](#calculate_float4_exponential_decay) | [✅](#plpgsql_calculate_float4_exponential_decay✅) | [❌](#plv8_calculate_float4_exponential_decay❌) | [❌](#plcsharp_calculate_float4_exponential_decay❌) | [❌](#plpython3u_calculate_float4_exponential_decay❌) | [✅](#plr_calculate_float4_exponential_decay✅) | [❌](#plfsharp_calculate_float4_exponential_decay❌) | [❌](#pllua_calculate_float4_exponential_decay❌) | [❌](#plperl_calculate_float4_exponential_decay❌) | [❌](#pltcl_calculate_float4_exponential_decay❌) |
| [test_float4_rounding](#test_float4_rounding) | [✅](#plpgsql_test_float4_rounding✅) | [✅](#plv8_test_float4_rounding✅) | [✅](#plcsharp_test_float4_rounding✅) | [✅](#plpython3u_test_float4_rounding✅) | [❌](#plr_test_float4_rounding❌) | [❌](#plfsharp_test_float4_rounding❌) | [✅](#pllua_test_float4_rounding✅) | [❌](#plperl_test_float4_rounding❌) | [❌](#pltcl_test_float4_rounding❌) |
| [calculate_hypotenuse](#calculate_hypotenuse) | [✅](#plpgsql_calculate_hypotenuse✅) | [✅](#plv8_calculate_hypotenuse✅) | [✅](#plcsharp_calculate_hypotenuse✅) | [✅](#plpython3u_calculate_hypotenuse✅) | [✅](#plr_calculate_hypotenuse✅) | [❌](#plfsharp_calculate_hypotenuse❌) | [✅](#pllua_calculate_hypotenuse✅) | [❌](#plperl_calculate_hypotenuse❌) | [❌](#pltcl_calculate_hypotenuse❌) |
| [calculate_float4_to_power_of_integer](#calculate_float4_to_power_of_integer) | [✅](#plpgsql_calculate_float4_to_power_of_integer✅) | [✅](#plv8_calculate_float4_to_power_of_integer✅) | [✅](#plcsharp_calculate_float4_to_power_of_integer✅) | [✅](#plpython3u_calculate_float4_to_power_of_integer✅) | [✅](#plr_calculate_float4_to_power_of_integer✅) | [✅](#plfsharp_calculate_float4_to_power_of_integer✅) | [❌](#pllua_calculate_float4_to_power_of_integer❌) | [✅](#plperl_calculate_float4_to_power_of_integer✅) | [❌](#pltcl_calculate_float4_to_power_of_integer❌) |
| [check_float4_within_tolerance](#check_float4_within_tolerance) | [✅](#plpgsql_check_float4_within_tolerance✅) | [✅](#plv8_check_float4_within_tolerance✅) | [✅](#plcsharp_check_float4_within_tolerance✅) | [✅](#plpython3u_check_float4_within_tolerance✅) | [✅](#plr_check_float4_within_tolerance✅) | [✅](#plfsharp_check_float4_within_tolerance✅) | [✅](#pllua_check_float4_within_tolerance✅) | [✅](#plperl_check_float4_within_tolerance✅) | [✅](#pltcl_check_float4_within_tolerance✅) |
| [calculate_percentage_difference](#calculate_percentage_difference) | [✅](#plpgsql_calculate_percentage_difference✅) | [✅](#plv8_calculate_percentage_difference✅) | [✅](#plcsharp_calculate_percentage_difference✅) | [✅](#plpython3u_calculate_percentage_difference✅) | [✅](#plr_calculate_percentage_difference✅) | [✅](#plfsharp_calculate_percentage_difference✅) | [❌](#pllua_calculate_percentage_difference❌) | [❌](#plperl_calculate_percentage_difference❌) | [❌](#pltcl_calculate_percentage_difference❌) |
| [is_negative](#is_negative) | [✅](#plpgsql_is_negative✅) | [✅](#plv8_is_negative✅) | [✅](#plcsharp_is_negative✅) | [✅](#plpython3u_is_negative✅) | [✅](#plr_is_negative✅) | [✅](#plfsharp_is_negative✅) | [✅](#pllua_is_negative✅) | [✅](#plperl_is_negative✅) | [❌](#pltcl_is_negative❌) |
| [calculate_float4_linear_intercept](#calculate_float4_linear_intercept) | [✅](#plpgsql_calculate_float4_linear_intercept✅) | [✅](#plv8_calculate_float4_linear_intercept✅) | [✅](#plcsharp_calculate_float4_linear_intercept✅) | [✅](#plpython3u_calculate_float4_linear_intercept✅) | [✅](#plr_calculate_float4_linear_intercept✅) | [✅](#plfsharp_calculate_float4_linear_intercept✅) | [❌](#pllua_calculate_float4_linear_intercept❌) | [❌](#plperl_calculate_float4_linear_intercept❌) | [❌](#pltcl_calculate_float4_linear_intercept❌) |
| [validate_even_float4](#validate_even_float4) | [✅](#plpgsql_validate_even_float4✅) | [✅](#plv8_validate_even_float4✅) | [✅](#plcsharp_validate_even_float4✅) | [✅](#plpython3u_validate_even_float4✅) | [✅](#plr_validate_even_float4✅) | [❌](#plfsharp_validate_even_float4❌) | [❌](#pllua_validate_even_float4❌) | [✅](#plperl_validate_even_float4✅) | [❌](#pltcl_validate_even_float4❌) |
| [validate_float4_within_range](#validate_float4_within_range) | [✅](#plpgsql_validate_float4_within_range✅) | [✅](#plv8_validate_float4_within_range✅) | [✅](#plcsharp_validate_float4_within_range✅) | [✅](#plpython3u_validate_float4_within_range✅) | [✅](#plr_validate_float4_within_range✅) | [✅](#plfsharp_validate_float4_within_range✅) | [✅](#pllua_validate_float4_within_range✅) | [✅](#plperl_validate_float4_within_range✅) | [❌](#pltcl_validate_float4_within_range❌) |
| [calculate_float4_remainder](#calculate_float4_remainder) | [✅](#plpgsql_calculate_float4_remainder✅) | [✅](#plv8_calculate_float4_remainder✅) | [✅](#plcsharp_calculate_float4_remainder✅) | [✅](#plpython3u_calculate_float4_remainder✅) | [✅](#plr_calculate_float4_remainder✅) | [✅](#plfsharp_calculate_float4_remainder✅) | [✅](#pllua_calculate_float4_remainder✅) | [✅](#plperl_calculate_float4_remainder✅) | [❌](#pltcl_calculate_float4_remainder❌) |
| [add_float4_values](#add_float4_values) | [✅](#plpgsql_add_float4_values✅) | [✅](#plv8_add_float4_values✅) | [✅](#plcsharp_add_float4_values✅) | [✅](#plpython3u_add_float4_values✅) | [✅](#plr_add_float4_values✅) | [✅](#plfsharp_add_float4_values✅) | [❌](#pllua_add_float4_values❌) | [❌](#plperl_add_float4_values❌) | [❌](#pltcl_add_float4_values❌) |
| [calculate_float4_complement](#calculate_float4_complement) | [✅](#plpgsql_calculate_float4_complement✅) | [✅](#plv8_calculate_float4_complement✅) | [✅](#plcsharp_calculate_float4_complement✅) | [✅](#plpython3u_calculate_float4_complement✅) | [✅](#plr_calculate_float4_complement✅) | [✅](#plfsharp_calculate_float4_complement✅) | [✅](#pllua_calculate_float4_complement✅) | [✅](#plperl_calculate_float4_complement✅) | [❌](#pltcl_calculate_float4_complement❌) |
| [calculate_sin](#calculate_sin) | [✅](#plpgsql_calculate_sin✅) | [✅](#plv8_calculate_sin✅) | [✅](#plcsharp_calculate_sin✅) | [✅](#plpython3u_calculate_sin✅) | [✅](#plr_calculate_sin✅) | [❌](#plfsharp_calculate_sin❌) | [✅](#pllua_calculate_sin✅) | [✅](#plperl_calculate_sin✅) | [❌](#pltcl_calculate_sin❌) |
| [check_float4_within_bounds](#check_float4_within_bounds) | [✅](#plpgsql_check_float4_within_bounds✅) | [✅](#plv8_check_float4_within_bounds✅) | [✅](#plcsharp_check_float4_within_bounds✅) | [✅](#plpython3u_check_float4_within_bounds✅) | [✅](#plr_check_float4_within_bounds✅) | [✅](#plfsharp_check_float4_within_bounds✅) | [❌](#pllua_check_float4_within_bounds❌) | [✅](#plperl_check_float4_within_bounds✅) | [❌](#pltcl_check_float4_within_bounds❌) |
| [calculate_logarithm](#calculate_logarithm) | [✅](#plpgsql_calculate_logarithm✅) | [✅](#plv8_calculate_logarithm✅) | [✅](#plcsharp_calculate_logarithm✅) | [✅](#plpython3u_calculate_logarithm✅) | [✅](#plr_calculate_logarithm✅) | [❌](#plfsharp_calculate_logarithm❌) | [❌](#pllua_calculate_logarithm❌) | [✅](#plperl_calculate_logarithm✅) | [❌](#pltcl_calculate_logarithm❌) |
| [is_float4_in_range](#is_float4_in_range) | [✅](#plpgsql_is_float4_in_range✅) | [✅](#plv8_is_float4_in_range✅) | [✅](#plcsharp_is_float4_in_range✅) | [✅](#plpython3u_is_float4_in_range✅) | [✅](#plr_is_float4_in_range✅) | [✅](#plfsharp_is_float4_in_range✅) | [✅](#pllua_is_float4_in_range✅) | [✅](#plperl_is_float4_in_range✅) | [❌](#pltcl_is_float4_in_range❌) |
| [calculate_float4_inverse](#calculate_float4_inverse) | [✅](#plpgsql_calculate_float4_inverse✅) | [✅](#plv8_calculate_float4_inverse✅) | [✅](#plcsharp_calculate_float4_inverse✅) | [✅](#plpython3u_calculate_float4_inverse✅) | [✅](#plr_calculate_float4_inverse✅) | [✅](#plfsharp_calculate_float4_inverse✅) | [✅](#pllua_calculate_float4_inverse✅) | [❌](#plperl_calculate_float4_inverse❌) | [❌](#pltcl_calculate_float4_inverse❌) |
| [calculate_linear_interpolation](#calculate_linear_interpolation) | [✅](#plpgsql_calculate_linear_interpolation✅) | [✅](#plv8_calculate_linear_interpolation✅) | [✅](#plcsharp_calculate_linear_interpolation✅) | [✅](#plpython3u_calculate_linear_interpolation✅) | [✅](#plr_calculate_linear_interpolation✅) | [✅](#plfsharp_calculate_linear_interpolation✅) | [✅](#pllua_calculate_linear_interpolation✅) | [❌](#plperl_calculate_linear_interpolation❌) | [❌](#pltcl_calculate_linear_interpolation❌) |
| [check_float4_equality](#check_float4_equality) | [✅](#plpgsql_check_float4_equality✅) | [✅](#plv8_check_float4_equality✅) | [✅](#plcsharp_check_float4_equality✅) | [✅](#plpython3u_check_float4_equality✅) | [✅](#plr_check_float4_equality✅) | [✅](#plfsharp_check_float4_equality✅) | [✅](#pllua_check_float4_equality✅) | [✅](#plperl_check_float4_equality✅) | [❌](#pltcl_check_float4_equality❌) |
| [compute_float4_quotient_and_remainder](#compute_float4_quotient_and_remainder) | [✅](#plpgsql_compute_float4_quotient_and_remainder✅) | [✅](#plv8_compute_float4_quotient_and_remainder✅) | [❌](#plcsharp_compute_float4_quotient_and_remainder❌) | [❌](#plpython3u_compute_float4_quotient_and_remainder❌) | [❌](#plr_compute_float4_quotient_and_remainder❌) | [❌](#plfsharp_compute_float4_quotient_and_remainder❌) | [❌](#pllua_compute_float4_quotient_and_remainder❌) | [❌](#plperl_compute_float4_quotient_and_remainder❌) | [❌](#pltcl_compute_float4_quotient_and_remainder❌) |
| [calculate_exponential_growth](#calculate_exponential_growth) | [✅](#plpgsql_calculate_exponential_growth✅) | [✅](#plv8_calculate_exponential_growth✅) | [❌](#plcsharp_calculate_exponential_growth❌) | [✅](#plpython3u_calculate_exponential_growth✅) | [✅](#plr_calculate_exponential_growth✅) | [❌](#plfsharp_calculate_exponential_growth❌) | [❌](#pllua_calculate_exponential_growth❌) | [❌](#plperl_calculate_exponential_growth❌) | [❌](#pltcl_calculate_exponential_growth❌) |
| [calculate_log_base_n](#calculate_log_base_n) | [✅](#plpgsql_calculate_log_base_n✅) | [✅](#plv8_calculate_log_base_n✅) | [✅](#plcsharp_calculate_log_base_n✅) | [✅](#plpython3u_calculate_log_base_n✅) | [✅](#plr_calculate_log_base_n✅) | [✅](#plfsharp_calculate_log_base_n✅) | [❌](#pllua_calculate_log_base_n❌) | [❌](#plperl_calculate_log_base_n❌) | [❌](#pltcl_calculate_log_base_n❌) |
| [calculate_float4_rounded_average](#calculate_float4_rounded_average) | [✅](#plpgsql_calculate_float4_rounded_average✅) | [✅](#plv8_calculate_float4_rounded_average✅) | [✅](#plcsharp_calculate_float4_rounded_average✅) | [❌](#plpython3u_calculate_float4_rounded_average❌) | [✅](#plr_calculate_float4_rounded_average✅) | [✅](#plfsharp_calculate_float4_rounded_average✅) | [❌](#pllua_calculate_float4_rounded_average❌) | [✅](#plperl_calculate_float4_rounded_average✅) | [❌](#pltcl_calculate_float4_rounded_average❌) |
| [is_float4_in_decreasing_order](#is_float4_in_decreasing_order) | [✅](#plpgsql_is_float4_in_decreasing_order✅) | [✅](#plv8_is_float4_in_decreasing_order✅) | [✅](#plcsharp_is_float4_in_decreasing_order✅) | [✅](#plpython3u_is_float4_in_decreasing_order✅) | [✅](#plr_is_float4_in_decreasing_order✅) | [✅](#plfsharp_is_float4_in_decreasing_order✅) | [✅](#pllua_is_float4_in_decreasing_order✅) | [❌](#plperl_is_float4_in_decreasing_order❌) | [✅](#pltcl_is_float4_in_decreasing_order✅) |
| [calculate_float4_inverse_square_root](#calculate_float4_inverse_square_root) | [✅](#plpgsql_calculate_float4_inverse_square_root✅) | [✅](#plv8_calculate_float4_inverse_square_root✅) | [✅](#plcsharp_calculate_float4_inverse_square_root✅) | [✅](#plpython3u_calculate_float4_inverse_square_root✅) | [❌](#plr_calculate_float4_inverse_square_root❌) | [❌](#plfsharp_calculate_float4_inverse_square_root❌) | [✅](#pllua_calculate_float4_inverse_square_root✅) | [✅](#plperl_calculate_float4_inverse_square_root✅) | [❌](#pltcl_calculate_float4_inverse_square_root❌) |
| [calculate_float4_as_percentage_of_another](#calculate_float4_as_percentage_of_another) | [✅](#plpgsql_calculate_float4_as_percentage_of_another✅) | [✅](#plv8_calculate_float4_as_percentage_of_another✅) | [✅](#plcsharp_calculate_float4_as_percentage_of_another✅) | [✅](#plpython3u_calculate_float4_as_percentage_of_another✅) | [✅](#plr_calculate_float4_as_percentage_of_another✅) | [✅](#plfsharp_calculate_float4_as_percentage_of_another✅) | [✅](#pllua_calculate_float4_as_percentage_of_another✅) | [❌](#plperl_calculate_float4_as_percentage_of_another❌) | [❌](#pltcl_calculate_float4_as_percentage_of_another❌) |
| [calculate_arccosine](#calculate_arccosine) | [✅](#plpgsql_calculate_arccosine✅) | [✅](#plv8_calculate_arccosine✅) | [✅](#plcsharp_calculate_arccosine✅) | [✅](#plpython3u_calculate_arccosine✅) | [✅](#plr_calculate_arccosine✅) | [❌](#plfsharp_calculate_arccosine❌) | [✅](#pllua_calculate_arccosine✅) | [❌](#plperl_calculate_arccosine❌) | [❌](#pltcl_calculate_arccosine❌) |
| [calculate_float4_logarithm_base2](#calculate_float4_logarithm_base2) | [✅](#plpgsql_calculate_float4_logarithm_base2✅) | [✅](#plv8_calculate_float4_logarithm_base2✅) | [✅](#plcsharp_calculate_float4_logarithm_base2✅) | [✅](#plpython3u_calculate_float4_logarithm_base2✅) | [✅](#plr_calculate_float4_logarithm_base2✅) | [❌](#plfsharp_calculate_float4_logarithm_base2❌) | [✅](#pllua_calculate_float4_logarithm_base2✅) | [❌](#plperl_calculate_float4_logarithm_base2❌) | [❌](#pltcl_calculate_float4_logarithm_base2❌) |
| [compute_square_root](#compute_square_root) | [✅](#plpgsql_compute_square_root✅) | [✅](#plv8_compute_square_root✅) | [✅](#plcsharp_compute_square_root✅) | [✅](#plpython3u_compute_square_root✅) | [✅](#plr_compute_square_root✅) | [❌](#plfsharp_compute_square_root❌) | [✅](#pllua_compute_square_root✅) | [✅](#plperl_compute_square_root✅) | [❌](#pltcl_compute_square_root❌) |
| [calculate_circumference](#calculate_circumference) | [✅](#plpgsql_calculate_circumference✅) | [✅](#plv8_calculate_circumference✅) | [✅](#plcsharp_calculate_circumference✅) | [✅](#plpython3u_calculate_circumference✅) | [✅](#plr_calculate_circumference✅) | [✅](#plfsharp_calculate_circumference✅) | [✅](#pllua_calculate_circumference✅) | [❌](#plperl_calculate_circumference❌) | [❌](#pltcl_calculate_circumference❌) |
| [calculate_float4_quotient_and_product](#calculate_float4_quotient_and_product) | [✅](#plpgsql_calculate_float4_quotient_and_product✅) | [✅](#plv8_calculate_float4_quotient_and_product✅) | [❌](#plcsharp_calculate_float4_quotient_and_product❌) | [✅](#plpython3u_calculate_float4_quotient_and_product✅) | [✅](#plr_calculate_float4_quotient_and_product✅) | [❌](#plfsharp_calculate_float4_quotient_and_product❌) | [✅](#pllua_calculate_float4_quotient_and_product✅) | [❌](#plperl_calculate_float4_quotient_and_product❌) | [❌](#pltcl_calculate_float4_quotient_and_product❌) |
| [calculate_distance_between_float4_points](#calculate_distance_between_float4_points) | [✅](#plpgsql_calculate_distance_between_float4_points✅) | [✅](#plv8_calculate_distance_between_float4_points✅) | [✅](#plcsharp_calculate_distance_between_float4_points✅) | [✅](#plpython3u_calculate_distance_between_float4_points✅) | [❌](#plr_calculate_distance_between_float4_points❌) | [✅](#plfsharp_calculate_distance_between_float4_points✅) | [❌](#pllua_calculate_distance_between_float4_points❌) | [✅](#plperl_calculate_distance_between_float4_points✅) | [❌](#pltcl_calculate_distance_between_float4_points❌) |
| [calculate_harmonic_mean](#calculate_harmonic_mean) | [✅](#plpgsql_calculate_harmonic_mean✅) | [✅](#plv8_calculate_harmonic_mean✅) | [✅](#plcsharp_calculate_harmonic_mean✅) | [✅](#plpython3u_calculate_harmonic_mean✅) | [✅](#plr_calculate_harmonic_mean✅) | [✅](#plfsharp_calculate_harmonic_mean✅) | [❌](#pllua_calculate_harmonic_mean❌) | [❌](#plperl_calculate_harmonic_mean❌) | [❌](#pltcl_calculate_harmonic_mean❌) |
| [float4_absolute_value_test](#float4_absolute_value_test) | [✅](#plpgsql_float4_absolute_value_test✅) | [✅](#plv8_float4_absolute_value_test✅) | [✅](#plcsharp_float4_absolute_value_test✅) | [✅](#plpython3u_float4_absolute_value_test✅) | [✅](#plr_float4_absolute_value_test✅) | [✅](#plfsharp_float4_absolute_value_test✅) | [✅](#pllua_float4_absolute_value_test✅) | [❌](#plperl_float4_absolute_value_test❌) | [❌](#pltcl_float4_absolute_value_test❌) |
| [test_cosine_float4](#test_cosine_float4) | [✅](#plpgsql_test_cosine_float4✅) | [✅](#plv8_test_cosine_float4✅) | [✅](#plcsharp_test_cosine_float4✅) | [❌](#plpython3u_test_cosine_float4❌) | [✅](#plr_test_cosine_float4✅) | [❌](#plfsharp_test_cosine_float4❌) | [✅](#pllua_test_cosine_float4✅) | [❌](#plperl_test_cosine_float4❌) | [❌](#pltcl_test_cosine_float4❌) |
| [calculate_float4_modulo](#calculate_float4_modulo) | [✅](#plpgsql_calculate_float4_modulo✅) | [✅](#plv8_calculate_float4_modulo✅) | [✅](#plcsharp_calculate_float4_modulo✅) | [✅](#plpython3u_calculate_float4_modulo✅) | [❌](#plr_calculate_float4_modulo❌) | [❌](#plfsharp_calculate_float4_modulo❌) | [❌](#pllua_calculate_float4_modulo❌) | [❌](#plperl_calculate_float4_modulo❌) | [❌](#pltcl_calculate_float4_modulo❌) |
| [calculate_thermal_expansion](#calculate_thermal_expansion) | [✅](#plpgsql_calculate_thermal_expansion✅) | [✅](#plv8_calculate_thermal_expansion✅) | [✅](#plcsharp_calculate_thermal_expansion✅) | [✅](#plpython3u_calculate_thermal_expansion✅) | [❌](#plr_calculate_thermal_expansion❌) | [✅](#plfsharp_calculate_thermal_expansion✅) | [✅](#pllua_calculate_thermal_expansion✅) | [❌](#plperl_calculate_thermal_expansion❌) | [❌](#pltcl_calculate_thermal_expansion❌) |
| [calculate_float4_dot_product](#calculate_float4_dot_product) | [✅](#plpgsql_calculate_float4_dot_product✅) | [✅](#plv8_calculate_float4_dot_product✅) | [✅](#plcsharp_calculate_float4_dot_product✅) | [✅](#plpython3u_calculate_float4_dot_product✅) | [✅](#plr_calculate_float4_dot_product✅) | [✅](#plfsharp_calculate_float4_dot_product✅) | [❌](#pllua_calculate_float4_dot_product❌) | [✅](#plperl_calculate_float4_dot_product✅) | [❌](#pltcl_calculate_float4_dot_product❌) |
| [calculate_ceil](#calculate_ceil) | [✅](#plpgsql_calculate_ceil✅) | [✅](#plv8_calculate_ceil✅) | [✅](#plcsharp_calculate_ceil✅) | [✅](#plpython3u_calculate_ceil✅) | [✅](#plr_calculate_ceil✅) | [✅](#plfsharp_calculate_ceil✅) | [✅](#pllua_calculate_ceil✅) | [❌](#plperl_calculate_ceil❌) | [❌](#pltcl_calculate_ceil❌) |
| [calculate_linear_intercept](#calculate_linear_intercept) | [✅](#plpgsql_calculate_linear_intercept✅) | [✅](#plv8_calculate_linear_intercept✅) | [✅](#plcsharp_calculate_linear_intercept✅) | [✅](#plpython3u_calculate_linear_intercept✅) | [✅](#plr_calculate_linear_intercept✅) | [✅](#plfsharp_calculate_linear_intercept✅) | [✅](#pllua_calculate_linear_intercept✅) | [✅](#plperl_calculate_linear_intercept✅) | [❌](#pltcl_calculate_linear_intercept❌) |
| [compute_circle_area](#compute_circle_area) | [✅](#plpgsql_compute_circle_area✅) | [✅](#plv8_compute_circle_area✅) | [✅](#plcsharp_compute_circle_area✅) | [❌](#plpython3u_compute_circle_area❌) | [✅](#plr_compute_circle_area✅) | [✅](#plfsharp_compute_circle_area✅) | [✅](#pllua_compute_circle_area✅) | [✅](#plperl_compute_circle_area✅) | [❌](#pltcl_compute_circle_area❌) |
| [calculate_float4_exponentiation](#calculate_float4_exponentiation) | [✅](#plpgsql_calculate_float4_exponentiation✅) | [✅](#plv8_calculate_float4_exponentiation✅) | [✅](#plcsharp_calculate_float4_exponentiation✅) | [✅](#plpython3u_calculate_float4_exponentiation✅) | [✅](#plr_calculate_float4_exponentiation✅) | [❌](#plfsharp_calculate_float4_exponentiation❌) | [❌](#pllua_calculate_float4_exponentiation❌) | [❌](#plperl_calculate_float4_exponentiation❌) | [❌](#pltcl_calculate_float4_exponentiation❌) |
| [calculate_float4_exponentiation_remainder](#calculate_float4_exponentiation_remainder) | [❌](#plpgsql_calculate_float4_exponentiation_remainder❌) | [✅](#plv8_calculate_float4_exponentiation_remainder✅) | [✅](#plcsharp_calculate_float4_exponentiation_remainder✅) | [✅](#plpython3u_calculate_float4_exponentiation_remainder✅) | [✅](#plr_calculate_float4_exponentiation_remainder✅) | [❌](#plfsharp_calculate_float4_exponentiation_remainder❌) | [❌](#pllua_calculate_float4_exponentiation_remainder❌) | [✅](#plperl_calculate_float4_exponentiation_remainder✅) | [❌](#pltcl_calculate_float4_exponentiation_remainder❌) |
| [calculate_inscribed_circle_area](#calculate_inscribed_circle_area) | [✅](#plpgsql_calculate_inscribed_circle_area✅) | [✅](#plv8_calculate_inscribed_circle_area✅) | [❌](#plcsharp_calculate_inscribed_circle_area❌) | [✅](#plpython3u_calculate_inscribed_circle_area✅) | [❌](#plr_calculate_inscribed_circle_area❌) | [❌](#plfsharp_calculate_inscribed_circle_area❌) | [❌](#pllua_calculate_inscribed_circle_area❌) | [✅](#plperl_calculate_inscribed_circle_area✅) | [✅](#pltcl_calculate_inscribed_circle_area✅) |
| [calculate_decibel_level](#calculate_decibel_level) | [✅](#plpgsql_calculate_decibel_level✅) | [✅](#plv8_calculate_decibel_level✅) | [✅](#plcsharp_calculate_decibel_level✅) | [✅](#plpython3u_calculate_decibel_level✅) | [✅](#plr_calculate_decibel_level✅) | [❌](#plfsharp_calculate_decibel_level❌) | [❌](#pllua_calculate_decibel_level❌) | [✅](#plperl_calculate_decibel_level✅) | [❌](#pltcl_calculate_decibel_level❌) |
| [test_increment_float4](#test_increment_float4) | [✅](#plpgsql_test_increment_float4✅) | [✅](#plv8_test_increment_float4✅) | [✅](#plcsharp_test_increment_float4✅) | [✅](#plpython3u_test_increment_float4✅) | [✅](#plr_test_increment_float4✅) | [✅](#plfsharp_test_increment_float4✅) | [✅](#pllua_test_increment_float4✅) | [✅](#plperl_test_increment_float4✅) | [❌](#pltcl_test_increment_float4❌) |
| [test_float4_truncation](#test_float4_truncation) | [✅](#plpgsql_test_float4_truncation✅) | [✅](#plv8_test_float4_truncation✅) | [✅](#plcsharp_test_float4_truncation✅) | [✅](#plpython3u_test_float4_truncation✅) | [✅](#plr_test_float4_truncation✅) | [✅](#plfsharp_test_float4_truncation✅) | [✅](#pllua_test_float4_truncation✅) | [✅](#plperl_test_float4_truncation✅) | [❌](#pltcl_test_float4_truncation❌) |
| [float4_min_value](#float4_min_value) | [✅](#plpgsql_float4_min_value✅) | [✅](#plv8_float4_min_value✅) | [✅](#plcsharp_float4_min_value✅) | [✅](#plpython3u_float4_min_value✅) | [✅](#plr_float4_min_value✅) | [✅](#plfsharp_float4_min_value✅) | [❌](#pllua_float4_min_value❌) | [✅](#plperl_float4_min_value✅) | [✅](#pltcl_float4_min_value✅) |
| [calculate_float4_percentage_change](#calculate_float4_percentage_change) | [✅](#plpgsql_calculate_float4_percentage_change✅) | [✅](#plv8_calculate_float4_percentage_change✅) | [✅](#plcsharp_calculate_float4_percentage_change✅) | [❌](#plpython3u_calculate_float4_percentage_change❌) | [✅](#plr_calculate_float4_percentage_change✅) | [✅](#plfsharp_calculate_float4_percentage_change✅) | [❌](#pllua_calculate_float4_percentage_change❌) | [❌](#plperl_calculate_float4_percentage_change❌) | [❌](#pltcl_calculate_float4_percentage_change❌) |
| [compare_float4_values](#compare_float4_values) | [✅](#plpgsql_compare_float4_values✅) | [✅](#plv8_compare_float4_values✅) | [✅](#plcsharp_compare_float4_values✅) | [✅](#plpython3u_compare_float4_values✅) | [✅](#plr_compare_float4_values✅) | [✅](#plfsharp_compare_float4_values✅) | [✅](#pllua_compare_float4_values✅) | [✅](#plperl_compare_float4_values✅) | [❌](#pltcl_compare_float4_values❌) |
| [normalize_float4_value](#normalize_float4_value) | [✅](#plpgsql_normalize_float4_value✅) | [✅](#plv8_normalize_float4_value✅) | [✅](#plcsharp_normalize_float4_value✅) | [✅](#plpython3u_normalize_float4_value✅) | [✅](#plr_normalize_float4_value✅) | [✅](#plfsharp_normalize_float4_value✅) | [✅](#pllua_normalize_float4_value✅) | [❌](#plperl_normalize_float4_value❌) | [❌](#pltcl_normalize_float4_value❌) |
| [calculate_scaled_value](#calculate_scaled_value) | [✅](#plpgsql_calculate_scaled_value✅) | [✅](#plv8_calculate_scaled_value✅) | [✅](#plcsharp_calculate_scaled_value✅) | [✅](#plpython3u_calculate_scaled_value✅) | [✅](#plr_calculate_scaled_value✅) | [✅](#plfsharp_calculate_scaled_value✅) | [✅](#pllua_calculate_scaled_value✅) | [✅](#plperl_calculate_scaled_value✅) | [❌](#pltcl_calculate_scaled_value❌) |
| [calculate_float4_max_absolute_difference](#calculate_float4_max_absolute_difference) | [✅](#plpgsql_calculate_float4_max_absolute_difference✅) | [✅](#plv8_calculate_float4_max_absolute_difference✅) | [✅](#plcsharp_calculate_float4_max_absolute_difference✅) | [✅](#plpython3u_calculate_float4_max_absolute_difference✅) | [✅](#plr_calculate_float4_max_absolute_difference✅) | [✅](#plfsharp_calculate_float4_max_absolute_difference✅) | [✅](#pllua_calculate_float4_max_absolute_difference✅) | [✅](#plperl_calculate_float4_max_absolute_difference✅) | [❌](#pltcl_calculate_float4_max_absolute_difference❌) |
| [calculate_product_of_float4](#calculate_product_of_float4) | [✅](#plpgsql_calculate_product_of_float4✅) | [✅](#plv8_calculate_product_of_float4✅) | [✅](#plcsharp_calculate_product_of_float4✅) | [✅](#plpython3u_calculate_product_of_float4✅) | [✅](#plr_calculate_product_of_float4✅) | [✅](#plfsharp_calculate_product_of_float4✅) | [✅](#pllua_calculate_product_of_float4✅) | [❌](#plperl_calculate_product_of_float4❌) | [❌](#pltcl_calculate_product_of_float4❌) |
| [calculate_float4_factorial](#calculate_float4_factorial) | [✅](#plpgsql_calculate_float4_factorial✅) | [✅](#plv8_calculate_float4_factorial✅) | [✅](#plcsharp_calculate_float4_factorial✅) | [✅](#plpython3u_calculate_float4_factorial✅) | [✅](#plr_calculate_float4_factorial✅) | [❌](#plfsharp_calculate_float4_factorial❌) | [❌](#pllua_calculate_float4_factorial❌) | [✅](#plperl_calculate_float4_factorial✅) | [❌](#pltcl_calculate_float4_factorial❌) |
| [calculate_float4_geometric_mean](#calculate_float4_geometric_mean) | [✅](#plpgsql_calculate_float4_geometric_mean✅) | [✅](#plv8_calculate_float4_geometric_mean✅) | [✅](#plcsharp_calculate_float4_geometric_mean✅) | [✅](#plpython3u_calculate_float4_geometric_mean✅) | [❌](#plr_calculate_float4_geometric_mean❌) | [❌](#plfsharp_calculate_float4_geometric_mean❌) | [✅](#pllua_calculate_float4_geometric_mean✅) | [❌](#plperl_calculate_float4_geometric_mean❌) | [❌](#pltcl_calculate_float4_geometric_mean❌) |
| [calculate_area_of_rectangle](#calculate_area_of_rectangle) | [✅](#plpgsql_calculate_area_of_rectangle✅) | [✅](#plv8_calculate_area_of_rectangle✅) | [✅](#plcsharp_calculate_area_of_rectangle✅) | [✅](#plpython3u_calculate_area_of_rectangle✅) | [✅](#plr_calculate_area_of_rectangle✅) | [✅](#plfsharp_calculate_area_of_rectangle✅) | [❌](#pllua_calculate_area_of_rectangle❌) | [✅](#plperl_calculate_area_of_rectangle✅) | [✅](#pltcl_calculate_area_of_rectangle✅) |
| [check_float4_is_positive](#check_float4_is_positive) | [✅](#plpgsql_check_float4_is_positive✅) | [✅](#plv8_check_float4_is_positive✅) | [✅](#plcsharp_check_float4_is_positive✅) | [✅](#plpython3u_check_float4_is_positive✅) | [✅](#plr_check_float4_is_positive✅) | [✅](#plfsharp_check_float4_is_positive✅) | [✅](#pllua_check_float4_is_positive✅) | [✅](#plperl_check_float4_is_positive✅) | [❌](#pltcl_check_float4_is_positive❌) |
| [calculate_arithmetic_mean](#calculate_arithmetic_mean) | [✅](#plpgsql_calculate_arithmetic_mean✅) | [✅](#plv8_calculate_arithmetic_mean✅) | [✅](#plcsharp_calculate_arithmetic_mean✅) | [✅](#plpython3u_calculate_arithmetic_mean✅) | [✅](#plr_calculate_arithmetic_mean✅) | [✅](#plfsharp_calculate_arithmetic_mean✅) | [❌](#pllua_calculate_arithmetic_mean❌) | [✅](#plperl_calculate_arithmetic_mean✅) | [✅](#pltcl_calculate_arithmetic_mean✅) |
| [calculate_logarithm_base_ten](#calculate_logarithm_base_ten) | [✅](#plpgsql_calculate_logarithm_base_ten✅) | [✅](#plv8_calculate_logarithm_base_ten✅) | [✅](#plcsharp_calculate_logarithm_base_ten✅) | [❌](#plpython3u_calculate_logarithm_base_ten❌) | [✅](#plr_calculate_logarithm_base_ten✅) | [❌](#plfsharp_calculate_logarithm_base_ten❌) | [❌](#pllua_calculate_logarithm_base_ten❌) | [❌](#plperl_calculate_logarithm_base_ten❌) | [❌](#pltcl_calculate_logarithm_base_ten❌) |
| [test_maximum_value](#test_maximum_value) | [✅](#plpgsql_test_maximum_value✅) | [✅](#plv8_test_maximum_value✅) | [✅](#plcsharp_test_maximum_value✅) | [✅](#plpython3u_test_maximum_value✅) | [✅](#plr_test_maximum_value✅) | [✅](#plfsharp_test_maximum_value✅) | [✅](#pllua_test_maximum_value✅) | [❌](#plperl_test_maximum_value❌) | [✅](#pltcl_test_maximum_value✅) |
| [calculate_float4_division](#calculate_float4_division) | [✅](#plpgsql_calculate_float4_division✅) | [✅](#plv8_calculate_float4_division✅) | [✅](#plcsharp_calculate_float4_division✅) | [✅](#plpython3u_calculate_float4_division✅) | [✅](#plr_calculate_float4_division✅) | [❌](#plfsharp_calculate_float4_division❌) | [✅](#pllua_calculate_float4_division✅) | [❌](#plperl_calculate_float4_division❌) | [❌](#pltcl_calculate_float4_division❌) |
| [calculate_euclidean_distance](#calculate_euclidean_distance) | [✅](#plpgsql_calculate_euclidean_distance✅) | [✅](#plv8_calculate_euclidean_distance✅) | [❌](#plcsharp_calculate_euclidean_distance❌) | [❌](#plpython3u_calculate_euclidean_distance❌) | [✅](#plr_calculate_euclidean_distance✅) | [❌](#plfsharp_calculate_euclidean_distance❌) | [❌](#pllua_calculate_euclidean_distance❌) | [❌](#plperl_calculate_euclidean_distance❌) | [❌](#pltcl_calculate_euclidean_distance❌) |
| [convert_to_radians](#convert_to_radians) | [✅](#plpgsql_convert_to_radians✅) | [✅](#plv8_convert_to_radians✅) | [✅](#plcsharp_convert_to_radians✅) | [✅](#plpython3u_convert_to_radians✅) | [✅](#plr_convert_to_radians✅) | [✅](#plfsharp_convert_to_radians✅) | [✅](#pllua_convert_to_radians✅) | [❌](#plperl_convert_to_radians❌) | [✅](#pltcl_convert_to_radians✅) |
| [calculate_float4_inverse_ratio](#calculate_float4_inverse_ratio) | [✅](#plpgsql_calculate_float4_inverse_ratio✅) | [✅](#plv8_calculate_float4_inverse_ratio✅) | [✅](#plcsharp_calculate_float4_inverse_ratio✅) | [✅](#plpython3u_calculate_float4_inverse_ratio✅) | [✅](#plr_calculate_float4_inverse_ratio✅) | [✅](#plfsharp_calculate_float4_inverse_ratio✅) | [❌](#pllua_calculate_float4_inverse_ratio❌) | [❌](#plperl_calculate_float4_inverse_ratio❌) | [❌](#pltcl_calculate_float4_inverse_ratio❌) |
| [average_of_float4_values](#average_of_float4_values) | [✅](#plpgsql_average_of_float4_values✅) | [✅](#plv8_average_of_float4_values✅) | [✅](#plcsharp_average_of_float4_values✅) | [✅](#plpython3u_average_of_float4_values✅) | [✅](#plr_average_of_float4_values✅) | [❌](#plfsharp_average_of_float4_values❌) | [❌](#pllua_average_of_float4_values❌) | [✅](#plperl_average_of_float4_values✅) | [✅](#pltcl_average_of_float4_values✅) |
| [calculate_float4_quadratic_sum](#calculate_float4_quadratic_sum) | [✅](#plpgsql_calculate_float4_quadratic_sum✅) | [✅](#plv8_calculate_float4_quadratic_sum✅) | [✅](#plcsharp_calculate_float4_quadratic_sum✅) | [✅](#plpython3u_calculate_float4_quadratic_sum✅) | [✅](#plr_calculate_float4_quadratic_sum✅) | [✅](#plfsharp_calculate_float4_quadratic_sum✅) | [❌](#pllua_calculate_float4_quadratic_sum❌) | [✅](#plperl_calculate_float4_quadratic_sum✅) | [❌](#pltcl_calculate_float4_quadratic_sum❌) |
| [calculate_quadratic_roots](#calculate_quadratic_roots) | [✅](#plpgsql_calculate_quadratic_roots✅) | [✅](#plv8_calculate_quadratic_roots✅) | [✅](#plcsharp_calculate_quadratic_roots✅) | [✅](#plpython3u_calculate_quadratic_roots✅) | [✅](#plr_calculate_quadratic_roots✅) | [✅](#plfsharp_calculate_quadratic_roots✅) | [❌](#pllua_calculate_quadratic_roots❌) | [❌](#plperl_calculate_quadratic_roots❌) | [❌](#pltcl_calculate_quadratic_roots❌) |
| [convert_float4_to_negative](#convert_float4_to_negative) | [✅](#plpgsql_convert_float4_to_negative✅) | [✅](#plv8_convert_float4_to_negative✅) | [✅](#plcsharp_convert_float4_to_negative✅) | [✅](#plpython3u_convert_float4_to_negative✅) | [✅](#plr_convert_float4_to_negative✅) | [✅](#plfsharp_convert_float4_to_negative✅) | [❌](#pllua_convert_float4_to_negative❌) | [❌](#plperl_convert_float4_to_negative❌) | [✅](#pltcl_convert_float4_to_negative✅) |
| [test_float4_power](#test_float4_power) | [✅](#plpgsql_test_float4_power✅) | [✅](#plv8_test_float4_power✅) | [❌](#plcsharp_test_float4_power❌) | [✅](#plpython3u_test_float4_power✅) | [✅](#plr_test_float4_power✅) | [❌](#plfsharp_test_float4_power❌) | [❌](#pllua_test_float4_power❌) | [❌](#plperl_test_float4_power❌) | [❌](#pltcl_test_float4_power❌) |
| [calculate_float4_ceil](#calculate_float4_ceil) | [✅](#plpgsql_calculate_float4_ceil✅) | [✅](#plv8_calculate_float4_ceil✅) | [✅](#plcsharp_calculate_float4_ceil✅) | [❌](#plpython3u_calculate_float4_ceil❌) | [✅](#plr_calculate_float4_ceil✅) | [❌](#plfsharp_calculate_float4_ceil❌) | [✅](#pllua_calculate_float4_ceil✅) | [❌](#plperl_calculate_float4_ceil❌) | [❌](#pltcl_calculate_float4_ceil❌) |
| [calculate_float4_precision](#calculate_float4_precision) | [✅](#plpgsql_calculate_float4_precision✅) | [✅](#plv8_calculate_float4_precision✅) | [✅](#plcsharp_calculate_float4_precision✅) | [✅](#plpython3u_calculate_float4_precision✅) | [✅](#plr_calculate_float4_precision✅) | [✅](#plfsharp_calculate_float4_precision✅) | [✅](#pllua_calculate_float4_precision✅) | [✅](#plperl_calculate_float4_precision✅) | [❌](#pltcl_calculate_float4_precision❌) |
| [combine_second_third_power](#combine_second_third_power) | [✅](#plpgsql_combine_second_third_power✅) | [✅](#plv8_combine_second_third_power✅) | [✅](#plcsharp_combine_second_third_power✅) | [✅](#plpython3u_combine_second_third_power✅) | [✅](#plr_combine_second_third_power✅) | [✅](#plfsharp_combine_second_third_power✅) | [❌](#pllua_combine_second_third_power❌) | [✅](#plperl_combine_second_third_power✅) | [❌](#pltcl_combine_second_third_power❌) |
| [is_float4_zero](#is_float4_zero) | [✅](#plpgsql_is_float4_zero✅) | [✅](#plv8_is_float4_zero✅) | [✅](#plcsharp_is_float4_zero✅) | [✅](#plpython3u_is_float4_zero✅) | [✅](#plr_is_float4_zero✅) | [✅](#plfsharp_is_float4_zero✅) | [✅](#pllua_is_float4_zero✅) | [✅](#plperl_is_float4_zero✅) | [❌](#pltcl_is_float4_zero❌) |
| [calculate_weight_force](#calculate_weight_force) | [✅](#plpgsql_calculate_weight_force✅) | [✅](#plv8_calculate_weight_force✅) | [✅](#plcsharp_calculate_weight_force✅) | [✅](#plpython3u_calculate_weight_force✅) | [✅](#plr_calculate_weight_force✅) | [✅](#plfsharp_calculate_weight_force✅) | [✅](#pllua_calculate_weight_force✅) | [✅](#plperl_calculate_weight_force✅) | [❌](#pltcl_calculate_weight_force❌) |


## Tests by language

This section includes the tests grouped by language.

### calculate

#### calculate_exponential_growth❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION calculate_exponential_growth(initial_value float8, growth_rate float8, "time" float8) RETURNS float8 AS $$
DECLARE
    growthRateDecimal float8;
    growthFactor float8;
    growthPowered float8;
    finalAmount float8;
    roundedFinalAmount float8;
BEGIN
    growthRateDecimal := growth_rate / 100;
    growthFactor := 1 + growthRateDecimal;
    growthPowered := POW(growthFactor, "time");
    finalAmount := initial_value * growthPowered;
    roundedFinalAmount := ROUND(finalAmount, 4);

    RETURN roundedFinalAmount;
END;
$$ LANGUAGE plpgsql;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'calculate_exponential_growth_10_year', plcsharp_calculate_exponential_growth(100.0::FLOAT4, 5.0::FLOAT4, 10.0::FLOAT4) = 162.889::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'calculate_exponential_growth_5_year', plcsharp_calculate_exponential_growth(1000.0::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 1159.274::FLOAT4;
```

### plcsharp

#### plcsharp_add_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_add_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
// name: add_float4_values
// description: Function that adds two float4 values and returns the result as float4
// type: float4
// input: float4 value to be added to value2
// input: float4 value to be added to value1
// output: Sum of value1 and value2 as float4

Elog.Info($"DEBUG: FUNCTION add_float4_values-1 - Running add_float4_values function with inputs 'value1' = {value1}, 'value2' = {value2}.");
float nonNullableValue1 = value1 ?? 0.0f;
float nonNullableValue2 = value2 ?? 0.0f;
float sum = nonNullableValue1 + nonNullableValue2;
Elog.Info($"DEBUG: FUNCTION add_float4_values-2 - Function add_float4_values is returning 'sum' = {sum}.");
return sum;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_add_float4_values1', plcsharp_add_float4_values(1.5::FLOAT4, 2.5::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_add_float4_values2', plcsharp_add_float4_values(-1.25::FLOAT4, 3.75::FLOAT4) = 2.5::FLOAT4;
```

#### plcsharp_average_of_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_average_of_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
// name: average_of_float4_values
// description: Calculates the average of two float4 values
// type: float4
// input: First float4 value
// input: Second float4 value
// output: The average value as float4

Elog.Info($"DEBUG: FUNCTION average_of_float4_values-1 - Running average_of_float4_values function with inputs 'value1' = {value1}, 'value2' = {value2}.");
float nonNullableValue1 = value1 ?? 0.0f;
if (value1 == null)
{
    Elog.Info($"DEBUG: FUNCTION average_of_float4_values-2 - 'value1' parameter is null.");
}
float nonNullableValue2 = value2 ?? 0.0f;
if (value2 == null)
{
    Elog.Info($"DEBUG: FUNCTION average_of_float4_values-3 - 'value2' parameter is null.");
}
float sum = nonNullableValue1 + nonNullableValue2;
float average = sum / 2;
Elog.Info($"DEBUG: FUNCTION average_of_float4_values-4 - Function average_of_float4_values is returning 'average' = {average}.");
return average;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'averageOfFloat4ValuesPositive', plcsharp_average_of_float4_values(4.0::FLOAT4, 8.0::FLOAT4) = 6.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'averageOfFloat4ValuesNegative', plcsharp_average_of_float4_values(-2.5::FLOAT4, -7.5::FLOAT4) = -5.0::FLOAT4;
```

#### plcsharp_calculate_arccosine✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_arccosine(value FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_arccosine
// description: Calculates the arccosine (inverse cosine) of a float4 value
// type: float4
// input: A float4 representing the cosine of an angle, range -1 to 1
// output: The arccosine of the input value as float4 in radians

Elog.Info($"DEBUG: FUNCTION calculate_arccosine_plcsharp-1 - Running calculate_arccosine function with input 'value' = {value}.");
if(value.HasValue && (value.Value < -1.0 || value.Value > 1.0))
{
    throw new ArgumentException("Input value should be in the range of -1 to 1 inclusive.");
}
float result = (float)Math.Acos(value.Value);
Elog.Info($"DEBUG: FUNCTION calculate_arccosine_plcsharp-2 - Function calculate_arccosine is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'calculateArccosineOf0', ROUND(plcsharp_calculate_arccosine(0::FLOAT4)::NUMERIC, 4) = CAST(1.5708 AS NUMERIC);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'calculateArccosineOf1', plcsharp_calculate_arccosine(1::FLOAT4) = float4 '0';
```

#### plcsharp_calculate_area_of_rectangle✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_area_of_rectangle(width FLOAT4, height FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_area_of_rectangle
// description: This function calculates the area of a rectangle given the width and height as float4 types and returns the area as float4
// type: float4
// input: float4 type representing the width of the rectangle
// input: float4 type representing the height of the rectangle
// output: float4 type representing the area of the rectangle

if (width.HasValue && height.HasValue)
{
    var area = width.GetValueOrDefault() * height.GetValueOrDefault();
    Elog.Info($"DEBUG: FUNCTION calculate_area_of_rectangle-1 - Running calculate_area_of_rectangle function with inputs 'width' = {width}, 'height' = {height}.");
    Elog.Info($"DEBUG: FUNCTION calculate_area_of_rectangle-2 - Function calculate_area_of_rectangle is returning 'area' = {area}.");
    return area;
}
else
{
    return null;
}
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_area_of_rectangle1', plcsharp_calculate_area_of_rectangle(4.0::FLOAT4, 3.0::FLOAT4) = 12.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_area_of_rectangle2', plcsharp_calculate_area_of_rectangle(0.0::FLOAT4, 5.0::FLOAT4) = 0.0::FLOAT4;
```

#### plcsharp_calculate_arithmetic_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_arithmetic_mean(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_arithmetic_mean
// description: Calculates arithmetic mean of two float4 values
// type: float4
// input: First float4 input value.
// input: Second float4 input value.
// output: Arithmetic mean result as float4.

Elog.Info($"DEBUG: FUNCTION calculate_arithmetic_mean-1 - Running calculate_arithmetic_mean function with inputs 'value1' = {value1}, 'value2' = {value2}.");
float? total = value1 + value2;
const int count = 2;
float result = total.HasValue ? total.Value / count : 0; 
Elog.Info($"DEBUG: FUNCTION calculate_arithmetic_mean-2 - Function calculate_arithmetic_mean is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateArithmeticMeanPositive', plcsharp_calculate_arithmetic_mean(3.5::FLOAT4, 2.5::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateArithmeticMeanMixedSign', plcsharp_calculate_arithmetic_mean(5.0::FLOAT4, -3.0::FLOAT4) = 1.0::FLOAT4;
```

#### plcsharp_calculate_arithmetic_progression_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_arithmetic_progression_sum(a float4, d float4, n float4) RETURNS float4 AS $$
// name: calculate_arithmetic_progression_sum
// description: Calculate the sum of the first n terms of an arithmetic progression, given the first term (a), the common difference (d), and the number of terms (n), returning the sum as float4.
// type: float4
// input: the first term of the arithmetic progression (float4)
// input: the common difference between the terms (float4)
// input: the number of terms to sum (float4)
// output: the sum of the first n terms of the arithmetic progression (float4)

Elog.Info($"DEBUG: FUNCTION calculate_arithmetic_progression_sum-1 - Running calculate_arithmetic_progression_sum function with inputs 'a' = {a}, 'd' = {d}, 'n' = {n}.");

float nonNullableA = a ?? 0.0f;
float nonNullableD = d ?? 0.0f;
float nonNullableN = n ?? 0.0f;

float nTimesA = nonNullableN * nonNullableA; 
float productOfCommonDifferenceAndTerms = nonNullableD * (nonNullableN - 1);
float sn = (nTimesA + productOfCommonDifferenceAndTerms * nonNullableN) / 2;

Elog.Info($"DEBUG: FUNCTION calculate_arithmetic_progression_sum-2 - Function calculate_arithmetic_progression_sum is returning 'sum' = {sn}.");
return sn;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateArithmeticProgressionSum1', plcsharp_calculate_arithmetic_progression_sum(2.0::FLOAT4, 2.0::FLOAT4, 5.0::FLOAT4) = 25.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateArithmeticProgressionSum2', plcsharp_calculate_arithmetic_progression_sum(1.5::FLOAT4, 1.5::FLOAT4, 3.0::FLOAT4) = 6.75::FLOAT4;
```

#### plcsharp_calculate_ceil✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_ceil(number FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_ceil
// description: This function calculates and returns the smallest integer greater than or equal to the given float4 number.
// type: float4
// input: A float4 number to calculate the ceiling value for
// output: The ceiling value of the input as float4

Elog.Info($"DEBUG: FUNCTION calculate_ceil_plcsharp-1 - Running calculate_ceil function with input 'number' = {number}.");
// Casting nullable float to float by using .Value assuming that the number will never be null
// This needs to be handled if 'number' can be null
float ceilingValue = (float)Math.Ceiling(number.Value);
Elog.Info($"DEBUG: FUNCTION calculate_ceil_plcsharp-2 - Function calculate_ceil is returning 'ceilingValue' = {ceilingValue}.");
return ceilingValue;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'calculateCeilPositiveFloat4', plcsharp_calculate_ceil(3.45::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'calculateCeilNegativeFloat4', plcsharp_calculate_ceil(-1.78::FLOAT4) = -1.0::FLOAT4;
```

#### plcsharp_calculate_circumference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_circumference(radius float4) RETURNS float4 AS $$
// name: calculate_circumference
// description: Calculates the circumference of a circle given the radius as float4
// type: float4
// input: The radius of the circle as float4
// output: The circumference of the circle as float4

Elog.Info($"DEBUG: FUNCTION calculate_circumference_plcsharp-1 - Calculating circumference with radius {radius}.");
const float PI = 3.1415926535f;
float diameter = radius.Value * 2;
float circumference = diameter * PI;
Elog.Info($"DEBUG: FUNCTION calculate_circumference_plcsharp-2 - Circumference calculated as {circumference}.");
return circumference;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateCircumferenceSmallRadius', plcsharp_calculate_circumference(2.0::FLOAT4) = 12.566370614::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateCircumferenceLargeRadius', plcsharp_calculate_circumference(100.0::FLOAT4) = 628.3185307179584::FLOAT4;
```

#### plcsharp_calculate_decibel_level✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_decibel_level(sound_pressure FLOAT4, reference_pressure FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_decibel_level
// description: Calculates the decibel level of a sound by comparing it to a reference sound pressure level.
// type: float4
// input: The sound pressure of the sound for which to determine the decibel level, as float4.
// input: The reference sound pressure which is typically the threshold of human hearing, as float4.
// output: The decibel level of the sound compared to the reference sound pressure, as float4.

Elog.Info($"DEBUG: FUNCTION calculate_decibel_level-1 - Running calculate_decibel_level function with inputs 'sound_pressure' = {sound_pressure}, 'reference_pressure' = {reference_pressure}.");

if (sound_pressure <= 0 || reference_pressure <= 0)
{
    throw new ArgumentException("Sound pressure and reference pressure must be positive.");
}

float ratio = (float)(sound_pressure / reference_pressure);
float decibelLevel = 20 * (float)Math.Log10(ratio);

Elog.Info($"DEBUG: FUNCTION calculate_decibel_level-2 - Function calculate_decibel_level is returning 'decibelLevel' = {decibelLevel}.");
return decibelLevel;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
  SELECT 'plcsharp-float4', 'test_calculate_decibel_level_1', 
  ROUND(plcsharp_calculate_decibel_level(1.0::FLOAT4, 0.00002::FLOAT4)) = 94.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
  SELECT 'plcsharp-float4', 'test_calculate_decibel_level_2', 
  plcsharp_calculate_decibel_level(0.00002::FLOAT4, 0.00002::FLOAT4) = 0.0::FLOAT4;
```

#### plcsharp_calculate_distance_between_float4_points✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_distance_between_float4_points(x1 float4, y1 float4, x2 float4, y2 float4) RETURNS float4 AS $$
// name: calculate_distance_between_float4_points
// description: Calculates the distance between two points in 2D space using float4 for coordinates
// type: float4
// input: The x-coordinate of the first point as a float4
// input: The y-coordinate of the first point as a float4
// input: The x-coordinate of the second point as a float4
// input: The y-coordinate of the second point as a float4
// output: The distance between the two points as a float4

Elog.Info($"DEBUG: FUNCTION calculate_distance_between_float4_points-1 - Running calculate_distance_between_float4_points function with inputs x1 = {x1}, y1 = {y1}, x2 = {x2}, y2 = {y2}.");
float nonNullableX1 = x1 ?? 0.0f;
float nonNullableY1 = y1 ?? 0.0f;
float nonNullableX2 = x2 ?? 0.0f;
float nonNullableY2 = y2 ?? 0.0f;

float deltaX = nonNullableX1 - nonNullableX2;
float deltaY = nonNullableY1 - nonNullableY2;
float squareDeltaX = (float)Math.Pow(deltaX, 2);
float squareDeltaY = (float)Math.Pow(deltaY, 2);
float sumOfSquares = squareDeltaX + squareDeltaY;
float distance = (float)Math.Sqrt(sumOfSquares);

Elog.Info($"DEBUG: FUNCTION calculate_distance_between_float4_points-2 - Function calculate_distance_between_float4_points is returning 'distance' = {distance}.");
return distance;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateDistanceBetweenFloat4PointsSame', plcsharp_calculate_distance_between_float4_points(0.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateDistanceBetweenFloat4PointsDifferent', plcsharp_calculate_distance_between_float4_points(3.0::FLOAT4, 4.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4) = 5.0::FLOAT4;
```

#### plcsharp_calculate_float4_as_percentage_of_another✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_as_percentage_of_another(value FLOAT4, total FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_as_percentage_of_another
// description: Calculates one float4 value as a percentage of another float4 value.
// type: float4
// input: The float4 number to calculate the percentage for
// input: The float4 number representing the total or 100%
// output: The percentage of 'value' relative to 'total' as float4

Elog.Info($"DEBUG: FUNCTION calculate_float4_as_percentage_of_another-1 - Running calculate_float4_as_percentage_of_another function with inputs 'value' = {value}, 'total' = {total}.");
if (total == 0.0f)
{
    Elog.Error("Error: 'total' cannot be zero.");
    return 0.0f; // Depending on desired behavior, you may throw an error instead.
}
float result = ((float)value / (float)total) * 100.0f;
Elog.Info($"DEBUG: FUNCTION calculate_float4_as_percentage_of_another-2 - Function calculate_float4_as_percentage_of_another is returning 'result' = {result}%.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4AsPercentageOfAnother1', plcsharp_calculate_float4_as_percentage_of_another(25.0::FLOAT4, 50.0::FLOAT4) = 50.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4AsPercentageOfAnother2', plcsharp_calculate_float4_as_percentage_of_another(1.0::FLOAT4, 200.0::FLOAT4) = 0.5::FLOAT4;
```

#### plcsharp_calculate_float4_ceil✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_ceil(value FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_ceil
// description: Function to calculate the smallest integer greater than or equal to the given float4 number
// type: float4
// input: float4 value to find the ceiling value for
// output: float4 representing the smallest integer greater than or equal to the input

Elog.Info($"DEBUG: FUNCTION calculate_float4_ceil-1 - Running calculate_float4_ceil function with input 'value' = {value}.");
float ceilingValue = (float)Math.Ceiling((double)value);
Elog.Info($"DEBUG: FUNCTION calculate_float4_ceil-2 - Function calculate_float4_ceil is returning 'ceilingValue' = {ceilingValue}.");
return ceilingValue;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'calculate_float4_ceil_positive', plcsharp_calculate_float4_ceil(3.45::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'calculate_float4_ceil_negative', plcsharp_calculate_float4_ceil(-2.8::FLOAT4) = -2.0::FLOAT4;
```

#### plcsharp_calculate_float4_complement✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_complement(number float4) RETURNS float4 AS $$
// name: calculate_float4_complement
// description: Calculates the complement of a float4 number with respect to 1, that is, it calculates 1 - n for a given float4 n.
// type: float4
// input: A float4 number which is the value to find the complement of.
// output: The complement of the input float4 number with respect to 1 as float4.

Elog.Info($"DEBUG: FUNCTION calculate_float4_complement-1 - Running calculate_float4_complement with input 'number' = {number}.");
float nonNullableNumber = (float)number;
float complement = 1.0f - nonNullableNumber;
Elog.Info($"DEBUG: FUNCTION calculate_float4_complement-2 - Function calculate_float4_complement is returning 'complement' = {complement}.");
return complement;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4Complement1', plcsharp_calculate_float4_complement(0.25::FLOAT4) = 0.75::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4Complement2', plcsharp_calculate_float4_complement(1.25::FLOAT4) = -0.25::FLOAT4;
```

#### plcsharp_calculate_float4_division✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_division(dividend float4, divisor float4) RETURNS float4 AS $$
// name: calculate_float4_division
// description: This function takes two float4 values and divides the first by the second, returning a float4.
// type: float4
// input: The float4 number to be divided
// input: The float4 number to divide by
// output: The result of the division as a float4

if (divisor == 0f)
{
    Elog.Error("ERROR: FUNCTION calculate_float4_division-1 - Division by zero attempted.");
    throw new Exception("Cannot divide by zero.");
}
Elog.Info($"DEBUG: FUNCTION calculate_float4_division-1 - Running calculate_float4_division function with inputs 'dividend' = {dividend}, 'divisor' = {divisor}.");
float result = (float)dividend / (float)divisor;
Elog.Info($"DEBUG: FUNCTION calculate_float4_division-2 - Function calculate_float4_division is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_float4_division_large_by_small', plcsharp_calculate_float4_division(10.5::FLOAT4, 2.5::FLOAT4) = 4.2::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_float4_division_small_by_large', plcsharp_calculate_float4_division(3.3::FLOAT4, 4.4::FLOAT4) = 0.75::FLOAT4;
```

#### plcsharp_calculate_float4_dot_product✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_dot_product(vector1_x float, vector1_y float, vector2_x float, vector2_y float) RETURNS float AS $$
// name: calculate_float4_dot_product
// description: Calculates the dot product of two 2D vectors, each vector component is a float4 type
// type: float4
// input: x component of the first vector (float4)
// input: y component of the first vector (float4)
// input: x component of the second vector (float4)
// input: y component of the second vector (float4)
// output: dot product of the two vectors (float4)

Elog.Info($"DEBUG: FUNCTION calculate_float4_dot_product_plcsharp-1 - Running calculate_float4_dot_product function with inputs 'vector1_x' = {vector1_x}, 'vector1_y' = {vector1_y}, 'vector2_x' = {vector2_x}, 'vector2_y' = {vector2_y}.");
float dotProduct = (float)(vector1_x * vector2_x + vector1_y * vector2_y);
Elog.Info($"DEBUG: FUNCTION calculate_float4_dot_product_plcsharp-2 - Function calculate_float4_dot_product is returning 'dotProduct' = {dotProduct}.");
return dotProduct;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4DotProductPerpendicular', plcsharp_calculate_float4_dot_product(1.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 1.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4DotProductParallel', plcsharp_calculate_float4_dot_product(1.0::FLOAT4, 1.0::FLOAT4, 2.0::FLOAT4, 2.0::FLOAT4) = 4.0::FLOAT4;
```

#### plcsharp_calculate_float4_exponential_decay❌
  

[Back to result table](#result-table)

```sql
-- CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_exponential_decay(initial_value float4, decay_rate float4, time float4) RETURNS float4 AS $$
-- // name: calculate_float4_exponential_decay
-- // description: Calculates the exponential decay based on initial value, decay rate, and time.
-- // type: float4
-- // input: Initial value of the quantity at time t0, as float4
-- // input: Decay rate, must be non-negative, as float4
-- // input: Time that has passed, as float4
-- // output: The quantity remaining after decay over the given time, as float4

-- if (decay_rate < 0.0f)
-- {
--     throw new ArgumentException("Decay rate must be non-negative");
-- }

-- Elog.Info($"DEBUG: FUNCTION calculate_float4_exponential_decay-1 - Running calculate_float4_exponential_decay function with inputs 'initial_value' = {initial_value}, 'decay_rate' = {decay_rate}, 'time' = {time}.");
-- float remaining_quantity = initial_value * (float)Math.Exp(-decay_rate * time);
-- Elog.Info($"DEBUG: FUNCTION calculate_float4_exponential_decay-2 - Function calculate_float4_exponential_decay is returning 'remaining_quantity' = {remaining_quantity}.");
-- return remaining_quantity;
-- $$ LANGUAGE plcsharp;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_float4_exponential_decay1', ROUND(plcsharp_calculate_float4_exponential_decay(100.0::FLOAT4, 0.5::FLOAT4, 10.0::FLOAT4)::NUMERIC, 5) = '6.73795'::NUMERIC;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_float4_exponential_decay2', ROUND(plcsharp_calculate_float4_exponential_decay(50.0::FLOAT4, 0.0::FLOAT4, 5.0::FLOAT4)::NUMERIC, 5) = '50.00000'::NUMERIC;
```

#### plcsharp_calculate_float4_exponentiation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_exponentiation(base_float FLOAT4, exponent FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_exponentiation
// description: Calculates the base raised to the power of exponent, both of float4 type, and returns float4
// type: float4
// input: float4 number to be raised to the power of the exponent
// input: float4 number representing the power
// output: float4 result of the exponentiation

Elog.Info($"DEBUG: FUNCTION calculate_float4_exponentiation-1 - Running calculate_float4_exponentiation function with 'base' = {base_float}, 'exponent' = {exponent}.");
float result;
if(exponent == 0.0f)
{
    result = 1.0f;
}
else if(base_float == 0.0f)
{
    result = 0.0f;
}
else
{
    result = (float)Math.Pow((double)base_float, (double)exponent);
}
Elog.Info($"DEBUG: FUNCTION calculate_float4_exponentiation-2 - Function calculate_float4_exponentiation is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4Exponentiation_PositiveBaseExponent', plcsharp_calculate_float4_exponentiation(2.5::FLOAT4, 3.0::FLOAT4) = 15.625::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4Exponentiation_NegativeBasePositiveExponent', plcsharp_calculate_float4_exponentiation(-3.0::FLOAT4, 2.0::FLOAT4) = 9.0::FLOAT4;
```

#### plcsharp_calculate_float4_exponentiation_remainder✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_exponentiation_remainder(base_value FLOAT4, exponent_value INT4, divisor_value FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_exponentiation_remainder
// description: Calculates the remainder of the exponentiation of a float4 base raised to an integer exponent when divided by a float4 divisor.
// type: float4
// input: the base value as float4
// input: the exponent value as integer
// input: the divisor value as float4
// output: the remainder as float4

Elog.Info($"DEBUG: FUNCTION calculate_float4_exponentiation_remainder_plcsharp-1 - Running calculate_float4_exponentiation_remainder function with inputs 'base_value' = {base_value}, 'exponent_value' = {exponent_value}, 'divisor_value' = {divisor_value}.");
if (exponent_value < 0) exponent_value = 0; // Treat negative exponents as zero.
float raisedValue = (float)Math.Pow((double)base_value, (double)exponent_value); // Raise base to the power of exponent.
float remainder = raisedValue % (float)divisor_value;
Elog.Info($"DEBUG: FUNCTION calculate_float4_exponentiation_remainder_plcsharp-2 - Function calculate_float4_exponentiation_remainder is returning 'remainder' = {remainder}.");
return remainder;

$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4ExponentiationRemainderPositive', ROUND(plcsharp_calculate_float4_exponentiation_remainder(2.5::FLOAT4, 3::INT4, 3.2::FLOAT4)::NUMERIC, 1) = 2.8::NUMERIC;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4ExponentiationRemainderNegativeExp', plcsharp_calculate_float4_exponentiation_remainder(5.1::FLOAT4, -2::INT4, 2.0::FLOAT4) = 1.0::FLOAT4;
```

#### plcsharp_calculate_float4_factorial✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_factorial(number float) RETURNS float AS $$
// name: calculate_float4_factorial
// description: Calculates the factorial of a non-negative float4 number, rounding down to the nearest whole value before computation.
// type: float4
// input: A non-negative float4 number to calculate the factorial of
// output: The factorial of the input number as float4, or 'undefined' if input is negative

Elog.Info($"DEBUG: FUNCTION calculate_float4_factorial-1 - Running calculate_float4_factorial function with input 'number' = {number}.");
float roundedNumber = (float)Math.Floor(number.Value);
if (roundedNumber < 0)
{
    Elog.Info($"DEBUG: FUNCTION calculate_float4_factorial-2 - Input 'number' = {roundedNumber} is negative. Returning 'undefined'.");
    throw new Exception("undefined"); // equivalent to returning 'undefined' for negative input
}

if (roundedNumber == 0 || roundedNumber == 1)
{
    Elog.Info($"DEBUG: FUNCTION calculate_float4_factorial-3 - Input 'number' = {roundedNumber} is 0 or 1. Returning 1.");
    return 1.0f;
}

float result = 1;
for (int i = 2; i <= roundedNumber; i++)
{
    Elog.Info($"DEBUG: FUNCTION calculate_float4_factorial-4 - Looping: i = {i}, result before = {result}.");
    result *= i;
    Elog.Info($"DEBUG: FUNCTION calculate_float4_factorial-5 - Looping: i = {i}, result after = {result}.");
}

Elog.Info($"DEBUG: FUNCTION calculate_float4_factorial-6 - Finished looping. Final result = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plcsharp-float4', 'test_calculate_float4_factorial_1', plcsharp_calculate_float4_factorial(0.85::FLOAT) = 1.0::FLOAT;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plcsharp-float4', 'test_calculate_float4_factorial_2', plcsharp_calculate_float4_factorial(5.75::FLOAT) = 120.0::FLOAT;
```

#### plcsharp_calculate_float4_geometric_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_geometric_mean(value1 float, value2 float) RETURNS float AS $$
// name: calculate_float4_geometric_mean
// description: Calculates the geometric mean of two float4 numbers and returns the result as float4
// type: float4
// input: The first positive float4 value
// input: The second positive float4 value
// output: The geometric mean of input float4 values as float4

// Check if both input values are greater than zero
if (value1 <= 0 || value2 <= 0)
{
    throw new InvalidOperationException("Both input values must be greater than zero.");
}

Elog.Info($"DEBUG: FUNCTION calculate_float4_geometric_mean-1 - Running calculate_float4_geometric_mean function with inputs 'value1' = {value1}, 'value2' = {value2}.");

// Calculate the product of the two input values
float product = (float)(value1 * value2);

// Take the square root of the product
float result = (float)Math.Sqrt(product);

Elog.Info($"DEBUG: FUNCTION calculate_float4_geometric_mean-2 - Function calculate_float4_geometric_mean is returning 'result' = {result}.");

return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4GeometricMean1', plcsharp_calculate_float4_geometric_mean(1.0::FLOAT4, 4.0::FLOAT4) = 2.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4GeometricMean2', plcsharp_calculate_float4_geometric_mean(1.0::FLOAT4, 10000.0::FLOAT4) = 100.0::FLOAT4;
```

#### plcsharp_calculate_float4_inverse✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_inverse(numeric_value FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_inverse
// description: Calculates the multiplicative inverse (or reciprocal) of a non-zero float4 number
// type: float4
// input: The float4 number to invert
// output: The multiplicative inverse of the input as float4, or 'undefined' if the input is zero

Elog.Info($"DEBUG: FUNCTION calculate_float4_inverse-1 - Running calculate_float4_inverse function with input 'numeric_value' = {numeric_value}.");
if (numeric_value == 0.0f)
{
    Elog.Info($"DEBUG: FUNCTION calculate_float4_inverse-2 - Input 'numeric_value' is zero. Returning 'undefined'.");
    throw new InvalidOperationException("Cannot calculate inverse of zero.");
}
else
{
    float inverse = 1.0f / numeric_value.Value;
    Elog.Info($"DEBUG: FUNCTION calculate_float4_inverse-3 - Calculated inverse 'inverse' = {inverse}.");
    return inverse;
}
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4Inverse1', plcsharp_calculate_float4_inverse(2.0::FLOAT4) = 0.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4Inverse2', plcsharp_calculate_float4_inverse(0.0::FLOAT4) IS NOT DISTINCT FROM 'undefined';
```

#### plcsharp_calculate_float4_inverse_ratio✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_inverse_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_inverse_ratio
// description: Calculates the inverse ratio of two float4 numbers, returns the result as float4.
// type: float4
// input: First float4 value, acting as the numerator
// input: Second float4 value, acting as the denominator, expected not to be zero
// output: The inverse ratio of the two float4 input values

Elog.Info($"DEBUG: FUNCTION calculate_float4_inverse_ratio-1 - Running calculate_float4_inverse_ratio function with inputs 'numerator' = {numerator}, 'denominator' = {denominator}.");
if (denominator == 0.0f)
{
    Elog.Info("DEBUG: FUNCTION calculate_float4_inverse_ratio-2 - Denominator is zero, cannot calculate inverse ratio.");
    throw new Exception("Denominator cannot be zero.");
}
float reciprocal = 1.0f / (float)denominator;
Elog.Info($"DEBUG: FUNCTION calculate_float4_inverse_ratio-3 - Reciprocal of 'denominator' = {reciprocal}.");
float result = reciprocal * (float)numerator;
Elog.Info($"DEBUG: FUNCTION calculate_float4_inverse_ratio-4 - Function calculate_float4_inverse_ratio is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4InverseRatioPositive', plcsharp_calculate_float4_inverse_ratio(2.0::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4InverseRatioZeroNumerator', plcsharp_calculate_float4_inverse_ratio(0.0::FLOAT4, 3.0::FLOAT4) = 0.0::FLOAT4;
```

#### plcsharp_calculate_float4_inverse_square_root✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_inverse_square_root(number FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_inverse_square_root
// description: Calculate the inverse square root of a float4 number
// type: float4
// input: The float4 number for which to find the inverse square root
// output: The inverse square root of the input number as float4

Elog.Info($"DEBUG: FUNCTION calculate_float4_inverse_square_root_plcsharp-1 - Running calculate_float4_inverse_square_root function with input 'number' = {number}.");

if (number <= 0.0f)
{
    Elog.Info($"DEBUG: FUNCTION calculate_float4_inverse_square_root_plcsharp-2 - Input 'number' is less than or equal to 0. Returning 'undefined'.");
    return float.NaN; // Assuming that 'undefined' should be represented as NaN in FLOAT4
}

float result = 1.0f / (float)Math.Sqrt((double)number);
Elog.Info($"DEBUG: FUNCTION calculate_float4_inverse_square_root_plcsharp-2 - Function calculate_float4_inverse_square_root is returning 'result' = {result}.");

return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4InverseSquareRootPositive', plcsharp_calculate_float4_inverse_square_root(4.0::FLOAT4) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4InverseSquareRootSmallPositive', plcsharp_calculate_float4_inverse_square_root(0.25::FLOAT4) = 2.0::FLOAT4;
```

#### plcsharp_calculate_float4_linear_intercept✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_linear_intercept(x1 FLOAT4, y1 FLOAT4, x2 FLOAT4, y2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_linear_intercept
// description: Calculates the y-intercept of a line (b) given two points with float4 coordinates (x1, y1) and (x2, y2). The formula used is b = y1 - (slope * x1), where slope is the (y2 - y1) / (x2 - x1).
// type: float4
// input: The x-coordinate of the first point as float4
// input: The y-coordinate of the first point as float4
// input: The x-coordinate of the second point as float4
// input: The y-coordinate of the second point as float4
// output: The y-intercept (b) of the line as float4

Elog.Info($"DEBUG: FUNCTION calculate_float4_linear_intercept-1 - Running calculate_float4_linear_intercept function with inputs 'x1' = {x1}, 'y1' = {y1}, 'x2' = {x2}, 'y2' = {y2}.");
if(x1 == x2)
{
    throw new Exception("Division by zero: x1 cannot be equal to x2");
}
float slope = (float)(y2.Value - y1.Value) / (float)(x2.Value - x1.Value);
float yIntercept = (float)(y1.Value - (slope * x1.Value));
Elog.Info($"DEBUG: FUNCTION calculate_float4_linear_intercept-2 - Function calculate_float4_linear_intercept is returning 'yIntercept' = {yIntercept}.");
return yIntercept;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'calculate_float4_linear_intercept_positive_slope', plcsharp_calculate_float4_linear_intercept(2.0::FLOAT4, 3.0::FLOAT4, 4.0::FLOAT4, 7.0::FLOAT4) = -1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'calculate_float4_linear_intercept_negative_slope', plcsharp_calculate_float4_linear_intercept(5.0::FLOAT4, 8.0::FLOAT4, 3.0::FLOAT4, 4.0::FLOAT4) = -2.0::FLOAT4;
```

#### plcsharp_calculate_float4_logarithm_base2✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_logarithm_base2(value float4) RETURNS float4 AS $$
// name: calculate_float4_logarithm_base2
// description: Calculates the base-2 logarithm of a given float4 number and returns the result as float4.
// type: float4
// input: The float4 number for which to calculate the base-2 logarithm
// output: The base-2 logarithm of the input float4 number

if (value <= 0)
{
    throw new ArgumentException("Input value must be positive.");
}

Elog.Info($"DEBUG: FUNCTION calculate_float4_logarithm_base2-1 - Running calculate_float4_logarithm_base2 function with input 'value' = {value}.");
float result = (float)Math.Log((double)value, 2);
Elog.Info($"DEBUG: FUNCTION calculate_float4_logarithm_base2-2 - Function calculate_float4_logarithm_base2 is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4LogarithmBase2_PositiveValue1', plcsharp_calculate_float4_logarithm_base2(8.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4LogarithmBase2_PositiveValue2', plcsharp_calculate_float4_logarithm_base2(2.0::FLOAT4) = 1.0::FLOAT4;
```

#### plcsharp_calculate_float4_max_absolute_difference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_max_absolute_difference(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_max_absolute_difference
// description: This function calculates the maximum absolute difference between two float4 values
// type: float4
// input: The first float4 input value
// input: The second float4 input value
// output: The maximum absolute difference as float4

Elog.Info($"DEBUG: FUNCTION calculate_float4_max_absolute_difference-1 - Running calculate_float4_max_absolute_difference function with inputs 'input1' = {input1}, 'input2' = {input2}.");
float absDiff1 = Math.Abs((float)input1 - (float)input2);
float absDiff2 = Math.Abs((float)input2 - (float)input1);
float maxDiff = Math.Max(absDiff1, absDiff2);
Elog.Info($"DEBUG: FUNCTION calculate_float4_max_absolute_difference-2 - Function calculate_float4_max_absolute_difference is returning 'maxDiff' = {maxDiff}.");
return maxDiff;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'calculate_float4_max_absolute_difference1', plcsharp_calculate_float4_max_absolute_difference('5.5'::FLOAT4, '3.0'::FLOAT4) = '2.5'::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'calculate_float4_max_absolute_difference2', ROUND(CAST(plcsharp_calculate_float4_max_absolute_difference(2.2::FLOAT4, 4.8::FLOAT4) AS NUMERIC), 1) = 2.6::NUMERIC;
```

#### plcsharp_calculate_float4_modulo✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_modulo(dividend FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_modulo
// description: Calculates the modulo (the remainder of division) of two float4 values and returns the result as float4
// type: float4
// input: The number that is to be divided (dividend) as float4
// input: The number by which the dividend is to be divided (divisor) as float4
// output: The remainder of the division of the two float4 inputs

if (divisor == 0.0f)
{
    Elog.Error("ERROR: FUNCTION calculate_float4_modulo_plcsharp - Divisor cannot be zero.");
    return 0.0f; // Changed from 'null' to '0.0f' because the return type is non-nullable
}

float? nullableDividend = dividend;
float? nullableDivisor = divisor;
Elog.Info($"DEBUG: FUNCTION calculate_float4_modulo_plcsharp-1 - Running calculate_float4_modulo function with inputs 'dividend' = {nullableDividend}, 'divisor' = {nullableDivisor}.");
float quotient = (float)(nullableDividend / nullableDivisor); // Added explicit cast
float result = (float)(nullableDividend - (quotient * nullableDivisor)); // Added explicit cast
Elog.Info($"DEBUG: FUNCTION calculate_float4_modulo_plcsharp-2 - Function calculate_float4_modulo_plcsharp is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4ModuloPositives', plcsharp_calculate_float4_modulo(8.75::FLOAT4, 3.5::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4ModuloNegativeDividend', plcsharp_calculate_float4_modulo(-5.25::FLOAT4, 2.0::FLOAT4) = 0::FLOAT4;
```

#### plcsharp_calculate_float4_percentage_change✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_percentage_change(old_value FLOAT4, new_value FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_percentage_change
// description: Calculates the percentage change from float4 old_value to float4 new_value.
// type: float4
// input: The original float4 value
// input: The new float4 value to compare against the old value
// output: The percentage change as float4

Elog.Info($"DEBUG: FUNCTION calculate_float4_percentage_change-1 - Running calculate_float4_percentage_change function with inputs 'old_value' = {old_value}, 'new_value' = {new_value}.");
if (old_value == 0.0f)
{
    throw new InvalidOperationException("old_value cannot be zero to avoid division by zero.");
}

float result = ((new_value.Value - old_value.Value) / old_value.Value) * 100.0f;
Elog.Info($"DEBUG: FUNCTION calculate_float4_percentage_change-2 - Function calculate_float4_percentage_change is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4PercentageChange1', plcsharp_calculate_float4_percentage_change(50.0::FLOAT4, 75.0::FLOAT4) = 50.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4PercentageChange2', ROUND(plcsharp_calculate_float4_percentage_change(75.0::FLOAT4, 50.0::FLOAT4)::NUMERIC, 4) = ROUND(-33.333336::NUMERIC, 4);
```

#### plcsharp_calculate_float4_precision✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_precision(number FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_precision
// description: Calculates the precision (number of decimal places) of a float4 number
// type: float4
// input: A float4 number to calculate the precision of
// output: The precision (number of decimal places) of the number as float4

Elog.Info($"DEBUG: FUNCTION calculateFloat4Precision-1 - Running calculate_float4_precision function with input 'number' = {number}.");
string numberStr = number.ToString();
int precision = 0;
int decimalPointIndex = numberStr.IndexOf('.');
if (decimalPointIndex != -1)
{
    precision = numberStr.Length - decimalPointIndex - 1;
}
Elog.Info($"DEBUG: FUNCTION calculateFloat4Precision-2 - Function calculate_float4_precision is returning 'precision' = {precision}.");
return (float)precision;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4Precision1', plcsharp_calculate_float4_precision(123.45::FLOAT4) = 2.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4Precision2', plcsharp_calculate_float4_precision(456.0::FLOAT4) = 0.0::FLOAT4;
```

#### plcsharp_calculate_float4_quadratic_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_quadratic_sum(num1 FLOAT4, num2 FLOAT4, num3 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_quadratic_sum
// description: Calculates the sum of squares of three float4 numbers and returns the result as float4.
// type: float4
// input: First float4 number
// input: Second float4 number
// input: Third float4 number
// output: Sum of squares of num1, num2, and num3 as float4

Elog.Info($"DEBUG: FUNCTION calculate_float4_quadratic_sum-1 - Running plcsharp_calculate_float4_quadratic_sum function with inputs 'num1' = {num1}, 'num2' = {num2}, 'num3' = {num3}.");
float result1 = (float)num1 * (float)num1;
float result2 = (float)num2 * (float)num2;
float result3 = (float)num3 * (float)num3;
float sum_of_squares = result1 + result2 + result3;
Elog.Info($"DEBUG: FUNCTION calculate_float4_quadratic_sum-2 - Function plcsharp_calculate_float4_quadratic_sum is returning 'sum_of_squares' = {sum_of_squares}.");
return sum_of_squares;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4QuadraticSumPositive', plcsharp_calculate_float4_quadratic_sum(3.0::FLOAT4, 4.0::FLOAT4, 5.0::FLOAT4) = 50.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4QuadraticSumMixed', plcsharp_calculate_float4_quadratic_sum(-3.0::FLOAT4, 4.0::FLOAT4, -5.0::FLOAT4) = 50.0::FLOAT4;
```

#### plcsharp_calculate_float4_ratio✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_ratio
// description: Calculates the ratio of two float4 numbers and returns the result as float4. Ratio is the result of dividing the first float4 value by the second, provided the second is not zero.
// type: float4
// input: The numerator for the ratio calculation. Type: float4
// input: The denominator for the ratio calculation. Type: float4. Must not be zero.
// output: The calculated ratio as float4. If the denominator is zero, the function will return 'undefined'.

Elog.Info($"DEBUG: FUNCTION calculate_float4_ratio-1 - Running calculate_float4_ratio function with inputs 'numerator' = {numerator}, 'denominator' = {denominator}.");

float result;
if (denominator == 0.0f)
{
    Elog.Info("DEBUG: FUNCTION calculate_float4_ratio-2 - 'denominator' parameter is zero, therefore the result is 'undefined'.");
    return null; // Assuming 'undefined' means returning NULL in the context of PL/C#
}
else
{
    result = (float)(numerator / denominator);
    Elog.Info($"DEBUG: FUNCTION calculate_float4_ratio-3 - Function calculate_float4_ratio is returning 'result' = {result}.");
    return result;
}
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4RatioPositive', plcsharp_calculate_float4_ratio(25.0::FLOAT4, 5.0::FLOAT4) = 5.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4RatioZeroDenominator', plcsharp_calculate_float4_ratio(10.0::FLOAT4, 0.0::FLOAT4) IS NULL;
```

#### plcsharp_calculate_float4_ratio_and_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_ratio_and_sum(number1 FLOAT4, number2 FLOAT4) RETURNS TABLE(ratio FLOAT4, sum FLOAT4) AS $$
// name: calculate_float4_ratio_and_sum
// description: Calculates the ratio of two float4 numbers and their sum
// type: float4
// input: First float4 number
// input: Second float4 number, cannot be zero as it will be used as divisor
// output: An object with the ratio and sum of the two float4 numbers

Elog.Info($"DEBUG: FUNCTION calculate_float4_ratio_and_sum-1 - Running calculate_float4_ratio_and_sum function with inputs 'number1' = {number1}, 'number2' = {number2}.");

if (number2 == 0.0f)
{
    throw new Exception("Division by zero is not allowed.");
}

float ratio = number1.Value / number2.Value;
float sum = number1.Value + number2.Value;

Elog.Info($"DEBUG: FUNCTION calculate_float4_ratio_and_sum-2 - Ratio calculated as 'ratio' = {ratio}.");
Elog.Info($"DEBUG: FUNCTION calculate_float4_ratio_and_sum-3 - Sum calculated as 'sum' = {sum}.");

yield return (ratio, sum);
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT)
SELECT 'plcsharp-float4', 'calculate_float4_ratio_and_sum1', 
(SELECT (ratio, sum) = (ratio, sum) FROM plcsharp_calculate_float4_ratio_and_sum(6.0::FLOAT4, 3.0::FLOAT4));
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 
    'plcsharp-float4', 
    'calculate_float4_ratio_and_sum2', 
    (SELECT ratio FROM plcsharp_calculate_float4_ratio_and_sum(-8.0::FLOAT4, 4.0::FLOAT4)) = -2.0::FLOAT4 
    AND 
    (SELECT sum FROM plcsharp_calculate_float4_ratio_and_sum(-8.0::FLOAT4, 4.0::FLOAT4)) = -4.0::FLOAT4;
```

#### plcsharp_calculate_float4_remainder✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_remainder(dividend FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_remainder
// description: Calculates the remainder of division between two float4 numbers
// type: float4
// input: float4 value representing the dividend
// input: float4 value representing the divisor
// output: float4 value representing the remainder of the division

Elog.Info($"DEBUG: FUNCTION calculate_float4_remainder_plcsharp-1 - Running calculate_float4_remainder function with inputs 'dividend' = {dividend} and 'divisor' = {divisor}.");
if (Math.Abs(divisor.Value) < 1E-07) // Assuming float4 corresponds to System.Single with 7 digits precision
{
    Elog.Info($"DEBUG: FUNCTION calculate_float4_remainder_plcsharp-2 - Division by zero encountered.");
    throw new DivideByZeroException("Attempt to divide by zero.");
}
float remainder = (float)(dividend.Value % divisor.Value);
Elog.Info($"DEBUG: FUNCTION calculate_float4_remainder_plcsharp-3 - Function calculate_float4_remainder is returning 'remainder' = {remainder}.");
return remainder;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'calculateFloat4RemainderPositive', plcsharp_calculate_float4_remainder(5.0::FLOAT4, 2.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'calculateFloat4Remainder', ABS(plcsharp_calculate_float4_remainder(5.0::FLOAT4, 2.0::FLOAT4) - 1.0::FLOAT4) < 1e-7;
```

#### plcsharp_calculate_float4_rounded_average✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_rounded_average(value1 float4, value2 float4) RETURNS float4 AS $$
// name: calculate_float4_rounded_average
// description: Calculate the average of two float4 values and round it to the nearest whole number, returning the result as a float4
// type: float4
// input: The first float4 value for the average calculation
// input: The second float4 value for the average calculation
// output: The rounded average of value1 and value2 as a float4

Elog.Info($"DEBUG: FUNCTION calculate_float4_rounded_average-1 - Running calculate_float4_rounded_average function with inputs 'value1' = {value1}, 'value2' = {value2}.");
float nonNullableValue1 = value1 ?? 0.0f;
float nonNullableValue2 = value2 ?? 0.0f;
float average = (nonNullableValue1 + nonNullableValue2) / 2.0f;
float roundedAverage = (float)Math.Round(average);
Elog.Info($"DEBUG: FUNCTION calculate_float4_rounded_average-2 - Function calculate_float4_rounded_average is returning 'roundedAverage' = {roundedAverage}.");
return roundedAverage;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_float4_rounded_average_positive', plcsharp_calculate_float4_rounded_average(25.4::FLOAT4, 34.6::FLOAT4) = 30.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_float4_rounded_average_mixed', plcsharp_calculate_float4_rounded_average(-14.8::FLOAT4, 20.2::FLOAT4) = 3.0::FLOAT4;
```

#### plcsharp_calculate_float4_to_power_of_integer✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_to_power_of_integer(float4_base float4, integer_exponent int4) RETURNS float4 AS $$
// name: calculate_float4_to_power_of_integer
// description: This function takes a float4 base number and an integer exponent, then raises the base to the power of the exponent returning a float4 result
// type: float4
// input: float4 number serving as the base for the power operation
// input: Integer serving as the exponent for the power operation
// output: float4 result of the base raised to the power of the exponent

Elog.Info($"DEBUG: FUNCTION calculate_float4_to_power_of_integer-1 - Running calculate_float4_to_power_of_integer function with inputs 'float4_base' = {float4_base}, 'integer_exponent' = {integer_exponent}.");
float result = (float)Math.Pow((float)float4_base, (int)integer_exponent);
Elog.Info($"DEBUG: FUNCTION calculate_float4_to_power_of_integer-2 - Function calculate_float4_to_power_of_integer is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4ToPowerOfInteger1', plcsharp_calculate_float4_to_power_of_integer(2.5::float4, 3::int4) = 15.625::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateFloat4ToPowerOfInteger2', plcsharp_calculate_float4_to_power_of_integer(7.0::float4, 0::int4) = 1.0::float4;
```

#### plcsharp_calculate_float4_with_exponential_notation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_float4_with_exponential_notation(number FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_with_exponential_notation
// description: Converts a float4 number in exponential notation to a float4 number in standard decimal notation
// type: float4
// input: float4 number in exponential notation
// output: float4 number in standard decimal notation

Elog.Info($"DEBUG: FUNCTION calculate_float4_with_exponential_notation-1 - Running calculate_float4_with_exponential_notation function with input 'number' = {number}.");
float result = (float)number;
Elog.Info($"DEBUG: FUNCTION calculate_float4_with_exponential_notation-2 - Function calculate_float4_with_exponential_notation is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'calculateFloat4WithExponentialNotation1', plcsharp_calculate_float4_with_exponential_notation('2.5e-4'::FLOAT4) = '0.00025'::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'calculateFloat4WithExponentialNotation2', plcsharp_calculate_float4_with_exponential_notation('3.57e+2'::FLOAT4) = '357.0'::FLOAT4;
```

#### plcsharp_calculate_harmonic_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_harmonic_mean(number1 FLOAT4, number2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_harmonic_mean
// description: Calculates the harmonic mean of two float4 numbers
// type: float4
// input: First float4 number
// input: Second float4 number
// output: Harmonic mean of the two float4 numbers as float4

Elog.Info($"DEBUG: FUNCTION calculate_harmonic_mean_plcsharp-1 - Running calculate_harmonic_mean function with inputs 'number1' = {number1}, 'number2' = {number2}.");
if (number1 == 0 || number2 == 0)
{
    Elog.Info("DEBUG: FUNCTION calculate_harmonic_mean_plcsharp-2 - One of the inputs is 0, returning 'undefined'.");
    return -1; // Using -1 to represent 'undefined', as FLOAT4 cannot be NULL
}
float reciprocalSum = (1 / (float)number1) + (1 / (float)number2);
float result = 2 / reciprocalSum;
Elog.Info($"DEBUG: FUNCTION calculate_harmonic_mean_plcsharp-3 - Function calculate_harmonic_mean is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateHarmonicMeanPositive', plcsharp_calculate_harmonic_mean(4.0::FLOAT4, 8.0::FLOAT4) = 5.3333334::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateHarmonicMeanWithZero', plcsharp_calculate_harmonic_mean(0.0::FLOAT4, 5.0::FLOAT4) = -1::FLOAT4;
-- --HERE we are using -1 as the representation of 'undefined'
```

#### plcsharp_calculate_hypotenuse✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_hypotenuse(a float4, b float4) RETURNS float4 AS $$
// name: calculate_hypotenuse
// description: Calculates the length of the hypotenuse of a right-angled triangle using the Pythagorean theorem
// type: float4
// input: length of side a as float4
// input: length of side b as float4
// output: length of the hypotenuse as float4

Elog.Info($"DEBUG: FUNCTION calculate_hypotenuse_plcsharp-1 - Running calculate_hypotenuse_plcsharp function with inputs 'a' = {a}, 'b' = {b}.");
float nonNullableA = a ?? 0.0f;
float nonNullableB = b ?? 0.0f;
float aSquared = nonNullableA * nonNullableA;
float bSquared = nonNullableB * nonNullableB;
float sumOfSquares = aSquared + bSquared;
float result = (float)Math.Sqrt(sumOfSquares);
Elog.Info($"DEBUG: FUNCTION calculate_hypotenuse_plcsharp-2 - Function calculate_hypotenuse_plcsharp is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateHypotenuse1', plcsharp_calculate_hypotenuse(3.0::FLOAT4, 4.0::FLOAT4) = 5.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateHypotenuse2', plcsharp_calculate_hypotenuse(5.0::FLOAT4, 12.0::FLOAT4) = 13.0::FLOAT4;
```

#### plcsharp_calculate_linear_intercept✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_linear_intercept(x1 FLOAT4, y1 FLOAT4, m FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_linear_intercept
// description: Calculates the y-intercept (b) of a linear equation in the form y = mx + b using a point (x1, y1) and the slope (m)
// type: float4
// input: float4 - the x-coordinate of the point
// input: float4 - the y-coordinate of the point
// input: float4 - the slope of the line
// output: float4 - the y-intercept of the line

float b = y1.Value - (m.Value * x1.Value);
return b;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_linear_intercept1', plcsharp_calculate_linear_intercept(3.0::FLOAT4, 4.0::FLOAT4, 2.0::FLOAT4) = -2.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_linear_intercept2', plcsharp_calculate_linear_intercept(-1.0::FLOAT4, -3.0::FLOAT4, -2.0::FLOAT4) = -5.0::FLOAT4;
```

#### plcsharp_calculate_linear_interpolation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_linear_interpolation(value1 FLOAT4, value2 FLOAT4, fraction FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_linear_interpolation
// description: Interpolates between two float4 values at a specific increment
// type: float4
// input: starting float4 value for interpolation
// input: ending float4 value for interpolation
// input: the float4 fraction representing the interpolation point between value1 and value2
// output: interpolated float4 value

Elog.Info($"DEBUG: FUNCTION calculate_linear_interpolation-1 - Running calculate_linear_interpolation function with inputs 'value1' = {value1}, 'value2' = {value2}, 'fraction' = {fraction}.");
if (fraction < 0.0 || fraction > 1.0)
{
    throw new ArgumentException("Fraction must be between 0.0 and 1.0, inclusive.");
}

float delta = value2.GetValueOrDefault() - value1.GetValueOrDefault();
float interpolatedValue = value1.GetValueOrDefault() + (delta * fraction.GetValueOrDefault());
Elog.Info($"DEBUG: FUNCTION calculate_linear_interpolation-2 - Function calculate_linear_interpolation is returning 'interpolatedValue' = {interpolatedValue}.");
return interpolatedValue;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateLinearInterpolationMidRange', plcsharp_calculate_linear_interpolation(10.75::FLOAT4, 20.5::FLOAT4, 0.5::FLOAT4) = 15.625::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateLinearInterpolationStartValue', plcsharp_calculate_linear_interpolation(-5.0::FLOAT4, 5.0::FLOAT4, 0.1::FLOAT4) = -4.0::FLOAT4;
```

#### plcsharp_calculate_log_base_n✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_log_base_n(number FLOAT4, custom_base FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_log_base_n
// description: Calculates the logarithm of a float4 number with a float4 custom base and returns the result as float4. Rejects a base that is less than or equal to 0, or equal to 1, and a number that is less than or equal to 0.
// type: float4
// input: Value to find the logarithm of. Must be greater than 0.
// input: Base of the logarithm. Must be greater than 0 and not equal to 1.
// output: Logarithm of the number to the base provided. If the base or number is invalid, the output is 'undefined'.

Elog.Info($"DEBUG: FUNCTION calculate_log_base_n_plcsharp-1 - Running calculate_log_base_n function with inputs 'number' = {number}, 'custom_base' = {custom_base}.");
if (custom_base <= 0 || custom_base == 1 || number <= 0)
{
    Elog.Info($"DEBUG: FUNCTION calculate_log_base_n_plcsharp-2 - Invalid input values, returning 'undefined'.");
    return float.NaN; // 'undefined' represented as NaN (Not a Number) in .NET
}
float result = (float)(Math.Log((double)number) / Math.Log((double)custom_base));
Elog.Info($"DEBUG: FUNCTION calculate_log_base_n_plcsharp-3 - Function calculate_log_base_n is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateLogBaseNValid', plcsharp_calculate_log_base_n(32.0::FLOAT4, 2.0::FLOAT4) = 5.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateLogBaseNInvalid', plcsharp_calculate_log_base_n(100.0::FLOAT4, 1.0::FLOAT4) IS NOT DISTINCT FROM float4 'NaN';
```

#### plcsharp_calculate_logarithm✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_logarithm(number FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_logarithm
// description: Calculates the natural logarithm (base e) of a given float4 number and returns the result as float4. If the input is less than or equal to zero, the function will return 'undefined' since the logarithm for non-positive numbers is not defined in real numbers.
// type: float4
// input: The float4 number for which to find the natural logarithm
// output: The natural logarithm of the given float4 number as float4, or 'undefined' if the input is not a positive float4

Elog.Info($"DEBUG: FUNCTION calculate_logarithm_plcsharp-1 - Running calculate_logarithm function with input 'number' = {number}.");
if (number <= 0)
{
    Elog.Info($"DEBUG: FUNCTION calculate_logarithm_plcsharp-2 - Input 'number' = {number} is not positive, returning 'undefined'.");
    return float.NaN; // In C#, NaN is used to represent undefined for floating-point numbers
}
float result = (float)Math.Log((double)number);
Elog.Info($"DEBUG: FUNCTION calculate_logarithm_plcsharp-3 - Natural logarithm of 'number' = {number} is 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateLogarithmPositive', ROUND(plcsharp_calculate_logarithm(2.7183::FLOAT4)::NUMERIC, 4) = 1.0000::NUMERIC;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateLogarithmNonPositive', plcsharp_calculate_logarithm(-1.0::FLOAT4) IS NOT DISTINCT FROM 'NaN'::FLOAT4;
```

#### plcsharp_calculate_logarithm_base_ten✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_logarithm_base_ten(number FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_logarithm_base_ten
// description: Calculates the logarithm base 10 of a float4 number and returns the result as float4. It assumes positive non-zero input.
// type: float4
// input: The float4 number to calculate the logarithm base 10 of
// output: The float4 result of the logarithm base 10 calculation

Elog.Info($"DEBUG: FUNCTION calculate_logarithm_base_ten-1 - Running calculate_logarithm_base_ten function with input 'number' = {number}.");
float nonNullableNumber = number ?? 0.0f; // Assuming that a null value will default to 0.0f
if (nonNullableNumber <= 0.0f) {
    Elog.Info($"DEBUG: FUNCTION calculate_logarithm_base_ten-2 - 'number' parameter must be greater than zero.");
    throw new ArgumentOutOfRangeException("number", "Input must be greater than zero.");
}
float result = (float)Math.Log10(nonNullableNumber);
Elog.Info($"DEBUG: FUNCTION calculate_logarithm_base_ten-3 - Function calculate_logarithm_base_ten is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateLogarithmBaseTen1', plcsharp_calculate_logarithm_base_ten(100.0::FLOAT4) = 2.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateLogarithmBaseTen2', plcsharp_calculate_logarithm_base_ten(1000.0::FLOAT4) = 3.0::FLOAT4;
```

#### plcsharp_calculate_median_of_two_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_median_of_two_float4(input1 float, input2 float) RETURNS float AS $$
// name: calculate_median_of_two_float4
// description: Calculates the median of two float4 numbers and returns the result as float4
// type: float4
// input: First float4 input value
// input: Second float4 input value
// output: Median of input1 and input2 as float4

Elog.Info($"DEBUG: FUNCTION plcsharp_calculate_median_of_two_float4-1 - Running calculate_median_of_two_float4 function with inputs 'input1' = {input1}, 'input2' = {input2}.");
float median = 0f;
if (input1 == input2)
{
    median = (float)input1;
    Elog.Info($"DEBUG: FUNCTION plcsharp_calculate_median_of_two_float4-2 - Both inputs are equal. Setting 'median' = {median}.");
}
else
{
    median = ((float)input1 + (float)input2) / 2f;
    Elog.Info($"DEBUG: FUNCTION plcsharp_calculate_median_of_two_float4-3 - Inputs are not equal. Setting 'median' to their average = {median}.");
}
Elog.Info($"DEBUG: FUNCTION plcsharp_calculate_median_of_two_float4-4 - Function plcsharp_calculate_median_of_two_float4 is returning 'median' = {median}.");
return median;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_median_of_two_float4_identical', plcsharp_calculate_median_of_two_float4(10.0::FLOAT4, 10.0::FLOAT4) = 10.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_median_of_two_float4_different', plcsharp_calculate_median_of_two_float4(10.0::FLOAT4, 20.0::FLOAT4) = 15.0::FLOAT4;
```

#### plcsharp_calculate_percentage_difference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_percentage_difference(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_percentage_difference
// description: Calculates the percentage difference between two float4 values
// type: float4
// input: First float4 value
// input: Second float4 value
// output: Percentage difference as float4

Elog.Info($"DEBUG: FUNCTION calculate_percentage_difference_plcsharp-1 - Running calculate_percentage_difference function with inputs 'value1' = {value1}, 'value2' = {value2}.");
float nonNullableValue1 = value1 ?? 0;
float nonNullableValue2 = value2 ?? 0;
float absolute_difference = Math.Abs(nonNullableValue1 - nonNullableValue2);
float average_value = (nonNullableValue1 + nonNullableValue2) / 2;
float percentage_difference = (absolute_difference / average_value) * 100;
Elog.Info($"DEBUG: FUNCTION calculate_percentage_difference_plcsharp-2 - Function calculate_percentage_difference is returning 'percentage_difference' = {percentage_difference}.");
return percentage_difference;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_percentage_difference1', plcsharp_calculate_percentage_difference(150.0::FLOAT4, 100.0::FLOAT4) = 40.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_percentage_difference2', plcsharp_calculate_percentage_difference(75.0::FLOAT4, 125.0::FLOAT4) = 50.0::FLOAT4;
```

#### plcsharp_calculate_product_of_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_product_of_float4(number1 FLOAT4, number2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_product_of_float4
// description: Calculates the product of two float4 numbers and returns the result as a float4
// type: float4
// input: The first float4 number to be multiplied
// input: The second float4 number to be multiplied
// output: The product of the two float4 inputs as a float4

Elog.Info($"DEBUG: FUNCTION calculate_product_of_float4_plcsharp-1 - Running calculate_product_of_float4 function with inputs 'number1' = {number1}, 'number2' = {number2}.");
float num1 = (float)number1;
float num2 = (float)number2;
float product = num1 * num2;
Elog.Info($"DEBUG: FUNCTION calculate_product_of_float4_plcsharp-2 - Function calculate_product_of_float4 is returning 'product' = {product}.");
return product;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_product_of_float4_positive', ROUND(plcsharp_calculate_product_of_float4(3.14::FLOAT4, 1.59::FLOAT4)::NUMERIC, 4) = 4.9926;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_product_of_float4_neg_by_pos', plcsharp_calculate_product_of_float4(-5.0::FLOAT4, 2.5::FLOAT4) = -12.5::FLOAT4;
```

#### plcsharp_calculate_quadratic_roots✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_quadratic_roots(a float4, b float4, c float4) RETURNS float4[] AS $$
// name: calculate_quadratic_roots
// description: Calculates the roots of a quadratic equation ax^2 + bx + c = 0 using the quadratic formula and returns them as an array of float4
// type: float4
// input: float4 coefficient for x^2
// input: float4 coefficient for x
// input: float4 constant term
// output: array of float4 containing the two roots

Elog.Info($"DEBUG: FUNCTION calculate_quadratic_roots-1 - Running calculate_quadratic_roots function with inputs 'a' = {a}, 'b' = {b}, 'c' = {c}.");

float discriminant = (float)(b.Value * b.Value - 4 * a.Value * c.Value);
if (discriminant < 0)
{
    Elog.Info($"DEBUG: FUNCTION calculate_quadratic_roots-2 - Discriminant is negative. No real roots.");
    return new float[]{};
}

float discriminantSqrt = (float)Math.Sqrt(discriminant);
float root1 = (-b.Value + discriminantSqrt) / (2 * a.Value);
float root2 = (-b.Value - discriminantSqrt) / (2 * a.Value);

float[] roots = discriminant == 0 ? new float[]{root1} : new float[]{root1, root2};

Elog.Info($"DEBUG: FUNCTION calculate_quadratic_roots-3 - Roots calculated. Returning array with {roots.Length} root(s).");
return roots;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateQuadraticRootsOneRealRoot', ARRAY[2.0::FLOAT4] = plcsharp_calculate_quadratic_roots(1.0::FLOAT4, -4.0::FLOAT4, 4.0::FLOAT4);
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateQuadraticRootsDistinctRealRoots', ARRAY[3.0, 2.0] = plcsharp_calculate_quadratic_roots(1.0::FLOAT4, -5.0::FLOAT4, 6.0::FLOAT4);
```

#### plcsharp_calculate_scaled_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_scaled_value(value FLOAT4, factor FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_scaled_value
// description: This function takes an input float4 value and scales it by a given float4 factor.
// type: float4
// input: The original float4 value to be scaled
// input: The float4 factor by which to scale the value
// output: The scaled float4 value

float scaledValue = (float)(value * factor);
return scaledValue;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_scaled_value_up', plcsharp_calculate_scaled_value(1.5::FLOAT4, 2.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_scaled_value_down', plcsharp_calculate_scaled_value(3.0::FLOAT4, 0.5::FLOAT4) = 1.5::FLOAT4;
```

#### plcsharp_calculate_sin✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_sin(angle float) RETURNS float AS $$
// name: calculate_sin
// description: Calculates the sine of a float4 angle value (in radians) and returns the result as float4
// type: float4
// input: float4 angle in radians for which the sine will be calculated
// output: float4 representing the sine of the input angle

Elog.Info($"DEBUG: FUNCTION calculate_sin_plcsharp-1 - Running calculate_sin function with input 'angle' = {angle}.");
float radians = (float)angle;
float sineValue = (float)Math.Sin(radians);
Elog.Info($"DEBUG: FUNCTION calculate_sin_plcsharp-2 - Function calculate_sin is returning 'sineValue' = {sineValue}.");
return sineValue;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_sin1', plcsharp_calculate_sin(0.0::float) = 0.0::float;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_sin2', plcsharp_calculate_sin(1.5708::float) = 1.0::float;
```

#### plcsharp_calculate_slope✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_slope(point1 FLOAT4[], point2 FLOAT4[]) RETURNS FLOAT4 AS $$
// name: calculate_slope
// description: Calculates the slope of a line passing through two points in the Cartesian coordinate system
// type: float4
// input: Coordinates (x1, y1) of the first point, type float4 array
// input: Coordinates (x2, y2) of the second point, type float4 array
// output: The slope of the line as float4

Elog.Info($"DEBUG: FUNCTION calculate_slope_plcsharp-1 - Running calculate_slope_plcsharp function with inputs 'point1' = {point1}, 'point2' = {point2}.");

if (point1 == null || point2 == null || point1.Length != 2 || point2.Length != 2)
{
    throw new ArgumentException("Input arrays must contain exactly two elements and not be null.");
}

float deltaY = (float)point2.GetValue(1) - (float)point1.GetValue(1);
float deltaX = (float)point2.GetValue(0) - (float)point1.GetValue(0);

Elog.Info($"DEBUG: FUNCTION calculate_slope_plcsharp-2 - Calculated deltaX = {deltaX} and deltaY = {deltaY}.");

if (deltaX == 0)
{
    Elog.Info($"DEBUG: FUNCTION calculate_slope_plcsharp-3 - DeltaX is zero, slope is undefined.");
    return float.NaN; // NaN (Not a Number) represents 'undefined' in this context
}
float slope = deltaY / deltaX;
Elog.Info($"DEBUG: FUNCTION calculate_slope_plcsharp-4 - Function calculate_slope_plcsharp is returning 'slope' = {slope}.");
return slope;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateSlope1', plcsharp_calculate_slope(ARRAY[1.0, 2.0]::FLOAT4[], ARRAY[3.0, 3.0]::FLOAT4[]) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateSlope2', plcsharp_calculate_slope(ARRAY[4.0, 1.0]::FLOAT4[], ARRAY[4.0, 3.0]::FLOAT4[]) IS NOT DISTINCT FROM 'NaN'::FLOAT4;
```

#### plcsharp_calculate_thermal_expansion✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_thermal_expansion(original_length FLOAT4, temperature_change FLOAT4, coefficient_of_expansion FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_thermal_expansion
// description: Calculates the linear thermal expansion of a material given its original length, temperature change, and the material's coefficient of linear expansion
// type: float4
// input: the original length of the material before thermal expansion (float4)
// input: the change in temperature that the material undergoes (float4)
// input: the coefficient of linear expansion of the material (float4)
// output: the new length of the material after thermal expansion (float4)

Elog.Info($"DEBUG: FUNCTION calculate_thermal_expansion-1 - Running calculate_thermal_expansion function with inputs 'original_length' = {original_length}, 'temperature_change' = {temperature_change}, 'coefficient_of_expansion' = {coefficient_of_expansion}.");
// Calculate the length change due to thermal expansion
float length_change = (float)(original_length * temperature_change * coefficient_of_expansion);
// Calculate the new length by adding the original length and the length change
float new_length = (float)(original_length + length_change);
Elog.Info($"DEBUG: FUNCTION calculate_thermal_expansion-2 - Function calculate_thermal_expansion is returning 'new_length' = {new_length}.");
return new_length;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateThermalExpansionSmallChange', plcsharp_calculate_thermal_expansion(10.0::FLOAT4, 0.0005::FLOAT4, 0.000012::FLOAT4) = 10.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculateThermalExpansionLargeChange', plcsharp_calculate_thermal_expansion(5.0::FLOAT4, 0.05::FLOAT4, 0.000015::FLOAT4) = 5.000004::FLOAT4;
```

#### plcsharp_calculate_weight_force✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_calculate_weight_force(mass FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_weight_force
// description: Calculates the force due to weight of an object using the formula F = m * g, where m is mass in kilograms, and g is acceleration due to gravity at 9.81 m/s^2 (represented as float4)
// type: float4
// input: mass of the object as float4
// output: the weight force as float4

// Define constant acceleration due to gravity
const float acceleration_due_to_gravity = 9.81f;
Elog.Info($"DEBUG: FUNCTION calculate_weight_force-1 - Running calculate_weight_force function with input 'mass' = {mass}.");

// Check if mass is not null, and multiply mass by acceleration_due_to_gravity if it's not
float weight_force = mass.HasValue ? mass.Value * acceleration_due_to_gravity : 0f;
Elog.Info($"DEBUG: FUNCTION calculate_weight_force-2 - Function calculate_weight_force is returning 'weight_force' = {weight_force}.");

return weight_force;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_weight_force1', plcsharp_calculate_weight_force(2.0::FLOAT4) = 19.62::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_calculate_weight_force2', plcsharp_calculate_weight_force(5.5::FLOAT4) = 53.955::FLOAT4;
```

#### plcsharp_check_float4_equality✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_check_float4_equality(input1 float4, input2 float4) RETURNS bool AS $$
// name: check_float4_equality
// description: Checks whether two float4 values are equal
// type: float4
// input: First float4 value to be compared
// input: Second float4 value to be compared
// output: Boolean result determining if the two float4 values are equal

Elog.Info($"DEBUG: FUNCTION check_float4_equality_plcsharp-1 - Running check_float4_equality function with inputs 'input1' = {input1}, 'input2' = {input2}.");
bool result = Math.Abs((float)(input1 - input2)) < 0.000001f; // Using a small epsilon value for float comparison
Elog.Info($"DEBUG: FUNCTION check_float4_equality_plcsharp-2 - Function check_float4_equality is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'check_float4_equality1', plcsharp_check_float4_equality(4.0000::FLOAT4, 4.0000::FLOAT4) = true;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'check_float4_equality2', plcsharp_check_float4_equality(4.0000::FLOAT4, -3.9999::FLOAT4) = false;
```

#### plcsharp_check_float4_is_positive✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_check_float4_is_positive(number float) RETURNS float AS $$
// name: check_float4_is_positive
// description: Determines if a float4 input is positive
// type: float4
// input: The float4 number to check
// output: A float4 representing a boolean true or false, 1.0 for true and 0.0 for false

Elog.Info($"DEBUG: FUNCTION plcsharp_check_float4_is_positive - Running check_float4_is_positive function with input 'number' = {number}.");
float result = number > 0.0f ? 1.0f : 0.0f;
Elog.Info($"DEBUG: FUNCTION plcsharp_check_float4_is_positive - Function check_float4_is_positive is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_check_float4_is_positive_positive', plcsharp_check_float4_is_positive(0.1::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_check_float4_is_positive_non_positive', plcsharp_check_float4_is_positive(-0.1::FLOAT4) = 0.0::FLOAT4;
```

#### plcsharp_check_float4_within_bounds✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_check_float4_within_bounds(value FLOAT4, lower_bound FLOAT4, upper_bound FLOAT4) RETURNS FLOAT4 AS $$
// name: check_float4_within_bounds
// description: Determines whether a float4 value is between two boundary float4 values (exclusive)
// type: float4
// input: the float4 value to check
// input: the lower float4 boundary
// input: the upper float4 boundary
// output: boolean represented as float4 (1.0 for true, 0.0 for false)

Elog.Info($"DEBUG: FUNCTION check_float4_within_bounds-1 - Running check_float4_within_bounds function with inputs 'value' = {value}, 'lower_bound' = {lower_bound}, 'upper_bound' = {upper_bound}.");
float result = (value > lower_bound && value < upper_bound) ? 1.0f : 0.0f;
Elog.Info($"DEBUG: FUNCTION check_float4_within_bounds-2 - Function check_float4_within_bounds is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'check_float4_within_bounds_WithinBounds', plcsharp_check_float4_within_bounds(5.75::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'check_float4_within_bounds_OutsideBounds', plcsharp_check_float4_within_bounds(-3.14::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 0.0::FLOAT4;
```

#### plcsharp_check_float4_within_tolerance✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_check_float4_within_tolerance(float4_num1 FLOAT4, float4_num2 FLOAT4, tolerance FLOAT4) RETURNS BOOLEAN AS $$
// name: check_float4_within_tolerance
// description: Checks if two float4 numbers are within a specified tolerance
// type: float4
// input: First float4 number to compare
// input: Second float4 number to compare
// input: The float4 tolerance within which the two numbers are considered equal
// output: Boolean float4 indicating if the numbers are within the tolerance

Elog.Info($"DEBUG: FUNCTION check_float4_within_tolerance_plcsharp-1 - Running check_float4_within_tolerance function with inputs 'float4_num1' = {float4_num1}, 'float4_num2' = {float4_num2}, 'tolerance' = {tolerance}.");
bool within_tolerance = false;
float absolute_difference = Math.Abs((float)float4_num1 - (float)float4_num2);
if (absolute_difference <= tolerance)
{
    within_tolerance = true;
}
Elog.Info($"DEBUG: FUNCTION check_float4_within_tolerance_plcsharp-2 - Function check_float4_within_tolerance is returning 'within_tolerance' = {within_tolerance}.");
return within_tolerance;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_checkFloat4WithinTolerance1', plcsharp_check_float4_within_tolerance(100.0::FLOAT4, 100.05::FLOAT4, 0.1::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_checkFloat4WithinTolerance2', plcsharp_check_float4_within_tolerance(200.0::FLOAT4, 200.2::FLOAT4, 0.1::FLOAT4) = FALSE;
```

#### plcsharp_clamp_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_clamp_value(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS FLOAT4 AS $$
// name: clamp_value
// description: Clamps a given float4 value between a minimum and maximum float4 range
// type: float4
// input: The float4 value to be clamped
// input: The minimum float4 value in the range
// input: The maximum float4 value in the range
// output: The clamped float4 value

Elog.Info($"DEBUG: FUNCTION clamp_value_plcsharp-1 - Running clamp_value_plcsharp function with inputs 'value' = {value}, 'min_value' = {min_value}, 'max_value' = {max_value}.");
float result;
if (value < min_value)
{
    result = (float)min_value;
    Elog.Info($"DEBUG: FUNCTION clamp_value_plcsharp-2 - 'value' is less than 'min_value'. Returning 'min_value' = {result}.");
}
else if (value > max_value)
{
    result = (float)max_value;
    Elog.Info($"DEBUG: FUNCTION clamp_value_plcsharp-3 - 'value' is greater than 'max_value'. Returning 'max_value' = {result}.");
}
else
{
    result = (float)value;
    Elog.Info($"DEBUG: FUNCTION clamp_value_plcsharp-4 - 'value' is within range. Returning 'value' = {result}.");
}
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'clampValueLessThanMinimum', plcsharp_clamp_value(2.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'clampValueWithinRange', plcsharp_clamp_value(4.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 4.5::FLOAT4;
```

#### plcsharp_combine_second_third_power✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_combine_second_third_power(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
// name: combine_second_third_power
// description: Combines the second power of the first float4 input with the third power of the second float4 input by adding them together.
// type: float4
// input: The first float4 input for which the second power is calculated
// input: The second float4 input for which the third power is calculated
// output: The result of adding the second power of input1 and the third power of input2, returned as float4

Elog.Info($"DEBUG: FUNCTION combine_second_third_power-1 - Running combine_second_third_power function with inputs 'input1' = {input1}, 'input2' = {input2}.");

// Calculate the second power (square) of input1
float input1SecondPower = (float)input1 * (float)input1;
Elog.Info($"DEBUG: FUNCTION combine_second_third_power-2 - Calculated second power of 'input1' = {input1SecondPower}.");

// Calculate the third power (cube) of input2
float input2ThirdPower = (float)input2 * (float)input2 * (float)input2;
Elog.Info($"DEBUG: FUNCTION combine_second_third_power-3 - Calculated third power of 'input2' = {input2ThirdPower}.");

// Add the result of the second power of input1 to the result of the third power of input2
float result = input1SecondPower + input2ThirdPower;
Elog.Info($"DEBUG: FUNCTION combine_second_third_power-4 - Final result after adding both powers = {result}.");

// Return the final result as float4
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'combine_second_third_power_positive', plcsharp_combine_second_third_power(4.0::FLOAT4, 2.0::FLOAT4) = 24.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'combine_second_third_power_mixed', plcsharp_combine_second_third_power(-1.5::FLOAT4, 3.0::FLOAT4) = 29.25::FLOAT4;
```

#### plcsharp_compare_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_compare_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
// name: compare_float4_values
// description: Compares two float4 values and determines if the first is greater than the second.
// type: float4
// input: First float4 value for comparison
// input: Second float4 value for comparison
// output: Boolean represented as float4 (1.0 for true, 0.0 for false)

Elog.Info($"DEBUG: FUNCTION compare_float4_values_plcsharp-1 - Running compare_float4_values function with inputs 'value1' = {value1}, 'value2' = {value2}.");
float result = 0.0f; // Set 'result' to 0.0 as the initial float4 value
if (value1 > value2)
{
    result = 1.0f; // If 'value1' is greater than 'value2' then set 'result' to 1.0
}
Elog.Info($"DEBUG: FUNCTION compare_float4_values_plcsharp-2 - Function compare_float4_values is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'compareFloat4ValuesGreaterThan', plcsharp_compare_float4_values(3.5::FLOAT4, 2.7::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'compareFloat4ValuesNotGreaterThan', plcsharp_compare_float4_values(1.4::FLOAT4, 1.8::FLOAT4) = 0.0::FLOAT4;
```

#### plcsharp_compute_circle_area✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_compute_circle_area(radius FLOAT4) RETURNS FLOAT4 AS $$
// name: compute_circle_area
// description: This function calculates the area of a circle given the radius as a float4 type.
// type: float4
// input: The radius of the circle as a float4
// output: The area of the circle as a float4

Elog.Info($"DEBUG: FUNCTION compute_circle_area_plcsharp-1 - Running compute_circle_area with input 'radius' = {radius}.");
float pi = 3.14159f;
float area = pi * (float)(radius * radius);
Elog.Info($"DEBUG: FUNCTION compute_circle_area_plcsharp-2 - Function compute_circle_area is returning 'area' = {area}.");
return area;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_compute_circle_area_small_radius', plcsharp_compute_circle_area(2.5::FLOAT4) = 19.634937::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_compute_circle_area_large_radius', plcsharp_compute_circle_area(100.0::FLOAT4) = 31415.9::FLOAT4;
```

#### plcsharp_compute_square_root✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_compute_square_root(input_number FLOAT4) RETURNS FLOAT4 AS $$
// name: compute_square_root
// description: Computes the square root of a given float4 input and returns the result as float4
// type: float4
// input: The float4 number to compute the square root of
// output: The float4 square root of the input number

Elog.Info($"DEBUG: FUNCTION compute_square_root_plcsharp-1 - Running compute_square_root function with input 'input_number' = {input_number}.");
if (input_number < 0)
{
    throw new ArgumentOutOfRangeException(nameof(input_number), "input_number cannot be negative.");
}
if (input_number == 0)
{
    Elog.Info($"DEBUG: FUNCTION compute_square_root_plcsharp-2 - Input is zero, the square root of zero is zero.");
    return 0.0f;
}
float result = MathF.Sqrt((float)input_number);
Elog.Info($"DEBUG: FUNCTION compute_square_root_plcsharp-3 - Computed square root 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_compute_square_root1', plcsharp_compute_square_root(16.0::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_compute_square_root2', plcsharp_compute_square_root(0.0::FLOAT4) = 0.0::FLOAT4;
```

#### plcsharp_compute_tangent✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_compute_tangent(angle_in_radians float4) RETURNS float4 AS $$
// name: compute_tangent
// description: Computes the tangent of a float4 angle value in radians and returns the result as float4
// type: float4
// input: The angle in radians for which to compute the tangent, as a float4
// output: The tangent of the angle as float4

if (!angle_in_radians.HasValue)
{
    throw new InvalidOperationException("Input angle_in_radians cannot be null.");
}
if (angle_in_radians.Value == MathF.PI / 2 || angle_in_radians.Value == 3 * MathF.PI / 2)
{
    throw new InvalidOperationException("Tangent is not defined for angles of PI/2 or 3*PI/2 radians.");
}
Elog.Info($"DEBUG: FUNCTION compute_tangent-1 - Running compute_tangent function with input 'angle_in_radians' = {angle_in_radians.Value}.");
float tangent_result = MathF.Tan(angle_in_radians.Value);
Elog.Info($"DEBUG: FUNCTION compute_tangent-2 - Function compute_tangent is returning 'tangent_result' = {tangent_result}.");
return tangent_result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_computeTangentOfZero', plcsharp_compute_tangent(0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_computeTangentOfPIOver4', plcsharp_compute_tangent(0.785398163::FLOAT4) = 1.0::FLOAT4;
```

#### plcsharp_convert_float4_to_negative✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_convert_float4_to_negative(number FLOAT4) RETURNS FLOAT4 AS $$
// name: convert_float4_to_negative
// description: This function converts a float4 number to its negative equivalent.
// type: float4
// input: float4 number to be negated
// output: The negative equivalent of the input as float4

Elog.Info($"DEBUG: FUNCTION convert_float4_to_negative-1 - Running convert_float4_to_negative function with input 'number' = {number}.");
float nonNullableNumber = number ?? 0.0f;
if (number >= 0)
{
    nonNullableNumber *= -1;
    Elog.Info($"DEBUG: FUNCTION convert_float4_to_negative-2 - 'number' is positive, negated to {nonNullableNumber}.");
}
else
{
    Elog.Info($"DEBUG: FUNCTION convert_float4_to_negative-3 - 'number' is already negative, value is {nonNullableNumber}.");
}
return nonNullableNumber;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_convertFloat4ToNegativePositive', plcsharp_convert_float4_to_negative(3.5::FLOAT4) = -3.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_convertFloat4ToNegativeNegative', plcsharp_convert_float4_to_negative(-2.0::FLOAT4) = -2.0::FLOAT4;
```

#### plcsharp_convert_to_radians✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_convert_to_radians(degrees FLOAT4) RETURNS FLOAT4 AS $$
// name: convert_to_radians
// description: Converts an angle in degrees to radians
// type: float4
// input: The angle in degrees to be converted to radians as float4
// output: The angle in radians as float4

const float PI = 3.1415927f;
Elog.Info($"DEBUG: FUNCTION plcsharp_convert_to_radians-1 - Running convert_to_radians_plcsharp function with input 'degrees' = {degrees}.");
float radians = degrees.HasValue ? degrees.Value * PI / 180.0f : 0.0f; // Explicit cast
Elog.Info($"DEBUG: FUNCTION plcsharp_convert_to_radians-2 - Function convert_to_radians_plcsharp is returning 'radians' = {radians}.");
return radians;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_convertToRadians1', plcsharp_convert_to_radians(0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_convertToRadians2', plcsharp_convert_to_radians(180.0::FLOAT4) = 3.1415927::FLOAT4;
```

#### plcsharp_find_nearest_multiple_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_find_nearest_multiple_float4(number FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
// name: find_nearest_multiple_float4
// description: Finds the nearest multiple of a divisor close to the given float4 number
// type: float4
// input: The original float4 value for which the nearest multiple is to be found
// input: The divisor float4 value whose multiple is to be found nearest to the number
// output: The nearest multiple of the divisor float4 value to the original number as float4

if (number.HasValue && divisor.HasValue && divisor.Value != 0)
{
    Elog.Info($"DEBUG: FUNCTION find_nearest_multiple_float4-1 - Running find_nearest_multiple_float4 function with inputs 'number' = {number}, 'divisor' = {divisor}.");
    float roundedQuotient = (float)Math.Round((double)number.Value / (double)divisor.Value);
    float nearestMultiple = roundedQuotient * divisor.Value;
    Elog.Info($"DEBUG: FUNCTION find_nearest_multiple_float4-2 - Function find_nearest_multiple_float4 is returning 'nearestMultiple' = {nearestMultiple}.");
    return nearestMultiple;
}
else
{
    throw new ArgumentNullException("number or divisor is null or divisor is zero");
}
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_findNearestMultipleFloat41', plcsharp_find_nearest_multiple_float4(14.2::FLOAT4, 5.0::FLOAT4) = 15.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_findNearestMultipleFloat42', plcsharp_find_nearest_multiple_float4(7.7::FLOAT4, 3.5::FLOAT4) = 7.0::FLOAT4;
```

#### plcsharp_float4_absolute_value_test✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_float4_absolute_value_test(number FLOAT4) RETURNS FLOAT4 AS $$
// name: float4_absolute_value_test
// description: Function to compute the absolute value of a float4 number
// type: float4
// input: A float4 value representing the number to find the absolute value for
// output: float4 absolute value of the input number

Elog.Info($"DEBUG: FUNCTION float4_absolute_value_test-1 - Running float4_absolute_value_test function with input 'number' = {number}.");
float nonNullableNumber = number ?? 0.0f;
float abs_value;
if (nonNullableNumber < 0)
{
    abs_value = nonNullableNumber * -1;
    Elog.Info($"DEBUG: FUNCTION float4_absolute_value_test-2 - 'number' is negative. 'abs_value' = {abs_value}.");
}
else
{
    abs_value = nonNullableNumber;
    Elog.Info($"DEBUG: FUNCTION float4_absolute_value_test-3 - 'number' is non-negative. Using 'number' as 'abs_value'.");
}
Elog.Info($"DEBUG: FUNCTION float4_absolute_value_test-4 - Function float4_absolute_value_test is returning 'abs_value' = {abs_value}.");
return abs_value;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'float4_absolute_value_test_negative', plcsharp_float4_absolute_value_test('-123.45'::FLOAT4) = '123.45'::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'float4_absolute_value_test_positive', plcsharp_float4_absolute_value_test('678.9'::FLOAT4) = '678.9'::FLOAT4;
```

#### plcsharp_float4_min_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_float4_min_value(number1 float4, number2 float4) RETURNS float4 AS $$
// name: float4_min_value
// description: Finds the minimum value between two float4 numbers
// type: float4
// input: First float4 number for comparison
// input: Second float4 number for comparison
// output: Returns the minimum value as float4

Elog.Info($"DEBUG: FUNCTION float4_min_value-1 - Running float4_min_value function with inputs 'number1' = {number1}, 'number2' = {number2}.");
float min_value = (float)number1;
if ((float)number2 < min_value)
{
    Elog.Info($"DEBUG: FUNCTION float4_min_value-2 - 'number2' = {number2} is less than 'min_value' = {min_value}, updating 'min_value'.");
    min_value = (float)number2;
}
Elog.Info($"DEBUG: FUNCTION float4_min_value-3 - Function float4_min_value is returning 'min_value' = {min_value}.");
return min_value;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_float4MinValuePositive', plcsharp_float4_min_value(3.5::FLOAT4, 7.25::FLOAT4) = 3.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_float4MinValueNegByPos', plcsharp_float4_min_value(-2.0::FLOAT4, 4.75::FLOAT4) = -2.0::FLOAT4;
```

#### plcsharp_is_float4_in_decreasing_order✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_is_float4_in_decreasing_order(number1 FLOAT4, number2 FLOAT4) RETURNS BOOLEAN AS $$
// name: is_float4_in_decreasing_order
// description: Determines if the provided float4 numbers are in strictly decreasing order
// type: float4
// input: First number of type float4
// input: Second number of type float4
// output: Result of type boolean, true if number1 > number2, false otherwise

Elog.Info($"DEBUG: FUNCTION is_float4_in_decreasing_order_plcsharp-1 - Running is_float4_in_decreasing_order function with inputs 'number1' = {number1}, 'number2' = {number2}.");
bool result = number1 > number2;
Elog.Info($"DEBUG: FUNCTION is_float4_in_decreasing_order_plcsharp-2 - Function is_float4_in_decreasing_order is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'is_float4_in_decreasing_order1', plcsharp_is_float4_in_decreasing_order(6.5::FLOAT4, 3.24::FLOAT4) = true;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'is_float4_in_decreasing_order2', plcsharp_is_float4_in_decreasing_order(5.5::FLOAT4, 5.5::FLOAT4) = false;
```

#### plcsharp_is_float4_in_range✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_is_float4_in_range(value float4, min_value float4, max_value float4) RETURNS bool AS $$
// name: is_float4_in_range
// description: Determines if a float4 value falls within a specified inclusive range, defined by a minimum and maximum float4 value.
// type: float4
// input: The float4 value to check
// input: The inclusive minimum value of the range as float4
// input: The inclusive maximum value of the range as float4
// output: Returns true if the value is within the range, otherwise false

Elog.Info($"DEBUG: FUNCTION is_float4_in_range-1 - Running is_float4_in_range function with inputs 'value' = {value}, 'min_value' = {min_value}, 'max_value' = {max_value}.");

bool isInRange = value >= min_value && value <= max_value;

Elog.Info($"DEBUG: FUNCTION is_float4_in_range-2 - Function is_float4_in_range is returning 'isInRange' = {isInRange}.");
return isInRange;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'is_float4_in_range_within', plcsharp_is_float4_in_range(3.5::FLOAT4, 1.0::FLOAT4, 5.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'is_float4_in_range_outside', plcsharp_is_float4_in_range(6.5::FLOAT4, 1.0::FLOAT4, 5.0::FLOAT4) = FALSE;
```

#### plcsharp_is_float4_zero✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_is_float4_zero(number float) RETURNS bool AS $$
// name: is_float4_zero
// description: Checks if the provided float4 number is zero
// type: float4
// input: the input float4 number to check
// output: returns true if number is 0.0, false otherwise

Elog.Info($"DEBUG: FUNCTION is_float4_zero-1 - Running is_float4_zero function with input 'number' = {number}.");
const float threshold = 0.0001f;
bool isZero = Math.Abs((double)number) <= threshold;
Elog.Info($"DEBUG: FUNCTION is_float4_zero-2 - Function is_float4_zero is returning 'isZero' = {isZero}.");
return isZero;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'is_float4_zero1', plcsharp_is_float4_zero(0.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'is_float4_zero2', plcsharp_is_float4_zero(0.00001::FLOAT4) = TRUE;
```

#### plcsharp_is_negative✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_is_negative(number float) RETURNS bool AS $$
// name: is_negative
// description: Determines if a float4 value is negative
// type: float4
// input: the float4 number to check
// output: boolean indicating if the number is negative

Elog.Info($"DEBUG: FUNCTION is_negative_plcsharp-1 - Running is_negative function with input 'number' = {number}.");
bool isNeg = number < 0;
Elog.Info($"DEBUG: FUNCTION is_negative_plcsharp-2 - Function is_negative is returning 'isNeg' = {isNeg}.");
return isNeg;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'is_negative_plcsharp_negative', plcsharp_is_negative(-3.14::FLOAT4) = true;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'is_negative_plcsharp_not_negative', plcsharp_is_negative(6.28::FLOAT4) = false;
```

#### plcsharp_normalize_float4_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_normalize_float4_value(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS FLOAT4 AS $$
// name: normalize_float4_value
// description: Normalize a float4 number to the range of 0 to 1 based on provided minimum and maximum values
// type: float4
// input: the float4 number to normalize
// input: the minimum float4 value of the range
// input: the maximum float4 value of the range
// output: the normalized float4 number

Elog.Info($"DEBUG: FUNCTION normalize_float4_value_plcsharp-1 - Running normalize_float4_value function with inputs 'value' = {value}, 'min_value' = {min_value}, 'max_value' = {max_value}.");

if (min_value >= max_value)
{
    throw new ArgumentException("min_value must be less than max_value.");
}

float distanceFromMin = value.GetValueOrDefault() - min_value.GetValueOrDefault();
float rangeSize = max_value.GetValueOrDefault() - min_value.GetValueOrDefault();
float normalizedValue = distanceFromMin / rangeSize;

Elog.Info($"DEBUG: FUNCTION normalize_float4_value_plcsharp-2 - Function normalize_float4_value is returning 'normalizedValue' = {normalizedValue}.");
return normalizedValue;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'normalizeFloat4ValueInRange', plcsharp_normalize_float4_value(10.0::FLOAT4, 0.0::FLOAT4, 20.0::FLOAT4) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'normalizeFloat4ValueAtTopRange', plcsharp_normalize_float4_value(20.0::FLOAT4, 10.0::FLOAT4, 20.0::FLOAT4) = 1.0::FLOAT4;
```

#### plcsharp_subtract_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_subtract_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
// name: subtract_float4_values
// description: Subtracts the second float4 value from the first and returns the result as float4
// type: float4
// input: First float4 value to be used in subtraction
// input: Second float4 value to subtract from the first value
// output: Result of subtraction as float4

Elog.Info($"DEBUG: FUNCTION subtract_float4_values-1 - Running subtract_float4_values function with inputs 'value1' = {value1}, 'value2' = {value2}.");
float result = (float)(value1 - value2);
Elog.Info($"DEBUG: FUNCTION subtract_float4_values-2 - Function subtract_float4_values is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'subtractFloat4ValuesPosPos', ROUND(plcsharp_subtract_float4_values(5.7::FLOAT4, 2.3::FLOAT4)::NUMERIC, 1) = 3.4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'subtractFloat4ValuesNegPos', plcsharp_subtract_float4_values(-1.2::FLOAT4, 4.6::FLOAT4) = -5.8::FLOAT4;
```

#### plcsharp_test_cosine_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_test_cosine_float4(angle FLOAT4) RETURNS FLOAT4 AS $$
// name: test_cosine_float4
// description: Calculates the cosine of a float4 angle value in radians and returns the result as float4
// type: float4
// input: Angle in radians for which the cosine has to be calculated (float4)
// output: The cosine of the provided angle (float4)

Elog.Info($"DEBUG: FUNCTION test_cosine_float4-1 - Running test_cosine_float4_plcsharp function with input 'angle' = {angle}.");
float nonNullableAngle = angle ?? 0.0f; // Coalescing with default float value 0.0f if angle is null
if (angle == null)
{
    Elog.Info($"DEBUG: FUNCTION test_cosine_float4-2 - 'angle' parameter is null.");
}
Elog.Info($"DEBUG: FUNCTION test_cosine_float4-3 - Calculating cosine of 'angle' = {nonNullableAngle}.");
float result = (float)Math.Cos(nonNullableAngle); // Casting to float to ensure float4 type is returned
Elog.Info($"DEBUG: FUNCTION test_cosine_float4-4 - Function test_cosine_float4_plcsharp is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_cosine_float4_zero', plcsharp_test_cosine_float4(0.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_cosine_float4_pi_half', ABS(plcsharp_test_cosine_float4(1.5707963::FLOAT4)) < 0.0001::FLOAT4;
```

#### plcsharp_test_float4_rounding✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_test_float4_rounding(original_value FLOAT4) RETURNS FLOAT4 AS $$
// name: test_float4_rounding
// description: This function rounds a float4 value to the nearest whole number and returns it as float4.
// type: float4
// input: A float4 value to be rounded to the nearest whole number
// output: Rounded float4 value to the nearest whole number

Elog.Info($"DEBUG: FUNCTION test_float4_rounding_plcsharp-1 - Running test_float4_rounding function with input 'original_value' = {original_value}.");
float roundedValue = (float)Math.Round((double)original_value, MidpointRounding.AwayFromZero);
Elog.Info($"DEBUG: FUNCTION test_float4_rounding_plcsharp-2 - Function test_float4_rounding is returning 'roundedValue' = {roundedValue}.");
return roundedValue;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_float4_rounding1', plcsharp_test_float4_rounding(2.5::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_float4_rounding2', plcsharp_test_float4_rounding(-3.7::FLOAT4) = -4.0::FLOAT4;
```

#### plcsharp_test_float4_truncation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_test_float4_truncation(number float) RETURNS float AS $$
// name: test_float4_truncation
// description: Truncates a float4 number, removing its decimal part.
// type: float4
// input: A float4 number to be truncated
// output: The truncated float4 number

Elog.Info($"DEBUG: FUNCTION test_float4_truncation-1 - Running test_float4_truncation function with input 'number' = {number}.");
float result = (float)Math.Truncate((double)number);
Elog.Info($"DEBUG: FUNCTION test_float4_truncation-2 - Function test_float4_truncation is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_float4_truncation_positive', plcsharp_test_float4_truncation(123.456::FLOAT4) = 123.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_float4_truncation_negative', plcsharp_test_float4_truncation(-123.456::FLOAT4) = -123.0::FLOAT4;
```

#### plcsharp_test_increment_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_test_increment_float4(number float, increment float) RETURNS float AS $$
// name: test_increment_float4
// description: This function increments a float4 value by a float4 increment and returns the result as float4.
// type: float4
// input: The float4 number to be incremented
// input: The float4 value to increment the number by
// output: The incremented float4 value

Elog.Info($"DEBUG: FUNCTION test_increment_float4-1 - Running test_increment_float4 function with inputs 'number' = {number}, 'increment' = {increment}.");
float result = (float)(number + increment);
Elog.Info($"DEBUG: FUNCTION test_increment_float4-2 - Function test_increment_float4 is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_incrementFloat4Positive', plcsharp_test_increment_float4(8.25::FLOAT4, 1.75::FLOAT4) = 10.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_incrementFloat4NegByPos', plcsharp_test_increment_float4(-3.5::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;
```

#### plcsharp_test_maximum_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_test_maximum_value(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
// name: test_maximum_value
// description: Function to determine the maximum of two float4 values
// type: float4
// input: First float4 value to compare
// input: Second float4 value to compare
// output: Returns the maximum of the two float4 inputs

Elog.Info($"DEBUG: FUNCTION test_maximum_value_plcsharp-1 - Running test_maximum_value function with inputs 'input1' = {input1}, 'input2' = {input2}.");
float result;
if (input1.HasValue && input2.HasValue)
{
    result = input1.Value >= input2.Value ? input1.Value : input2.Value;
}
else
{
    result = input1 ?? input2 ?? float.NaN;
}
Elog.Info($"DEBUG: FUNCTION test_maximum_value_plcsharp-4 - Function test_maximum_value is returning 'result' = {result}.");
return result;
$$ LANGUAGE plcsharp;
-- Test case where the first value is greater
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_maximum_value1', plcsharp_test_maximum_value(12.34::FLOAT4, 9.87::FLOAT4) = 12.34::FLOAT4;
-- Test case where the second value is greater
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'test_maximum_value2', plcsharp_test_maximum_value(-3.21::FLOAT4, 4.56::FLOAT4) = 4.56::FLOAT4;
```

#### plcsharp_validate_even_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plcsharp_validate_even_float4(value FLOAT4) RETURNS bool AS $$
// name: validate_even_float4
// description: Determines whether a float4 number represents an even number
// type: float4
// input: The float4 number to check
// output: Returns true if the number is even, otherwise false

Elog.Info($"DEBUG: FUNCTION validate_even_float4-1 - Running validate_even_float4 function with input 'value' = {value}.");
float nonNullableValue = value ?? 0.0f;
int wholeNumber = (int)Math.Floor(nonNullableValue);
bool isEven = wholeNumber % 2 == 0;
Elog.Info($"DEBUG: FUNCTION validate_even_float4-2 - Function validate_even_float4 is returning 'isEven' = {isEven}.");
return isEven;
$$ LANGUAGE plcsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'validateEvenFloat4EvenWholeNumber', plcsharp_validate_even_float4(4.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plcsharp-float4', 'validateEvenFloat4OddWholeNumber', plcsharp_validate_even_float4(5.0::FLOAT4) = FALSE;
```

### plfsharp

#### plfsharp_add_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_add_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
// name: add_float4_values
// description: Function that adds two float4 values and returns the result as float4
// type: float4
// input: float4 value to be added to value2
// input: float4 value to be added to value1
// output: Sum of value1 and value2 as float4

    Elog.Info($"add_float4_values function called with 'value1' = {value1.GetValueOrDefault().ToString()}, 'value2' = {value2.GetValueOrDefault().ToString()}")
    let sum = value1.GetValueOrDefault() + value2.GetValueOrDefault()
    Elog.Info($"Result of add_float4_values: {sum.ToString()}")
    Nullable(sum)
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_addFloat4ValuesPositive', plfsharp_add_float4_values(1.5::FLOAT4, 2.5::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_addFloat4ValuesPosNeg', plfsharp_add_float4_values(-1.25::FLOAT4, 3.75::FLOAT4) = 2.5::FLOAT4;
```

#### plfsharp_calculate_area_of_rectangle✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_area_of_rectangle(width float4, height float4) RETURNS float4 AS $$
// name: calculate_area_of_rectangle
// description: This function calculates the area of a rectangle given the width and height as float4 types and returns the area as float4
// type: float4
// input: float4 type representing the width of the rectangle
// input: float4 type representing the height of the rectangle
// output: float4 type representing the area of the rectangle

    Elog.Info($"calculate_area_of_rectangle function called with width = {width}, height = {height}")
    let nonNullableWidth = if width.HasValue then width.Value else 0.0f
    let nonNullableHeight = if height.HasValue then height.Value else 0.0f
    let area = nonNullableWidth * nonNullableHeight
    Elog.Info($"Result of calculate_area_of_rectangle: {area}")
    area
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'calculate_area_of_rectangle_Positive', plfsharp_calculate_area_of_rectangle(4.0::FLOAT4, 3.0::FLOAT4) = 12.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'calculate_area_of_rectangle_ZeroDimension', plfsharp_calculate_area_of_rectangle(0.0::FLOAT4, 5.0::FLOAT4) = 0.0::FLOAT4;
```

#### plfsharp_calculate_arithmetic_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_arithmetic_mean(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_arithmetic_mean
// description: Calculates arithmetic mean of two float4 values
// type: float4
// input: First float4 input value.
// input: Second float4 input value.
// output: Arithmetic mean result as float4.

Elog.Info($"DEBUG: FUNCTION calculate_arithmetic_mean_plfsharp - Running calculate_arithmetic_mean_plfsharp function with inputs 'value1' = {value1}, 'value2' = {value2}.");
let total = value1.Value + value2.Value
let count = 2.0f // FLOAT4 cast
let mean = total / count
Elog.Info($"DEBUG: FUNCTION calculate_arithmetic_mean_plfsharp - Function calculate_arithmetic_mean_plfsharp is returning 'mean' = {mean}.");
mean
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateArithmeticMeanPositives', plfsharp_calculate_arithmetic_mean(3.5::FLOAT4, 2.5::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateArithmeticMeanPosNeg', plfsharp_calculate_arithmetic_mean(5.0::FLOAT4, -3.0::FLOAT4) = 1.0::FLOAT4;
```

#### plfsharp_calculate_arithmetic_progression_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_arithmetic_progression_sum(a FLOAT4, d FLOAT4, n FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_arithmetic_progression_sum
// description: Calculate the sum of the first n terms of an arithmetic progression, given the first term (a), the common difference (d), and the number of terms (n), returning the sum as float4.
// type: float4
// input: the first term of the arithmetic progression (float4)
// input: the common difference between the terms (float4)
// input: the number of terms to sum (float4)
// output: the sum of the first n terms of the arithmetic progression (float4)

    Elog.Info($"DEBUG: FUNCTION calculate_arithmetic_progression_sum - Running with inputs 'a' = {a}, 'd' = {d}, 'n' = {n}.")

    let aNonNullable = if a.HasValue then a.Value else 0.0f
    let dNonNullable = if d.HasValue then d.Value else 0.0f
    let nNonNullable = if n.HasValue then n.Value else 0.0f

    let n_minus_one = nNonNullable - 1.0f
    let term1 = nNonNullable * aNonNullable
    let term2 = dNonNullable * n_minus_one * nNonNullable / 2.0f
    let sn = term1 + term2

    Elog.Info($"DEBUG: FUNCTION calculate_arithmetic_progression_sum - Result 'sn' = {sn}.")
    sn
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateArithmeticProgressionSum1', plfsharp_calculate_arithmetic_progression_sum(2.0::FLOAT4, 2.0::FLOAT4, 5.0::FLOAT4) = 30.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateArithmeticProgressionSum2', plfsharp_calculate_arithmetic_progression_sum(1.5::FLOAT4, 1.5::FLOAT4, 3.0::FLOAT4) = 9.0::FLOAT4;
```

#### plfsharp_calculate_ceil✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_ceil(number float4) RETURNS float4 AS $$
// name: calculate_ceil
// description: This function calculates and returns the smallest integer greater than or equal to the given float4 number.
// type: float4
// input: A float4 number to calculate the ceiling value for
// output: The ceiling value of the input as float4

Elog.Info($"calculate_ceil function called with number = {number}.");
// Determine the smallest integer greater than or equal to the input number
let result = Math.Ceiling(float(number.Value));
Elog.Info($"Result of calculate_ceil: {result}.");
// Return this integer as a float4 value
Nullable(float32(result))
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateCeilPositive', plfsharp_calculate_ceil(3.45::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateCeilNegative', plfsharp_calculate_ceil(-1.78::FLOAT4) = -1.0::FLOAT4;
```

#### plfsharp_calculate_circumference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_circumference(radius FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_circumference
// description: Calculates the circumference of a circle given the radius as float4
// type: float4
// input: The radius of the circle as float4
// output: The circumference of the circle as float4

    if(radius.HasValue) then
        Elog.Info($"plfsharp_calculate_circumference function called with radius = {radius}.")

        let PI = 3.1415926535f
        let diameter = radius.Value * 2.0f
        let circumference = diameter * PI

        Elog.Info($"Computed circumference = {circumference}.")
        Nullable(circumference)
    else
        Nullable()
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateCircumferenceSmallRadius', plfsharp_calculate_circumference(2.0::FLOAT4) = 12.566370614::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateCircumferenceLargeRadius', plfsharp_calculate_circumference(100.0::FLOAT4) = 628.3185307179584::FLOAT4;
```

#### plfsharp_calculate_distance_between_float4_points✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_distance_between_float4_points(x1 FLOAT4, y1 FLOAT4, x2 FLOAT4, y2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_distance_between_float4_points
// description: Calculates the distance between two points in 2D space using float4 for coordinates
// type: float4
// input: The x-coordinate of the first point as a float4
// input: The y-coordinate of the first point as a float4
// input: The x-coordinate of the second point as a float4
// input: The y-coordinate of the second point as a float4
// output: The distance between the two points as a float4

    Elog.Info($"DEBUG: FUNCTION calculate_distance_between_float4_points-1 - Running calculate_distance_between_float4_points function with inputs 'x1' = {x1.Value}, 'y1' = {y1.Value}, 'x2' = {x2.Value}, 'y2' = {y2.Value}.");

    let delta_x = x2.Value - x1.Value
    let delta_y = y2.Value - y1.Value
    let square_delta_x = delta_x * delta_x
    let square_delta_y = delta_y * delta_y
    let sum_squares = square_delta_x + square_delta_y
    let distance = Math.Sqrt(float sum_squares)

    Elog.Info($"DEBUG: FUNCTION calculate_distance_between_float4_points-2 - Function calculate_distance_between_float4_points is returning 'distance' = {distance}.");

    Nullable(float32 distance)
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateDistanceBetweenFloat4PointsSame', plfsharp_calculate_distance_between_float4_points(0.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateDistanceBetweenFloat4PointsDifferent', plfsharp_calculate_distance_between_float4_points(3.0::FLOAT4, 4.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4) = 5.0::FLOAT4;
```

#### plfsharp_calculate_float4_as_percentage_of_another✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_float4_as_percentage_of_another(value FLOAT4, total FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_as_percentage_of_another
// description: Calculates one float4 value as a percentage of another float4 value.
// type: float4
// input: The float4 number to calculate the percentage for
// input: The float4 number representing the total or 100%
// output: The percentage of 'value' relative to 'total' as float4

Elog.Info("calculate_float4_as_percentage_of_another function called with value = " + value.ToString() + ", total = " + total.ToString())
if total = 0.0f then
    Elog.Error("Total cannot be zero.")
    new Nullable<float32>(-1.0f) // Adjusted to return Nullable<float32>, consider defining an error value
else
    let ratio = value.Value / total.Value
    let percentage = ratio * 100.0f
    Elog.Info("Result of calculate_float4_as_percentage_of_another: " + percentage.ToString())
    new Nullable<float32>(percentage)
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4AsPercentageOfAnotherKnownPercentage', plfsharp_calculate_float4_as_percentage_of_another(25.0::FLOAT4, 50.0::FLOAT4) = 50.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4AsPercentageOfAnotherFractionalPercentage', plfsharp_calculate_float4_as_percentage_of_another(1.0::FLOAT4, 200.0::FLOAT4) = 0.5::FLOAT4;
```

#### plfsharp_calculate_float4_complement✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_float4_complement(input_number float) RETURNS float AS $$
// name: calculate_float4_complement
// description: Calculates the complement of a float4 number with respect to 1, that is, it calculates 1 - n for a given float4 n.
// type: float4
// input: A float4 number which is the value to find the complement of.
// output: The complement of the input float4 number with respect to 1 as float4.

    Elog.Info("calculate_float4_complement function called with input_number = " + input_number.ToString())
    let result = 1.0 - float(input_number)
    Elog.Info("Result of calculate_float4_complement: " + result.ToString())
    Nullable(result)
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4ComplementLessThanOne', plfsharp_calculate_float4_complement(0.25::float) = 0.75;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4ComplementGreaterThanOne', plfsharp_calculate_float4_complement(1.25::float) = -0.25;
```

#### plfsharp_calculate_float4_dot_product✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_float4_dot_product(vector1_x FLOAT4, vector1_y FLOAT4, vector2_x FLOAT4, vector2_y FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_dot_product
// description: Calculates the dot product of two 2D vectors, each vector component is a float4 type
// type: float4
// input: x component of the first vector (float4)
// input: y component of the first vector (float4)
// input: x component of the second vector (float4)
// input: y component of the second vector (float4)
// output: dot product of the two vectors (float4)

    let vector1_x = vector1_x.Value
    let vector1_y = vector1_y.Value
    let vector2_x = vector2_x.Value
    let vector2_y = vector2_y.Value
    Elog.Info("calculate_float4_dot_product function called with vector1_x = " + vector1_x.ToString() + ", vector1_y = " + vector1_y.ToString() + ", vector2_x = " + vector2_x.ToString() + ", vector2_y = " + vector2_y.ToString())
    let result = (vector1_x * vector2_x) + (vector1_y * vector2_y)
    Elog.Info("Result of calculate_float4_dot_product: " + result.ToString())
    Nullable(result)
$$ LANGUAGE plfsharp;
-- Test case: Dot product of two perpendicular vectors
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4DotProductPerpendicular', plfsharp_calculate_float4_dot_product(1.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 1.0::FLOAT4) = 0.0::FLOAT4;
-- Test case: Dot product of two parallel vectors
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4DotProductParallel', plfsharp_calculate_float4_dot_product(1.0::FLOAT4, 1.0::FLOAT4, 2.0::FLOAT4, 2.0::FLOAT4) = 4.0::FLOAT4;
```

#### plfsharp_calculate_float4_inverse✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_float4_inverse(numeric_value FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_inverse
// description: Calculates the multiplicative inverse (or reciprocal) of a non-zero float4 number
// type: float4
// input: The float4 number to invert
// output: The multiplicative inverse of the input as float4, or 'undefined' if the input is zero

    Elog.Info($"calculate_float4_inverse function called with numeric_value = {numeric_value}")
    let inverse = 
        if numeric_value.HasValue then
            let value = numeric_value.Value
            if value = 0.0f then None
            else Some(1.0f / value)
        else None
    match inverse with
    | Some(inv) -> 
        Elog.Info($"Result of calculate_float4_inverse (not zero): {inv}")
        inv
    | None -> 
        Elog.Info("Result of calculate_float4_inverse (zero): undefined")
        raise (new System.ArgumentException("undefined, reciprocal of zero"))
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4InverseNonZero', plfsharp_calculate_float4_inverse(2.0::FLOAT4) = 0.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4InverseZero', plfsharp_calculate_float4_inverse(0.0::FLOAT4) IS NULL;
```

#### plfsharp_calculate_float4_inverse_ratio✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_float4_inverse_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_inverse_ratio
// description: Calculates the inverse ratio of two float4 numbers, returns the result as float4.
// type: float4
// input: First float4 value, acting as the numerator
// input: Second float4 value, acting as the denominator, expected not to be zero
// output: The inverse ratio of the two float4 input values

    Elog.Info($"calculate_float4_inverse_ratio called with numerator = {numerator}, denominator = {denominator}")
    if denominator = 0.0f then
        // Raising an error for zero denominator instead of returning Inf or NaN which might be unexpected
        raise (Failure "Denominator should not be zero")
    else
        let reciprocal = 1.0f / denominator.Value
        let result = reciprocal * numerator.Value
        Elog.Info($"Result of calculate_float4_inverse_ratio: {result}")
        result
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'calculate_float4_inverse_ratio_positive_values', plfsharp_calculate_float4_inverse_ratio(2.0::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'calculate_float4_inverse_ratio_numerator_zero', plfsharp_calculate_float4_inverse_ratio(0.0::FLOAT4, 3.0::FLOAT4) = 0.0::FLOAT4;
```

#### plfsharp_calculate_float4_linear_intercept✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_float4_linear_intercept(x1 FLOAT4, y1 FLOAT4, x2 FLOAT4, y2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_linear_intercept
-- description: Calculates the y-intercept of a line (b) given two points with float4 coordinates (x1, y1) and (x2, y2). The formula used is b = y1 - (slope * x1), where slope is the (y2 - y1) / (x2 - x1).
-- type: float4
-- input: The x-coordinate of the first point as float4
-- input: The y-coordinate of the first point as float4
-- input: The x-coordinate of the second point as float4
-- input: The y-coordinate of the second point as float4
-- output: The y-intercept (b) of the line as float4

BEGIN
    IF x2 = x1 THEN 
        RAISE EXCEPTION 'Division by zero: x-coordinates (x1 and x2) cannot be equal.';
    ELSE
        RETURN y1 - ((y2 - y1) / (x2 - x1)) * x1;
    END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'calculate_float4_linear_intercept1', plfsharp_calculate_float4_linear_intercept(2.0::FLOAT4, 3.0::FLOAT4, 4.0::FLOAT4, 7.0::FLOAT4)::FLOAT4 = -1.0;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'calculate_float4_linear_intercept2', plfsharp_calculate_float4_linear_intercept(5.0::FLOAT4, 8.0::FLOAT4, 3.0::FLOAT4, 4.0::FLOAT4)::FLOAT4 = 12.0;
```

#### plfsharp_calculate_float4_max_absolute_difference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_float4_max_absolute_difference(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_max_absolute_difference
// description: This function calculates the maximum absolute difference between two float4 values
// type: float4
// input: The first float4 input value
// input: The second float4 input value
// output: The maximum absolute difference as float4

Elog.Info($"DEBUG: FUNCTION calculate_float4_max_absolute_difference - Running plfsharp_calculate_float4_max_absolute_difference function with inputs 'input1' = {input1}, 'input2' = {input2}.");
let difference1 = Math.Abs(input1.Value - input2.Value);
let difference2 = Math.Abs(input2.Value - input1.Value);
let max_difference = Math.Max(difference1, difference2);
Elog.Info($"DEBUG: FUNCTION calculate_float4_max_absolute_difference - Function plfsharp_calculate_float4_max_absolute_difference is returning 'max_difference' = {max_difference}.");
max_difference
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4MaxAbsoluteDifference1', plfsharp_calculate_float4_max_absolute_difference(5.5::FLOAT4, 3.0::FLOAT4) = 2.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4MaxAbsoluteDifference2', (ROUND(plfsharp_calculate_float4_max_absolute_difference(2.2::FLOAT4, 4.8::FLOAT4)::NUMERIC, 1) = 2.6::NUMERIC);
```

#### plfsharp_calculate_float4_percentage_change✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_float4_percentage_change(old_value float4, new_value float4) RETURNS float4 AS $$
// name: calculate_float4_percentage_change
// description: Calculates the percentage change from float4 old_value to float4 new_value.
// type: float4
// input: The original float4 value
// input: The new float4 value to compare against the old value
// output: The percentage change as float4

    Elog.Info("calculate_float4_percentage_change function called with old_value = " + old_value.ToString() + ", new_value = " + new_value.ToString())
    if old_value.HasValue && new_value.HasValue then
        let oldVal = old_value.Value
        let newVal = new_value.Value
        
        // Check that old_value is not equal to zero to avoid division by zero
        if oldVal = 0.0f then
            Elog.Error("Old value cannot be zero to calculate percentage change.")
            0.0f // Return zero or an appropriate error value
        else
            // Calculate the percentage change
            let difference = newVal - oldVal
            let percentageChange = (difference / oldVal) * 100.0f
            Elog.Info("Percentage change result: " + percentageChange.ToString() + "%")
            percentageChange
    else
        Elog.Error("Null values provided for old_value or new_value.")
        0.0f // Return zero or an appropriate error value
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculate_float4_percentage_change_greater', plfsharp_calculate_float4_percentage_change(50.0::FLOAT4, 75.0::FLOAT4) = 50.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculate_float4_percentage_change_lesser', plfsharp_calculate_float4_percentage_change(75.0::FLOAT4, 50.0::FLOAT4) = -33.333336::FLOAT4;
```

#### plfsharp_calculate_float4_precision✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_float4_precision(number FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_precision
// description: Calculates the precision (number of decimal places) of a float4 number
// type: float4
// input: A float4 number to calculate the precision of
// output: The precision (number of decimal places) of the number as float4

Elog.Info($"DEBUG: FUNCTION calculate_float4_precision-1 - Running calculate_float4_precision function with input 'number' = {number}.")

let numberAsString = number.ToString()
let decimalPointIndex = numberAsString.IndexOf('.')
let precision = if decimalPointIndex >= 0 then numberAsString.Length - decimalPointIndex - 1 else 0
let precisionAsFloat4 = float32 precision

Elog.Info($"DEBUG: FUNCTION calculate_float4_precision-2 - Function calculate_float4_precision is returning 'precision' = {precisionAsFloat4}.")
precisionAsFloat4
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4Precision1', plfsharp_calculate_float4_precision(123.45::FLOAT4) = 2.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4Precision2', plfsharp_calculate_float4_precision(456.0::FLOAT4) = 0.0::FLOAT4;
```

#### plfsharp_calculate_float4_quadratic_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_float4_quadratic_sum(num1 FLOAT4, num2 FLOAT4, num3 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_quadratic_sum
// description: Calculates the sum of squares of three float4 numbers and returns the result as float4.
// type: float4
// input: First float4 number
// input: Second float4 number
// input: Third float4 number
// output: Sum of squares of num1, num2, and num3 as float4

Elog.Info($"DEBUG: FUNCTION calculate_float4_quadratic_sum-1 - Running plfsharp_calculate_float4_quadratic_sum function with inputs 'num1' = {num1}, 'num2' = {num2}, 'num3' = {num3}.");
let result1 = (float32)num1 * (float32)num1
let result2 = (float32)num2 * (float32)num2
let result3 = (float32)num3 * (float32)num3
let sum_of_squares = result1 + result2 + result3
Elog.Info($"DEBUG: FUNCTION calculate_float4_quadratic_sum-2 - Function plfsharp_calculate_float4_quadratic_sum is returning 'sum_of_squares' = {sum_of_squares}.");
sum_of_squares
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'calculate_float4_quadratic_sum_positives', plfsharp_calculate_float4_quadratic_sum(3.0::FLOAT4, 4.0::FLOAT4, 5.0::FLOAT4) = 50.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'calculate_float4_quadratic_sum_negatives', plfsharp_calculate_float4_quadratic_sum(-3.0::FLOAT4, 4.0::FLOAT4, -5.0::FLOAT4) = 50.0::FLOAT4;
```

#### plfsharp_calculate_float4_ratio✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_float4_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_ratio
// description: Calculates the ratio of two float4 numbers and returns the result as float4. Ratio is the result of dividing the first float4 value by the second, provided the second is not zero.
// type: float4
// input: The numerator for the ratio calculation. Type: float4
// input: The denominator for the ratio calculation. Type: float4. Must not be zero.
// output: The calculated ratio as float4. If the denominator is zero, the function will return null.

    Elog.Info($"DEBUG: FUNCTION calculate_float4_ratio_plfsharp - Running calculate_float4_ratio function with inputs 'numerator' = {numerator}, 'denominator' = {denominator}.")

    if denominator = 0.0f then
        Elog.Info($"DEBUG: FUNCTION calculate_float4_ratio_plfsharp - Denominator is zero, returning null.")
        Nullable()
    else
        let ratio = numerator.Value / denominator.Value
        Elog.Info($"DEBUG: FUNCTION calculate_float4_ratio_plfsharp - Calculated ratio is {ratio}.")
        Nullable(ratio)
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4Ratio1', plfsharp_calculate_float4_ratio(25.0::FLOAT4, 5.0::FLOAT4) = 5.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4Ratio2', COALESCE(plfsharp_calculate_float4_ratio(10.0::FLOAT4, 0.0::FLOAT4)::TEXT, 'undefined') = 'undefined';
```

#### plfsharp_calculate_float4_ratio_and_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_float4_ratio_and_sum(number1 FLOAT4, number2 FLOAT4) RETURNS TABLE(ratio FLOAT, sum FLOAT) AS $$
-- name: calculate_float4_ratio_and_sum
-- description: Calculates the ratio of two float4 numbers and their sum
-- type: float4
-- input: First float4 number
-- input: Second float4 number, cannot be zero as it will be used as divisor
-- output: An object with the ratio and sum of the two float4 numbers

BEGIN
    IF number2 = 0.0 THEN 
        RAISE EXCEPTION 'Division by zero is not allowed.';
    END IF;

    ratio := number1 / number2;
    sum := number1 + number2;

    RETURN QUERY SELECT ratio, sum;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4RatioAndSum1', (SELECT (ratio = 2.0::FLOAT4 AND sum = 9.0::FLOAT4) FROM plfsharp_calculate_float4_ratio_and_sum(6.0::FLOAT4, 3.0::FLOAT4) LIMIT 1) AS result;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4RatioAndSum2', (SELECT (ratio = -2.0::FLOAT4 AND sum = -4.0::FLOAT4) FROM plfsharp_calculate_float4_ratio_and_sum(-8.0::FLOAT4, 4.0::FLOAT4) LIMIT 1) AS result;
```

#### plfsharp_calculate_float4_remainder✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_float4_remainder(dividend FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
/* name: calculate_float4_remainder
 description: Calculates the remainder of division between two float4 numbers
 type: float4
 input: float4 value representing the dividend
 input: float4 value representing the divisor
 output: float4 value representing the remainder of the division
*/

    DECLARE
        remainder FLOAT4;

    BEGIN

    RAISE NOTICE 'DEBUG: FUNCTION plfsharp_calculate_float4_remainder - Running plfsharp_calculate_float4_remainder function with inputs "dividend" = %, "divisor" = %', dividend, divisor;

    IF (divisor = 0) THEN
        RAISE NOTICE 'DEBUG: FUNCTION plfsharp_calculate_float4_remainder - Divisor is 0, cannot divide by zero.';
        RETURN NULL;
    END IF;

    remainder := dividend % divisor;

    RAISE NOTICE 'DEBUG: FUNCTION plfsharp_calculate_float4_remainder - Function is returning "remainder" = %', remainder;
    RETURN remainder;

    END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculate_float4_remainder2', plfsharp_calculate_float4_remainder(5.0::FLOAT4, 0.0::FLOAT4) IS NULL;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculate_float4_remainder1', plfsharp_calculate_float4_remainder(5.0::FLOAT4, 2.0::FLOAT4) = 1.0::FLOAT4;
```

#### plfsharp_calculate_float4_rounded_average✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_float4_rounded_average(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_rounded_average
// description: Calculate the average of two float4 values and round it to the nearest whole number, returning the result as a float4
// type: float4
// input: The first float4 value for the average calculation
// input: The second float4 value for the average calculation
// output: The rounded average of value1 and value2 as a float4

let average = (value1.GetValueOrDefault() + value2.GetValueOrDefault()) / 2.0f
let rounded_average = System.Math.Round(float(average))
Nullable<float32>(float32(rounded_average))
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4RoundedAverage1', plfsharp_calculate_float4_rounded_average(25.4::FLOAT4, 34.6::FLOAT4) = 30.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateFloat4RoundedAverage2', plfsharp_calculate_float4_rounded_average(-14.8::FLOAT4, 20.2::FLOAT4) = 3.0::FLOAT4;
```

#### plfsharp_calculate_float4_to_power_of_integer✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_float4_to_power_of_integer(float4_base FLOAT4, integer_exponent INT) RETURNS FLOAT4 AS $$
// name: calculate_float4_to_power_of_integer
// description: This function takes a float4 base number and an integer exponent, then raises the base to the power of the exponent returning a float4 result
// type: float4
// input: float4 number serving as the base for the power operation
// input: Integer serving as the exponent for the power operation
// output: float4 result of the base raised to the power of the exponent

    Elog.Info($"calculate_float4_to_power_of_integer called with float4_base = {float4_base}, integer_exponent = {integer_exponent}")
    let baseNullable = if float4_base.HasValue then float4_base.Value else 0.0f
    let exponentNullable = if integer_exponent.HasValue then integer_exponent.Value else 0
    let result = Math.Pow(float baseNullable, exponentNullable)
    let resultFloat4 = Convert.ToSingle(result)
    Elog.Info($"Result of calculate_float4_to_power_of_integer: {resultFloat4}")
    resultFloat4
$$ LANGUAGE plfsharp;
-- Test case 1: Raising a float4 value to the power of a positive integer
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'calculate_float4_to_power_of_integer1', plfsharp_calculate_float4_to_power_of_integer(2.5::FLOAT4, 3::INT) = 15.625::FLOAT4;
-- Test case 2: Raising a float4 value to the power of zero
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'calculate_float4_to_power_of_integer2', plfsharp_calculate_float4_to_power_of_integer(7.0::FLOAT4, 0::INT) = 1.0::FLOAT4;
```

#### plfsharp_calculate_float4_with_exponential_notation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_float4_with_exponential_notation(number FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_with_exponential_notation
// description: Converts a float4 number in exponential notation to a float4 number in standard decimal notation
// type: float4
// input: float4 number in exponential notation
// output: float4 number in standard decimal notation

    Elog.Info("calculate_float4_with_exponential_notation function called with number = " + number.ToString())
    let nonNullableNumber = if number.HasValue then number.Value else 0.0f
    let result = nonNullableNumber
    Elog.Info("Result of calculate_float4_with_exponential_notation: " + result.ToString())
    result
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculate_float4_with_exponential_notation_small', plfsharp_calculate_float4_with_exponential_notation('2.5e-4'::FLOAT4) = '0.00025'::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculate_float4_with_exponential_notation_large', plfsharp_calculate_float4_with_exponential_notation('3.57e+2'::FLOAT4) = '357.0'::FLOAT4;
```

#### plfsharp_calculate_harmonic_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_harmonic_mean(number1 FLOAT4, number2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_harmonic_mean
-- description: Calculates the harmonic mean of two float4 numbers
-- type: float4
-- input: First float4 number
-- input: Second float4 number
-- output: Harmonic mean of the two float4 numbers as float4

DECLARE
    reciprocalSum FLOAT4;
    result FLOAT4;
BEGIN
    -- Log statements are not supported in the current context
    -- Elog.Info($"harmonicMean function called with number1 = {number1}, number2 = {number2}");
    IF (number1 = 0.0 OR number2 = 0.0) THEN
        -- Log statements are not supported in the current context
        -- Elog.Info("One of the inputs is zero, returning 'undefined'");
        RETURN NULL; -- 'undefined' is represented as null in the database.
    END IF;
    reciprocalSum := (1.0 / number1) + (1.0 / number2);
    result := 2.0 / reciprocalSum;
    -- Log statements are not supported in the current context
    -- Elog.Info($"Result of harmonicMean: {result}");
    RETURN result;
END
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_harmonicMeanPositive', plfsharp_calculate_harmonic_mean(4.0::FLOAT4, 8.0::FLOAT4) = 5.3333334::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_harmonicMeanWithZero', plfsharp_calculate_harmonic_mean(0.0::FLOAT4, 5.0::FLOAT4) IS NULL;
```

#### plfsharp_calculate_linear_intercept✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_linear_intercept(x1 FLOAT4, y1 FLOAT4, m FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_linear_intercept
// description: Calculates the y-intercept (b) of a linear equation in the form y = mx + b using a point (x1, y1) and the slope (m)
// type: float4
// input: float4 - the x-coordinate of the point
// input: float4 - the y-coordinate of the point
// input: float4 - the slope of the line
// output: float4 - the y-intercept of the line

    let b =  y1.Value - (m.Value * x1.Value) // Calculate the y-intercept
    b
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateLinearIntercept1', plfsharp_calculate_linear_intercept(3.0::FLOAT4, 4.0::FLOAT4, 2.0::FLOAT4) = -2.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateLinearIntercept2', plfsharp_calculate_linear_intercept(-1.0::FLOAT4, -3.0::FLOAT4, -2.0::FLOAT4) = -5.0::FLOAT4;
```

#### plfsharp_calculate_linear_interpolation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_linear_interpolation(value1 FLOAT4, value2 FLOAT4, fraction FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_linear_interpolation
-- description: Interpolates between two float4 values at a specific increment
-- type: float4
-- input: starting float4 value for interpolation
-- input: ending float4 value for interpolation
-- input: the float4 fraction representing the interpolation point between value1 and value2
-- output: interpolated float4 value

BEGIN
    IF (fraction < 0.0 OR fraction > 1.0) THEN
        RAISE EXCEPTION 'Fraction must be between 0.0 and 1.0 inclusive';
    END IF;

    DECLARE
        difference FLOAT4;
        interpolatedValue FLOAT4;
    BEGIN
        difference := value2 - value1;
        interpolatedValue := value1 + (difference * fraction);

        RETURN interpolatedValue;
    END;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 
    'plfsharp-float4', 
    'test_calculateLinearInterpolationMidRange', 
    plfsharp_calculate_linear_interpolation(10.75::FLOAT4, 20.5::FLOAT4, 0.5::FLOAT4) = 15.625::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 
    'plfsharp-float4', 
    'test_calculateLinearInterpolationStartValue', 
    plfsharp_calculate_linear_interpolation(-5.0::FLOAT4, 5.0::FLOAT4, 0.1::FLOAT4) = -4.0::FLOAT4;
```

#### plfsharp_calculate_log_base_n✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_log_base_n(number float4, base float4) RETURNS float4 AS $$
/* name: calculate_log_base_n
 description: Calculates the logarithm of a float4 number with a float4 custom base and returns the result as float4. Rejects a base that is less than or equal to 0, or equal to 1, and a number that is less than or equal to 0.
 type: float4
 input: Value to find the logarithm of. Must be greater than 0.
 input: Base of the logarithm. Must be greater than 0 and not equal to 1.
 output: Logarithm of the number to the base provided. If the base or number is invalid, the output is 'undefined'.
*/
    BEGIN
        IF base <= 0.0 OR base = 1.0 THEN
            RAISE EXCEPTION 'Invalid base provided.';
            RETURN NULL;
        END IF;

        IF number <= 0.0 THEN
            RAISE EXCEPTION 'Invalid number provided.';
            RETURN NULL;
        END IF;

        RETURN log(number) / log(base);
    END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateLogBaseNValid', plfsharp_calculate_log_base_n(32.0::FLOAT4, 2.0::FLOAT4) = 5.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateLogBaseNInvalidBase', plfsharp_calculate_log_base_n(100.0::FLOAT4, 10.0::FLOAT4) IS NOT NULL;
```

#### plfsharp_calculate_median_of_two_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_median_of_two_float4(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_median_of_two_float4
// description: Calculates the median of two float4 numbers and returns the result as float4
// type: float4
// input: First float4 input value
// input: Second float4 input value
// output: Median of input1 and input2 as float4

    Elog.Info($"calculate_median_of_two_float4 function called with input1 = {input1}, input2 = {input2}")
    let mutable median = 0.0f
    if input1 = input2 then
        median <- input1.Value
    else 
        median <- (input1.Value + input2.Value) / 2.0f
    Elog.Info($"calculate_median_of_two_float4 returning median = {median}")
    median
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'calculate_median_of_two_float4_identical', plfsharp_calculate_median_of_two_float4(10.0::FLOAT4, 10.0::FLOAT4) = 10.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'calculate_median_of_two_float4_different', plfsharp_calculate_median_of_two_float4(10.0::FLOAT4, 20.0::FLOAT4) = 15.0::FLOAT4;
```

#### plfsharp_calculate_percentage_difference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_percentage_difference(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_percentage_difference
// description: Calculates the percentage difference between two float4 values
// type: float4
// input: First float4 value
// input: Second float4 value
// output: Percentage difference as float4

    if value1.HasValue && value2.HasValue then
        let v1 = value1.Value
        let v2 = value2.Value
        Elog.Info($"calculate_percentage_difference function called with value1 = {v1}, value2 = {v2}")
        let abs_difference = Math.Abs(v1 - v2)
        let average_value = (v1 + v2) / 2.0f
        let percentage_difference = (abs_difference / average_value) * 100.0f
        Elog.Info($"Result of calculate_percentage_difference: {percentage_difference}")
        Nullable(percentage_difference)
    else
        Nullable()
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculatePercentageDifference1', plfsharp_calculate_percentage_difference(150.0::FLOAT4, 100.0::FLOAT4) = 40.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculatePercentageDifference2', plfsharp_calculate_percentage_difference(75.0::FLOAT4, 125.0::FLOAT4) = 50.0::FLOAT4;
```

#### plfsharp_calculate_product_of_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_product_of_float4(number1 FLOAT4, number2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_product_of_float4
// description: Calculates the product of two float4 numbers and returns the result as a float4
// type: float4
// input: The first float4 number to be multiplied
// input: The second float4 number to be multiplied
// output: The product of the two float4 inputs as a float4

    Elog.Info($"DEBUG: FUNCTION plfsharp_calculate_product_of_float4 - Running with inputs 'number1' = {number1}, 'number2' = {number2}.")
    let num1 = if number1.HasValue then number1.Value else 0.0f
    let num2 = if number2.HasValue then number2.Value else 0.0f
    let product = num1 * num2
    Elog.Info($"DEBUG: FUNCTION plfsharp_calculate_product_of_float4 - Result 'product' = {product}.")
    Nullable(product) // ensure the result is Nullable type
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateProductOfFloat42', plfsharp_calculate_product_of_float4(-5.0::FLOAT4, 2.5::FLOAT4) = -12.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateProductOfFloat41', plfsharp_calculate_product_of_float4(3.14::FLOAT4, 1.59::FLOAT4) = 4.9916::FLOAT4;
```

#### plfsharp_calculate_quadratic_roots✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_quadratic_roots(a FLOAT4, b FLOAT4, c FLOAT4) RETURNS FLOAT4[] AS $$
// name: calculate_quadratic_roots
// description: Calculates the roots of a quadratic equation ax^2 + bx + c = 0 using the quadratic formula and returns them as an array of float4
// type: float4
// input: float4 coefficient for x^2
// input: float4 coefficient for x
// input: float4 constant term
// output: array of float4 containing the two roots

    if a.HasValue && b.HasValue && c.HasValue then
        let a' = a.Value : float32
        let b' = b.Value : float32
        let c' = c.Value : float32
        Elog.Info($"DEBUG: FUNCTION calculate_quadratic_roots_plfsharp - Calculating roots with coefficients a = {a'}, b = {b'}, c = {c'}.")
        let discriminant = (b' * b') - (4.0f * a' * c')
        if discriminant < 0.0f then
            Elog.Info("DEBUG: FUNCTION calculate_quadratic_roots_plfsharp - No real roots found.")
            [||]
        else
            let root_part = float32 (Math.Sqrt(float discriminant))
            let denominator = 2.0f * a'
            let root1 = (-b' + root_part) / denominator
            let root2 = (-b' - root_part) / denominator
            if discriminant = 0.0f then
                Elog.Info($"DEBUG: FUNCTION calculate_quadratic_roots_plfsharp - One real root found: {root1}.")
                [|root1|]
            else
                Elog.Info($"DEBUG: FUNCTION calculate_quadratic_roots_plfsharp - Two real roots found: {root1}, {root2}.")
                [|root1; root2|]
    else
        raise (ArgumentNullException("Arguments cannot be null."))
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateQuadraticRootsDistinct', ARRAY[3.0::FLOAT4, 2.0::FLOAT4] = plfsharp_calculate_quadratic_roots(1.0::FLOAT4, -5.0::FLOAT4, 6.0::FLOAT4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateQuadraticRootsSingle', ARRAY[2.0::FLOAT4] = plfsharp_calculate_quadratic_roots(1.0::FLOAT4, -4.0::FLOAT4, 4.0::FLOAT4);
```

#### plfsharp_calculate_scaled_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_scaled_value(value FLOAT4, factor FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_scaled_value
// description: This function takes an input float4 value and scales it by a given float4 factor.
// type: float4
// input: The original float4 value to be scaled
// input: The float4 factor by which to scale the value
// output: The scaled float4 value

    Elog.Info("calculate_scaled_value function called with value = " + value.ToString() + ", factor = " + factor.ToString())
    let valueNonNullable = if value.HasValue then value.Value else 0.0f
    let factorNonNullable = if factor.HasValue then factor.Value else 0.0f
    let result = valueNonNullable * factorNonNullable
    Elog.Info("Result of calculate_scaled_value: " + result.ToString())
    result
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateScaledValueUp', plfsharp_calculate_scaled_value(1.5::FLOAT4, 2.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_calculateScaledValueDown', plfsharp_calculate_scaled_value(3.0::FLOAT4, 0.5::FLOAT4) = 1.5::FLOAT4;
```

#### plfsharp_calculate_thermal_expansion✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_thermal_expansion(original_length FLOAT4, temperature_change FLOAT4, coefficient_of_expansion FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_thermal_expansion
// description: Calculates the linear thermal expansion of a material given its original length, temperature change, and the material's coefficient of linear expansion
// type: float4
// input: the original length of the material before thermal expansion (float4)
// input: the change in temperature that the material undergoes (float4)
// input: the coefficient of linear expansion of the material (float4)
// output: the new length of the material after thermal expansion (float4)

    // Ensure that input types are not nullable
    let original_length = original_length.Value
    let temperature_change = temperature_change.Value
    let coefficient_of_expansion = coefficient_of_expansion.Value
    Elog.Info($"DEBUG: FUNCTION calculate_thermal_expansion_plfsharp - Running with original_length = {original_length}, temperature_change = {temperature_change}, coefficient_of_expansion = {coefficient_of_expansion}.")
    let expansion = original_length * temperature_change * coefficient_of_expansion
    let new_length = original_length + expansion
    Elog.Info($"DEBUG: FUNCTION calculate_thermal_expansion_plfsharp - New length after expansion = {new_length}.")
    Nullable(new_length)
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'calculate_thermal_expansion_small_temperature_change', plfsharp_calculate_thermal_expansion(10.0::FLOAT4, 0.0005::FLOAT4, 0.000012::FLOAT4) = 10.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'calculate_thermal_expansion_large_temperature_change', plfsharp_calculate_thermal_expansion(5.0::FLOAT4, 0.05::FLOAT4, 0.000015::FLOAT4) = 5.000004::FLOAT4;
```

#### plfsharp_calculate_weight_force✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_calculate_weight_force(mass FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_weight_force
// description: Calculates the force due to weight of an object using the formula F = m * g, where m is mass in kilograms, and g is acceleration due to gravity at 9.81 m/s^2 (represented as float4)
// type: float4
// input: mass of the object as float4
// output: the weight force as float4

    Elog.Info($"DEBUG: FUNCTION plfsharp_calculate_weight_force - Running with 'mass' = {mass}.");
    let acceleration_due_to_gravity = 9.81f; // constant
    let weight_force = acceleration_due_to_gravity * mass.Value;
    Elog.Info($"DEBUG: FUNCTION plfsharp_calculate_weight_force - Calculated 'weight_force' = {weight_force}.");
    Nullable(weight_force)
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'calculate_weight_force1', plfsharp_calculate_weight_force(2.0::FLOAT4) = 19.62::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'calculate_weight_force2', plfsharp_calculate_weight_force(5.5::FLOAT4) = 53.955::FLOAT4;
```

#### plfsharp_check_float4_equality✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_check_float4_equality(input1 float4, input2 float4) RETURNS bool AS $$
// name: check_float4_equality
// description: Checks whether two float4 values are equal
// type: float4
// input: First float4 value to be compared
// input: Second float4 value to be compared
// output: Boolean result determining if the two float4 values are equal

    Elog.Info($"DEBUG: FUNCTION check_float4_equality_plfsharp - Running check_float4_equality_plfsharp function with inputs 'input1' = {input1}, 'input2' = {input2}.")
    let result = input1 = input2
    Elog.Info($"DEBUG: FUNCTION check_float4_equality_plfsharp - Function check_float4_equality_plfsharp is returning 'result' = {result}.")
    result
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'checkFloat4EqualityEqual', plfsharp_check_float4_equality(4.0000::FLOAT4, 4.0000::FLOAT4) = true;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'checkFloat4EqualityNotEqual', plfsharp_check_float4_equality(4.0000::FLOAT4, -3.9999::FLOAT4) = false;
```

#### plfsharp_check_float4_is_positive✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_check_float4_is_positive(number float4) RETURNS float4 AS $$
// name: check_float4_is_positive
// description: Determines if a float4 input is positive
// type: float4
// input: The float4 number to check
// output: A float4 representing a boolean true or false, 1.0 for true and 0.0 for false

    Elog.Info("check_float4_is_positive function called with number = " + number.ToString())
    let result = if number.HasValue && number.Value > 0.0f then 1.0f else 0.0f
    Elog.Info("Result of check_float4_is_positive: " + result.ToString())
    result
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'checkFloat4IsPositiveTC1', plfsharp_check_float4_is_positive(0.1::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'checkFloat4IsPositiveTC2', plfsharp_check_float4_is_positive(-0.1::FLOAT4) = 0.0::FLOAT4;
```

#### plfsharp_check_float4_within_bounds✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_check_float4_within_bounds(value FLOAT4, lower_bound FLOAT4, upper_bound FLOAT4) RETURNS FLOAT4 AS $$
// name: check_float4_within_bounds
// description: Determines whether a float4 value is between two boundary float4 values (exclusive)
// type: float4
// input: the float4 value to check
// input: the lower float4 boundary
// input: the upper float4 boundary
// output: boolean represented as float4 (1.0 for true, 0.0 for false)

    Elog.Info($"check_float4_within_bounds function called with value = {value}, lower_bound = {lower_bound}, upper_bound = {upper_bound}")
    let valueNonNullable = if value.HasValue then value.Value else 0.0f
    let lowerBoundNonNullable = if lower_bound.HasValue then lower_bound.Value else 0.0f
    let upperBoundNonNullable = if upper_bound.HasValue then upper_bound.Value else 0.0f
    let result = if valueNonNullable > lowerBoundNonNullable && valueNonNullable < upperBoundNonNullable then 1.0f else 0.0f
    Elog.Info($"Result of check_float4_within_bounds: {result}")
    result
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'checkFloat4WithinBoundsWithin', plfsharp_check_float4_within_bounds(5.75::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'checkFloat4WithinBoundsOutside', plfsharp_check_float4_within_bounds(-3.14::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 0.0::FLOAT4;
```

#### plfsharp_check_float4_within_tolerance✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_check_float4_within_tolerance(float4_num1 FLOAT4, float4_num2 FLOAT4, tolerance FLOAT4) RETURNS bool AS $$
// name: check_float4_within_tolerance
// description: Checks if two float4 numbers are within a specified tolerance
// type: float4
// input: First float4 number to compare
// input: Second float4 number to compare
// input: The float4 tolerance within which the two numbers are considered equal
// output: Boolean float4 indicating if the numbers are within the tolerance

    Elog.Info($"check_float4_within_tolerance function called with float4_num1 = {float4_num1}, float4_num2 = {float4_num2}, tolerance = {tolerance}");
    let nonNullableFloat4Num1 = if float4_num1.HasValue then float4_num1.Value else 0.0f;
    let nonNullableFloat4Num2 = if float4_num2.HasValue then float4_num2.Value else 0.0f;
    let nonNullableTolerance = if tolerance.HasValue then tolerance.Value else 0.0f;
    let difference = Math.Abs(nonNullableFloat4Num1 - nonNullableFloat4Num2);
    let within_tolerance = difference <= nonNullableTolerance;
    Elog.Info($"Result of check_float4_within_tolerance: {within_tolerance}");
    within_tolerance
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'checkFloat4WithinToleranceCase1', plfsharp_check_float4_within_tolerance(100.0::FLOAT4, 100.05::FLOAT4, 0.1::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'checkFloat4WithinToleranceCase2', plfsharp_check_float4_within_tolerance(200.0::FLOAT4, 200.2::FLOAT4, 0.1::FLOAT4) = FALSE;
```

#### plfsharp_clamp_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_clamp_value(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS FLOAT4 AS $$
// name: clamp_value
// description: Clamps a given float4 value between a minimum and maximum float4 range
// type: float4
// input: The float4 value to be clamped
// input: The minimum float4 value in the range
// input: The maximum float4 value in the range
// output: The clamped float4 value

    // Log the function call with input values
    Elog.Info($"DEBUG: FUNCTION clamp_value_plfsharp - Called with 'value' = {value}, 'min_value' = {min_value}, 'max_value' = {max_value}.");

    // Perform the clamping operation
    let clampedValue = Math.Max(Math.Min(value.Value, max_value.Value), min_value.Value);

    // Log the result
    Elog.Info($"DEBUG: FUNCTION clamp_value_plfsharp - Clamped value = {clampedValue}.");

    clampedValue
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plfsharp-float4', 'clampValueLessThanMinimum', 
       plfsharp_clamp_value(2.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plfsharp-float4', 'clampValueWithinRange', 
       plfsharp_clamp_value(4.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 4.5::FLOAT4;
```

#### plfsharp_combine_second_third_power✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_combine_second_third_power(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
/*
 name: combine_second_third_power
 description: Combines the second power of the first float4 input with the third power of the second float4 input by adding them together.
 type: float4
 input: The first float4 input for which the second power is calculated
 input: The second float4 input for which the third power is calculated
 output: The result of adding the second power of input1 and the third power of input2, returned as float4
*/

DECLARE
    result FLOAT4;
BEGIN
    result := POWER(input1, 2) + POWER(input2, 3);
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'combineSecondThirdPowerPositive', plfsharp_combine_second_third_power(4.0::FLOAT4, 2.0::FLOAT4) = 24.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'combineSecondThirdPowerMixed', plfsharp_combine_second_third_power(-1.5::FLOAT4, 3.0::FLOAT4)::FLOAT4 = 26.25::FLOAT4;
```

#### plfsharp_compare_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_compare_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
// name: compare_float4_values
// description: Compares two float4 values and determines if the first is greater than the second.
// type: float4
// input: First float4 value for comparison
// input: Second float4 value for comparison
// output: Boolean represented as float4 (1.0 for true, 0.0 for false)

    Elog.Info("compare_float4_values function called with value1 = " + value1.ToString() + ", value2 = " + value2.ToString())
    let result = if value1.Value > value2.Value then 1.0F else 0.0F
    Elog.Info("Result of compare_float4_values: " + result.ToString())
    result
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'compareFloat4ValuesCase1', plfsharp_compare_float4_values(3.5::FLOAT4, 2.7::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'compareFloat4ValuesCase2', plfsharp_compare_float4_values(1.4::FLOAT4, 1.8::FLOAT4) = 0.0::FLOAT4;
```

#### plfsharp_compute_circle_area✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_compute_circle_area(radius FLOAT4) RETURNS FLOAT4 AS $$
// name: compute_circle_area
// description: This function calculates the area of a circle given the radius as a float4 type.
// type: float4
// input: The radius of the circle as a float4
// output: The area of the circle as a float4

    if radius.HasValue then
        Elog.Info("compute_circle_area function called with radius = " + radius.Value.ToString())
        let pi = 3.14159f // Using 'f' to specify a float32 literal
        let area = pi * (radius.Value * radius.Value) // Square the radius and multiply it by pi
        Elog.Info("Area of circle: " + area.ToString())
        Nullable(area) // Return the computed area
    else
        Nullable()
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'compute_circle_area_small_radius', ROUND(CAST(plfsharp_compute_circle_area(2.5::FLOAT4) AS NUMERIC), 2) = CAST(19.63 AS NUMERIC);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'compute_circle_area_large_radius', plfsharp_compute_circle_area(100.0::FLOAT4) = 31415.9::FLOAT4;
```

#### plfsharp_compute_float4_quotient_and_remainder❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_compute_float4_quotient_and_remainder(dividend float4, divisor float4) RETURNS json AS $$
// name: compute_float4_quotient_and_remainder
// description: Compute the quotient and remainder of the division of two float4 numbers
// type: float4
// input: The float4 number being divided
// input: The float4 number by which the dividend is divided
// output: A JSON object with float4 quotient and remainder

Elog.Info("compute_float4_quotient_and_remainder function called with dividend = " + dividend.ToString() + ", divisor = " + divisor.ToString())
if divisor = Nullable(0.0f) then
    Elog.Error("Division by zero error.")
    raise (NpgsqlException("Division by zero"))

let quotient = dividend.Value / divisor.Value
let remainder = dividend.Value - (quotient * divisor.Value)
let result = "{\"quotient\": \"" + quotient.ToString() + "\", \"remainder\": \"" + remainder.ToString() + "\"}"
Elog.Info("Result of compute_float4_quotient_and_remainder: " + result)
result
$$ LANGUAGE plfsharp;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'compute_float4_quotient_and_remainder_positive', plfsharp_compute_float4_quotient_and_remainder(8.75::FLOAT4, 2.50::FLOAT4) = '{"quotient": "3.5", "remainder": "1.25"}'::json;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'compute_float4_quotient_and_remainder_negative', plfsharp_compute_float4_quotient_and_remainder(-5.5::FLOAT4, 2.2::FLOAT4) = '{"quotient": "-2.5", "remainder": "-0.9"}'::json;
```

#### plfsharp_convert_float4_to_negative✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_convert_float4_to_negative(number FLOAT4) RETURNS FLOAT4 AS $$
// name: convert_float4_to_negative
// description: This function converts a float4 number to its negative equivalent.
// type: float4
// input: float4 number to be negated
// output: The negative equivalent of the input as float4

    Elog.Info("convert_float4_to_negative function called with number = " + number.ToString());
    let nonNullableNumber = if number.HasValue then number.Value else 0.0f; // Convert nullable float to non-nullable, defaulting to 0.0
    let result = if nonNullableNumber < 0.0f then nonNullableNumber else -nonNullableNumber; // Negate if positive
    Elog.Info("Result of convert_float4_to_negative: " + result.ToString());
    result
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'convertFloat4ToNegativePositiveValue', plfsharp_convert_float4_to_negative(3.5::FLOAT4) = -3.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'convertFloat4ToNegativeNegativeValue', plfsharp_convert_float4_to_negative(-2.0::FLOAT4) = -2.0::FLOAT4;
```

#### plfsharp_convert_to_radians✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_convert_to_radians(degrees FLOAT4) RETURNS FLOAT4 AS $$
// name: convert_to_radians
// description: Converts an angle in degrees to radians
// type: float4
// input: The angle in degrees to be converted to radians as float4
// output: The angle in radians as float4

    Elog.Info("convert_to_radians function called with degrees = " + degrees.ToString())
    let pi: float32 = 3.1415927f
    let radians = (degrees.Value * pi) / 180.0f
    Elog.Info("Result of convert_to_radians: " + radians.ToString())
    Nullable<float32>(radians)
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'convert_to_radians1', plfsharp_convert_to_radians(0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'convert_to_radians2', plfsharp_convert_to_radians(180.0::FLOAT4) = 3.1415927::FLOAT4;
```

#### plfsharp_float4_absolute_value_test✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_float4_absolute_value_test(number float4) RETURNS float4 AS $$
// name: float4_absolute_value_test
// description: Function to compute the absolute value of a float4 number
// type: float4
// input: A float4 value representing the number to find the absolute value for
// output: float4 absolute value of the input number

    Elog.Info("float4_absolute_value_test function called with number = " + number.ToString());
    let abs_value = if number.GetValueOrDefault() < 0.0f then -number.GetValueOrDefault() else number.GetValueOrDefault();
    Elog.Info("Result of float4_absolute_value_test: " + abs_value.ToString());
    abs_value
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'float4_absolute_value_test1', plfsharp_float4_absolute_value_test(-123.45::FLOAT4) = 123.45::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'float4_absolute_value_test2', plfsharp_float4_absolute_value_test(678.9::FLOAT4) = 678.9::FLOAT4;
```

#### plfsharp_float4_min_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_float4_min_value(number1 float4, number2 float4) RETURNS float4 AS $$
// name: float4_min_value
// description: Finds the minimum value between two float4 numbers
// type: float4
// input: First float4 number for comparison
// input: Second float4 number for comparison
// output: Returns the minimum value as float4

    Elog.Info($"float4_min_value function called with number1 = {number1.Value}, number2 = {number2.Value}")
    let min_value = if number1.HasValue && number2.HasValue then (if number1.Value < number2.Value then number1 else number2) else System.Nullable()
    Elog.Info($"Result of float4_min_value: {min_value}")
    min_value.Value
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'float4_min_value_positive_values', plfsharp_float4_min_value(3.5::FLOAT4, 7.25::FLOAT4) = 3.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'float4_min_value_neg_and_pos', plfsharp_float4_min_value(-2.0::FLOAT4, 4.75::FLOAT4) = -2.0::FLOAT4;
```

#### plfsharp_is_float4_in_decreasing_order✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_is_float4_in_decreasing_order(number1 float4, number2 float4) RETURNS bool AS $$
// name: is_float4_in_decreasing_order
// description: Determines if the provided float4 numbers are in strictly decreasing order
// type: float4
// input: First number of type float4
// input: Second number of type float4
// output: Result of type boolean, true if number1 > number2, false otherwise

    Elog.Info("is_float4_in_decreasing_order function called with number1 = " + number1.ToString() + ", number2 = " + number2.ToString())
    let num1 = if number1.HasValue then number1.Value else 0.0f
    let num2 = if number2.HasValue then number2.Value else 0.0f
    let result = num1 > num2
    Elog.Info("Result of is_float4_in_decreasing_order: " + result.ToString())
    result
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'is_float4_in_decreasing_order1', plfsharp_is_float4_in_decreasing_order(6.5::FLOAT4, 3.24::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'is_float4_in_decreasing_order2', plfsharp_is_float4_in_decreasing_order(5.5::FLOAT4, 5.5::FLOAT4) = FALSE;
```

#### plfsharp_is_float4_in_range✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_is_float4_in_range(value float4, min_value float4, max_value float4) RETURNS bool AS $$
// name: is_float4_in_range
// description: Determines if a float4 value falls within a specified inclusive range, defined by a minimum and maximum float4 value.
// type: float4
// input: The float4 value to check
// input: The inclusive minimum value of the range as float4
// input: The inclusive maximum value of the range as float4
// output: Returns true if the value is within the range, otherwise false

    Elog.Info($"is_float4_in_range function called with value = {value}, min_value = {min_value}, max_value = {max_value}")
    let nonNullableValue = if value.HasValue then value.Value else 0.0f
    let nonNullableMinValue = if min_value.HasValue then min_value.Value else 0.0f
    let nonNullableMaxValue = if max_value.HasValue then max_value.Value else 0.0f
    let result = nonNullableValue >= nonNullableMinValue && nonNullableValue <= nonNullableMaxValue
    Elog.Info($"Result of is_float4_in_range: {result}")
    result
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'is_float4_in_range1', plfsharp_is_float4_in_range(3.5::FLOAT4, 1.0::FLOAT4, 5.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'is_float4_in_range2', plfsharp_is_float4_in_range(6.5::FLOAT4, 1.0::FLOAT4, 5.0::FLOAT4) = FALSE;
```

#### plfsharp_is_float4_zero✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_is_float4_zero(number FLOAT4) RETURNS BOOL AS $$
// name: is_float4_zero
// description: Checks if the provided float4 number is zero
// type: float4
// input: the input float4 number to check
// output: returns true if number is 0.0, false otherwise

    if number = System.Nullable() then
        Elog.Info("is_float4_zero function called with null")
        false
    else
        Elog.Info(sprintf "is_float4_zero function called with number = %A" number)
        let threshold = 0.0001f // Threshold for zero comparison
        let absNumber = Math.Abs(number.Value)
        let result = absNumber <= threshold
        Elog.Info(sprintf "Result of is_float4_zero: %A" result)
        result
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'is_float4_zero_exact_zero', plfsharp_is_float4_zero(0.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'is_float4_zero_near_zero', plfsharp_is_float4_zero(0.00001::FLOAT4) = TRUE;
```

#### plfsharp_is_negative✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_is_negative(number float4) RETURNS bool AS $$
// name: is_negative
// description: Determines if a float4 value is negative
// type: float4
// input: the float4 number to check
// output: boolean indicating if the number is negative

Elog.Info("is_negative function called with number = " + number.ToString())
let result = Nullable.Compare(number, 0.0f) < 0
Elog.Info("Result of is_negative: " + result.ToString())
result
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'is_negative1', plfsharp_is_negative(-3.14::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'is_negative2', plfsharp_is_negative(6.28::FLOAT4) = FALSE;
```

#### plfsharp_normalize_float4_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_normalize_float4_value(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS FLOAT4 AS $$
DECLARE
    distance FLOAT4;
    range FLOAT4;
BEGIN
    -- name: normalize_float4_value
    -- description: Normalize a float4 number to the range of 0 to 1 based on provided minimum and maximum values
    -- type: float4
    -- input: the float4 number to normalize
    -- input: the minimum float4 value of the range
    -- input: the maximum float4 value of the range
    -- output: the normalized float4 number

    IF min_value IS NULL OR max_value IS NULL THEN
        RAISE EXCEPTION 'min_value and max_value cannot be null';
    END IF;

    IF min_value >= max_value THEN
        RAISE EXCEPTION 'min_value must be less than max_value';
    END IF;
    
    -- Coalesce function will handle potential nulls
    value := COALESCE(value, 0.0);
    min_value := COALESCE(min_value, 0.0);
    max_value := COALESCE(max_value, 0.0);

    distance := value - min_value;
    range := max_value - min_value;
    
    -- Prevent division by zero
    IF range = 0.0 THEN
        RETURN 0.0;
    ELSE
        RETURN distance / range;
    END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'normalize_float4_value_within_range', plfsharp_normalize_float4_value(10.0::FLOAT4, 0.0::FLOAT4, 20.0::FLOAT4) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'normalize_float4_value_at_top_of_range', plfsharp_normalize_float4_value(20.0::FLOAT4, 10.0::FLOAT4, 20.0::FLOAT4) = 1.0::FLOAT4;
```

#### plfsharp_subtract_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_subtract_float4_values(value1 float4, value2 float4) RETURNS float4 AS $$
// name: subtract_float4_values
// description: Subtracts the second float4 value from the first and returns the result as float4
// type: float4
// input: First float4 value to be used in subtraction
// input: Second float4 value to subtract from the first value
// output: Result of subtraction as float4

    Elog.Info($"DEBUG: FUNCTION plfsharp_subtract_float4_values - Running plfsharp_subtract_float4_values function with inputs 'value1' = {value1}, 'value2' = {value2}.");
    let result = value1.Value - value2.Value
    Elog.Info($"DEBUG: FUNCTION plfsharp_subtract_float4_values - Function plfsharp_subtract_float4_values is returning 'result' = {result}.");
    result
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_subtractFloat4ValuesPositive', ROUND(plfsharp_subtract_float4_values(5.7::FLOAT4, 2.3::FLOAT4)::NUMERIC, 1) = ROUND(3.4::NUMERIC, 1);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_subtractFloat4ValuesNegFromPos', plfsharp_subtract_float4_values(-1.2::FLOAT4, 4.6::FLOAT4) = -5.8::FLOAT4;
```

#### plfsharp_test_float4_truncation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_test_float4_truncation(number FLOAT4) RETURNS FLOAT4 AS $$
// name: test_float4_truncation
// description: Truncates a float4 number, removing its decimal part.
// type: float4
// input: A float4 number to be truncated
// output: The truncated float4 number

    Elog.Info("test_float4_truncation function called with number = " + number.ToString())
    // Truncate the float4 number using casting to int and then back to float.
    let result = float32(int32 number.Value)
    Elog.Info("Result of test_float4_truncation: " + result.ToString())
    Nullable(result)
$$ LANGUAGE plfsharp;
-- Test case: Truncating a positive float4 number
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_float4_truncation1', plfsharp_test_float4_truncation(123.456::FLOAT4) = 123.0::FLOAT4;
-- Test case: Truncating a negative float4 number
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_float4_truncation2', plfsharp_test_float4_truncation(-123.456::FLOAT4) = -123.0::FLOAT4;
```

#### plfsharp_test_increment_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_test_increment_float4(number FLOAT4, increment FLOAT4) RETURNS FLOAT4 AS $$
// name: test_increment_float4
// description: This function increments a float4 value by a float4 increment and returns the result as float4.
// type: float4
// input: The float4 number to be incremented
// input: The float4 value to increment the number by
// output: The incremented float4 value

    Elog.Info("test_increment_float4 function called with number = " + number.ToString() + ", increment = " + increment.ToString())
    let num = if number.HasValue then number.Value else 0.0f
    let incr = if increment.HasValue then increment.Value else 0.0f
    let result = num + incr
    Elog.Info("Result of test_increment_float4: " + result.ToString())
    result
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_increment_float41', plfsharp_test_increment_float4(8.25::FLOAT4, 1.75::FLOAT4) = 10.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_increment_float42', plfsharp_test_increment_float4(-3.5::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;
```

#### plfsharp_test_maximum_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_test_maximum_value(input1 float4, input2 float4) RETURNS float4 AS $$
// name: test_maximum_value
// description: Function to determine the maximum of two float4 values
// type: float4
// input: First float4 value to compare
// input: Second float4 value to compare
// output: Returns the maximum of the two float4 inputs

    if input1.HasValue && input2.HasValue then
        Elog.Info("test_maximum_value function called with input1 = " + input1.Value.ToString() + ", input2 = " + input2.Value.ToString())
        let result = if input1.Value >= input2.Value then input1 else input2
        Elog.Info("Result of test_maximum_value: " + result.Value.ToString())
        result
    else
        Nullable()
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_maximum_value_first_greater', plfsharp_test_maximum_value(12.34::FLOAT4, 9.87::FLOAT4) = 12.34::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'test_maximum_value_second_greater', plfsharp_test_maximum_value(-3.21::FLOAT4, 4.56::FLOAT4) = 4.56::FLOAT4;
```

#### plfsharp_validate_float4_within_range✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plfsharp_validate_float4_within_range(number float4, range_min float4, range_max float4) RETURNS float4 AS $$
// name: validate_float4_within_range
// description: validate whether the float4 number falls within the exclusive range (min, max)
// type: float4
// input: the float4 number to validate
// input: the minimum float4 boundary of the range
// input: the maximum float4 boundary of the range
// output: boolean represented as float4 (1.0 for true, 0.0 for false)

    Elog.Info($"DEBUG: FUNCTION validate_float4_within_range_plfsharp-1 - Running validate_float4_within_range_plfsharp function with inputs 'number' = {number}, 'range_min' = {range_min}, 'range_max' = {range_max}.");
    let result =
        if number.HasValue && range_min.HasValue && range_max.HasValue && number.Value > range_min.Value && number.Value < range_max.Value then 1.0f
        else 0.0f
    Elog.Info($"DEBUG: FUNCTION validate_float4_within_range_plfsharp-2 - Function validate_float4_within_range_plfsharp is returning 'result' = {result}.");
    result
$$ LANGUAGE plfsharp;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'validateFloat4WithinRange1', plfsharp_validate_float4_within_range(5.5::FLOAT4, 5.0::FLOAT4, 6.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plfsharp-float4', 'validateFloat4WithinRange2', plfsharp_validate_float4_within_range(4.0::FLOAT4, 5.0::FLOAT4, 6.0::FLOAT4) = 0.0::FLOAT4;
```

### pllua

#### pllua_add_float4_values❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_add_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: add_float4_values
-- description: Function that adds two float4 values and returns the result as float4
-- type: float4
-- input: float4 value to be added to value2
-- input: float4 value to be added to value1
-- output: Sum of value1 and value2 as float4

    pllua.info("add_float4_values function called with value1 = " .. (value1 or "nil") .. ", value2 = " .. (value2 or "nil"))
    local result = value1 + value2
    pllua.info("Result of add_float4_values: " .. result)
    return result
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'add_float4_valuesPositiveNumbers', pllua_add_float4_values(1.5::FLOAT4, 2.5::FLOAT4) = 4.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'add_float4_valuesPosAndNegNumbers', pllua_add_float4_values(-1.25::FLOAT4, 3.75::FLOAT4) = 2.5::FLOAT4;
```

#### pllua_average_of_float4_values❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_average_of_float4_values(value1 float4, value2 float4) RETURNS float4 AS $$
-- name: average_of_float4_values
-- description: Calculates the average of two float4 values
-- type: float4
-- input: First float4 value
-- input: Second float4 value
-- output: The average value as float4

    pllua.info("average_of_float4_values function called with value1 = " .. tostring(value1) .. ", value2 = " .. tostring(value2))
    local sum = value1 + value2
    local average = sum / 2
    pllua.info("Result of average_of_float4_values: " .. tostring(average))
    return average
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'average_of_float4_valuesPositive', pllua_average_of_float4_values(4.0::FLOAT4, 8.0::FLOAT4) = 6.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'average_of_float4_valuesNegative', pllua_average_of_float4_values(-2.5::FLOAT4, -7.5::FLOAT4) = -5.0::FLOAT4;
```

#### pllua_calculate_arccosine✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_arccosine(value FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_arccosine
-- description: Calculates the arccosine (inverse cosine) of a float4 value
-- type: float4
-- input: A float4 representing the cosine of an angle, range -1 to 1
-- output: The arccosine of the input value as float4 in radians

    -- Debugging: Print input value
    -- pllua.info("calculate_arccosine function called with value = " .. (value or "nil"))

    -- Input validation: Check if value is within range [-1, 1]
    if value < -1 or value > 1 then
        error("Input value must be in the range of -1 to 1 inclusive.")
    end

    -- Calculation: Compute the arccosine of value
    local result = math.acos(value)

    -- Debugging: Print the result
    -- pllua.info(string.format("Result of calculate_arccosine: %.4f", result))

    -- Ensure the result is returned as float4 with correct precision
    return tonumber(string.format("%.4f", result))
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_arccosine_zero', pllua_calculate_arccosine(0::FLOAT4) BETWEEN 1.5707 AND 1.5709;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_arccosine_one', pllua_calculate_arccosine(1::FLOAT4) = 0::FLOAT4;

-- calculate_float4_logarithm_base2
```

#### pllua_calculate_area_of_rectangle❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_area_of_rectangle(width FLOAT4, height FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_area_of_rectangle
-- description: This function calculates the area of a rectangle given the width and height as float4 types and returns the area as float4
-- type: float4
-- input: float4 type representing the width of the rectangle
-- input: float4 type representing the height of the rectangle
-- output: float4 type representing the area of the rectangle

    pllua.notice("pllua_calculate_area_of_rectangle function called with width = " .. tostring(width) .. ", height = " .. tostring(height))
    local area = width * height
    pllua.notice("Result of pllua_calculate_area_of_rectangle: " .. tostring(area))
    return area
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculate_area_of_rectangle1', pllua_calculate_area_of_rectangle(4.0::FLOAT4, 3.0::FLOAT4) = 12.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculate_area_of_rectangle2', pllua_calculate_area_of_rectangle(0.0::FLOAT4, 5.0::FLOAT4) = 0.0::FLOAT4;
```

#### pllua_calculate_arithmetic_mean❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_arithmetic_mean(value1 float4, value2 float4) RETURNS float4 AS $$
-- name: calculate_arithmetic_mean
-- description: Calculates arithmetic mean of two float4 values
-- type: float4
-- input: First float4 input value.
-- input: Second float4 input value.
-- output: Arithmetic mean result as float4.

    pllua.info("calculate_arithmetic_mean function called with value1 = " .. tostring(value1) .. ", value2 = " .. tostring(value2))
    local total = value1 + value2
    local count = 2
    local result = total / count
    pllua.info("Result of calculate_arithmetic_mean: " .. result)
    return result
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_arithmetic_mean1', pllua_calculate_arithmetic_mean(3.5::float4, 2.5::float4) = 3.0::float4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_arithmetic_mean2', pllua_calculate_arithmetic_mean(5.0::float4, -3.0::float4) = 1.0::float4;
```

#### pllua_calculate_arithmetic_progression_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_arithmetic_progression_sum(a float4, d float4, n float4) RETURNS float4 AS $$
-- name: calculate_arithmetic_progression_sum
-- description: Calculate the sum of the first n terms of an arithmetic progression, given the first term (a), the common difference (d), and the number of terms (n), returning the sum as float4.
-- type: float4
-- input: the first term of the arithmetic progression (float4)
-- input: the common difference between the terms (float4)
-- input: the number of terms to sum (float4)
-- output: the sum of the first n terms of the arithmetic progression (float4)

    print("calculate_arithmetic_progression_sum function called with a = " .. tostring(a) .. ", d = " .. tostring(d) .. ", n = " .. tostring(n))
    local term_n_minus_1 = n - 1
    local sum_n = (n * a) + (d * term_n_minus_1 * n) / 2
    print("Result of calculate_arithmetic_progression_sum: " .. sum_n)
    return sum_n
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateArithmeticProgressionSum1', pllua_calculate_arithmetic_progression_sum(2.0::FLOAT4, 2.0::FLOAT4, 5.0::FLOAT4) = 30.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateArithmeticProgressionSum2', pllua_calculate_arithmetic_progression_sum(1.5::FLOAT4, 1.5::FLOAT4, 3.0::FLOAT4) = 9.0::FLOAT4;

-- calculate_float4_ratio
```

#### pllua_calculate_ceil✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_ceil(number float4) RETURNS float4 AS $$
    local result = math.ceil(number)
    return result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculateCeilNegativeFloat', pllua_calculate_ceil(-1.78::FLOAT4) = -1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculateCeilPositiveFloat', pllua_calculate_ceil(3.45::FLOAT4) = 4.0::FLOAT4;

-- calculate_linear_intercept
```

#### pllua_calculate_circumference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_circumference(radius FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_circumference
-- description: Calculates the circumference of a circle given the radius as float4
-- type: float4
-- input: The radius of the circle as float4
-- output: The circumference of the circle as float4

    local PI = 3.1415926535 -- Define constant PI
    local diameter = radius * 2 -- Calculate the diameter
    local circumference = diameter * PI -- Calculate the circumference
    return circumference
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculate_circumference_small_radius', pllua_calculate_circumference(2.0::FLOAT4) = 12.566370614::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculate_circumference_large_radius', pllua_calculate_circumference(100.0::FLOAT4) = 628.3185307179584::FLOAT4;

-- calculate_float4_quotient_and_product
```

#### pllua_calculate_decibel_level❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_decibel_level(sound_pressure FLOAT4, reference_pressure FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_decibel_level
-- description: Calculates the decibel level of a sound by comparing it to a reference sound pressure level.
-- type: float4
-- input: The sound pressure of the sound for which to determine the decibel level, as float4.
-- input: The reference sound pressure which is typically the threshold of human hearing, as float4.
-- output: The decibel level of the sound compared to the reference sound pressure, as float4.

    pllua.info("calculate_decibel_level function called with sound_pressure = " .. tostring(sound_pressure) .. ", reference_pressure = " .. tostring(reference_pressure))
    assert(sound_pressure > 0 and reference_pressure > 0, "Sound pressure and reference pressure must be positive numbers.")

    local ratio = sound_pressure / reference_pressure
    local decibels = 20 * math.log10(ratio)

    pllua.info("Result of calculate_decibel_level: " .. decibels)
    return decibels
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_decibel_level1', pllua_calculate_decibel_level(1.0::FLOAT4, 0.00002::FLOAT4) = 94.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_decibel_level2', pllua_calculate_decibel_level(0.00002::FLOAT4, 0.00002::FLOAT4) = 0.0::FLOAT4;
```

#### pllua_calculate_distance_between_float4_points❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_distance_between_float4_points(x1 float4, y1 float4, x2 float4, y2 float4) RETURNS float4 AS $$
-- name: calculate_distance_between_float4_points
-- description: Calculates the distance between two points in 2D space using float4 for coordinates
-- type: float4
-- input: The x-coordinate of the first point as a float4
-- input: The y-coordinate of the first point as a float4
-- input: The x-coordinate of the second point as a float4
-- input: The y-coordinate of the second point as a float4
-- output: The distance between the two points as a float4

    pllua.info("calculate_distance_between_float4_points function called with x1 = " .. (x1 or "nil") .. ", y1 = " .. (y1 or "nil") .. ", x2 = " .. (x2 or "nil") .. ", y2 = " .. (y2 or "nil"))
    local delta_x = x1 - x2
    local delta_y = y1 - y2
    local square_delta_x = delta_x^2
    local square_delta_y = delta_y^2
    local sum_of_squares = square_delta_x + square_delta_y
    local distance = math.sqrt(sum_of_squares)
    pllua.info("Result of calculate_distance_between_float4_points: " .. distance)
    return distance
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateDistanceBetweenFloat4PointsSamePoints', pllua_calculate_distance_between_float4_points(0.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateDistanceBetweenFloat4PointsDifferentPoints', pllua_calculate_distance_between_float4_points(3.0::FLOAT4, 4.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4) = 5.0::FLOAT4;
```

#### pllua_calculate_euclidean_distance❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_euclidean_distance(point1 JSONB, point2 JSONB) RETURNS FLOAT4 AS $$
-- name: calculate_euclidean_distance
-- description: Calculates the Euclidean distance between two points in 3D space.
-- type: float4
-- input: First point as an object with float4 x, y, z coordinates
-- input: Second point as an object with float4 x, y, z coordinates
-- output: The Euclidean distance between the two points as float4

    local x1 = point1.x or 0.0
    local y1 = point1.y or 0.0
    local z1 = point1.z or 0.0

    local x2 = point2.x or 0.0
    local y2 = point2.y or 0.0
    local z2 = point2.z or 0.0

    pllua.info("calculate_euclidean_distance function called with point1 = {x: " .. x1 .. ", y: " .. y1 .. ", z: " .. z1 .. 
               "}, point2 = {x: " .. x2 .. ", y: " .. y2 .. ", z: " .. z2 .. "}")

    local dx = x1 - x2
    local dy = y1 - y2
    local dz = z1 - z2

    local distance = math.sqrt(dx^2 + dy^2 + dz^2)

    pllua.info("Result of calculate_euclidean_distance: " .. distance)
    return distance
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateEuclideanDistance1', pllua_calculate_euclidean_distance(
--     '{"x": 1.0, "y": 2.0, "z": 3.0}', 
--     '{"x": 4.0, "y": 5.0, "z": 6.0}'
-- ) = 5.1962::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateEuclideanDistance2', pllua_calculate_euclidean_distance(
--     '{"x": 7.0, "y": 8.0, "z": 9.0}', 
--     '{"x": 7.0, "y": 8.0, "z": 9.0}'
-- ) = 0.0::FLOAT4;
```

#### pllua_calculate_exponential_growth❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_exponential_growth(initial_value float, growth_rate float, time_period float) RETURNS float AS $$
-- name: calculate_exponential_growth
-- description: This function calculates the exponential growth based on initial value, growth rate, and time.
-- type: float4
-- input: Initial quantity as float4
-- input: Growth rate (in percentage) as float4
-- input: Time period over which to calculate as float4
-- output: Returns the amount after growth as float4

    local debug_message = string.format("calculate_exponential_growth function called with initial_value = %f, growth_rate = %f, time_period = %f", initial_value, growth_rate, time_period)
    pllua.info(debug_message)

    -- Instruction 1: Convert the growth rate percentage to a decimal by dividing by 100.
    local growth_rate_decimal = growth_rate / 100

    -- Instruction 2: Calculate the growth factor by adding 1 to the growth rate decimal.
    local growth_factor = 1 + growth_rate_decimal

    -- Instruction 3: Raise the growth factor to the power of the time period.
    local power_result = math.pow(growth_factor, time_period)

    -- Instruction 4: Multiply the initial quantity by the result to get the final amount after exponential growth.
    local final_amount = initial_value * power_result

    -- Instruction 5: Return the final amount rounded to the nearest float4 precision.
    local rounded_amount = tonumber(string.format("%.4f", final_amount))

    pllua.info("Result of calculate_exponential_growth: " .. rounded_amount)
    return rounded_amount
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_exponential_growth_10_year', pllua_calculate_exponential_growth(100.0::FLOAT4, 5.0::FLOAT4, 10.0::FLOAT4) = 162.889::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_exponential_growth_5_year', pllua_calculate_exponential_growth(1000.0::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 1159.274::FLOAT4;
```

#### pllua_calculate_float4_as_percentage_of_another✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_as_percentage_of_another(value FLOAT4, total FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_as_percentage_of_another
-- description: Calculates one float4 value as a percentage of another float4 value.
-- type: float4
-- input: The float4 number to calculate the percentage for
-- input: The float4 number representing the total or 100%
-- output: The percentage of 'value' relative to 'total' as float4

    pllua.info("calculate_float4_as_percentage_of_another called with value = " .. tostring(value) .. ", total = " .. tostring(total))
    if total == 0 then
        error('Total must not be zero.')
    end
    local percentage = (value / total) * 100
    pllua.info("Resulting percentage: " .. tostring(percentage))
    return percentage
$$ LANGUAGE pllua;
-- Test case 2: Calculating a fractional percentage
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_as_percentage_of_another2', pllua_calculate_float4_as_percentage_of_another(1.0::FLOAT4, 200.0::FLOAT4) = 0.5::FLOAT4;
-- -- Test case 1: Calculating a known percentage
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_as_percentage_of_another1', pllua_calculate_float4_as_percentage_of_another(25.0::FLOAT4, 50.0::FLOAT4) = 50.0::FLOAT4;

-- calculate_arccosine
```

#### pllua_calculate_float4_ceil✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_ceil(value FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_ceil
-- description: Function to calculate the smallest integer greater than or equal to the given float4 number
-- type: float4
-- input: float4 value to find the ceiling value for
-- output: float4 representing the smallest integer greater than or equal to the input

    return math.ceil(value)
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateFloat4CeilPositive', pllua_calculate_float4_ceil(3.45::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateFloat4CeilNegative', pllua_calculate_float4_ceil(-2.8::FLOAT4) = -2.0::FLOAT4;

-- calculate_float4_precision
```

#### pllua_calculate_float4_complement✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_complement(number FLOAT4) RETURNS FLOAT4 AS $$
    local complement = 1.0 - number
    return complement
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_complement_greater_than_1', pllua_calculate_float4_complement(1.25::FLOAT4) = -0.25::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_complement_less_than_1', pllua_calculate_float4_complement(0.25::FLOAT4) = 0.75::FLOAT4;

-- calculate_sin
```

#### pllua_calculate_float4_division✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_division(dividend FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_division
-- description: This function takes two float4 values and divides the first by the second, returning a float4.
-- type: float4
-- input: The float4 number to be divided
-- input: The float4 number to divide by
-- output: The result of the division as a float4

    -- pllua.info("calculate_float4_division function called with dividend = " .. tostring(dividend) .. ", divisor = " .. tostring(divisor))
    if divisor == 0 then
        error("Division by zero is not allowed")
    end
    local result = dividend / divisor
    -- pllua.info("Result of calculate_float4_division: " .. result)
    return result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculate_float4_division_2', pllua_calculate_float4_division(3.3::FLOAT4, 4.4::FLOAT4) = 0.75;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculate_float4_division_1', pllua_calculate_float4_division(10.5::FLOAT4, 2.5::FLOAT4) = 4.2::FLOAT4;

-- calculate_euclidean_distance
```

#### pllua_calculate_float4_dot_product❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_dot_product(vector1_x FLOAT4, vector1_y FLOAT4, vector2_x FLOAT4, vector2_y FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_dot_product
-- description: Calculates the dot product of two 2D vectors, each vector component is a float4 type
-- type: float4
-- input: x component of the first vector (float4)
-- input: y component of the first vector (float4)
-- input: x component of the second vector (float4)
-- input: y component of the second vector (float4)
-- output: dot product of the two vectors (float4)

    pllua.info("calculate_float4_dot_product function called with vector1_x = " .. (vector1_x or "nil") .. ", vector1_y = " .. (vector1_y or "nil") .. ", vector2_x = " .. (vector2_x or "nil") .. ", vector2_y = " .. (vector2_y or "nil"))
    local dot_product = (vector1_x * vector2_x) + (vector1_y * vector2_y)
    pllua.info("Result of calculate_float4_dot_product: " .. dot_product)
    return dot_product
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculate_float4_dot_product_perpendicular', pllua_calculate_float4_dot_product(1.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 1.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculate_float4_dot_product_parallel', pllua_calculate_float4_dot_product(1.0::FLOAT4, 1.0::FLOAT4, 2.0::FLOAT4, 2.0::FLOAT4) = 4.0::FLOAT4;
```

#### pllua_calculate_float4_exponentiation❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_exponentiation(base FLOAT4, exponent FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_exponentiation
-- description: Calculates the base raised to the power of exponent, both of float4 type, and returns float4
-- type: float4
-- input: float4 number to be raised to the power of the exponent
-- input: float4 number representing the power
-- output: float4 result of the exponentiation

    pllua.info("calculate_float4_exponentiation function called with base = " .. (base or "nil") .. ", exponent = " .. (exponent or "nil"))
    if exponent == 0 then
        pllua.info("Exponent is 0, returning 1.")
        return 1
    end
    if base == 0 then
        pllua.info("Base is 0, returning 0.")
        return 0
    end
    local result = base ^ exponent
    result = tonumber(string.format("%.4f", result))  -- Ensure the result is formatted as FLOAT4
    pllua.info("Result of calculate_float4_exponentiation: " .. result)
    return result
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_exponentiation_positive_base_and_exponent', pllua_calculate_float4_exponentiation(2.5, 3.0) = 15.625::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_exponentiation_negative_base_and_positive_exponent', pllua_calculate_float4_exponentiation(-3.0, 2.0) = 9.0::FLOAT4;
```

#### pllua_calculate_float4_exponentiation_remainder❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_exponentiation_remainder(base FLOAT4, exponent INTEGER, divisor FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_exponentiation_remainder
-- description: Calculates the remainder of the exponentiation of a float4 base raised to an integer exponent when divided by a float4 divisor.
-- type: float4
-- input: the base value as float4
-- input: the exponent value as integer
-- input: the divisor value as float4
-- output: the remainder as float4

    -- Debugging output
    pllua.info("calculate_float4_exponentiation_remainder function called with base = " .. base .. ", exponent = " .. exponent .. ", divisor = " .. divisor)

    -- Convert integer exponent to float4 prior to exponentiation when necessary
    local exp_as_float = exponent
    if exponent < 0 then
        exp_as_float = 0
    end

    -- Calculate exponentiation
    local exponentiation_result = math.pow(base, exp_as_float)

    -- Calculate remainder
    local result = exponentiation_result % divisor

    -- Debugging output
    pllua.info("Result of calculate_float4_exponentiation_remainder: " .. result)
    
    -- Return result
    return result
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateFloat4ExponentiationRemainder1', pllua_calculate_float4_exponentiation_remainder(2.5::FLOAT4, 3, 3.2::FLOAT4) = 0.9::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateFloat4ExponentiationRemainder2', pllua_calculate_float4_exponentiation_remainder(5.1::FLOAT4, -2, 2.0::FLOAT4) = 1.1::FLOAT4;
```

#### pllua_calculate_float4_factorial❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_factorial(number float4) RETURNS float4 AS $$
-- name: calculate_float4_factorial
-- description: Calculates the factorial of a non-negative float4 number, rounding down to the nearest whole value before computation.
-- type: float4
-- input: A non-negative float4 number to calculate the factorial of
-- output: The factorial of the input number as float4, or 'undefined' if input is negative

    pllua.info("calculate_float4_factorial function called with number = " .. (number or "nil"))
    local rounded_number = math.floor(number)
    if rounded_number < 0 then
        pllua.info("Result of calculate_float4_factorial: undefined (input is negative)")
        return 'undefined'
    end
    if rounded_number == 0 or rounded_number == 1 then
        pllua.info("Result of calculate_float4_factorial: 1.0 (input is 0 or 1)")
        return 1.0
    end
    local result = 1.0
    for i = 2, rounded_number do
        result = result * i
    end
    pllua.info("Result of calculate_float4_factorial: " .. result)
    return result
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_factorial1', pllua_calculate_float4_factorial(0.85::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_factorial2', pllua_calculate_float4_factorial(5.75::FLOAT4) = 120.0::FLOAT4;
```

#### pllua_calculate_float4_geometric_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_geometric_mean(value1 float4, value2 float4) RETURNS float4 AS $$
-- name: calculate_float4_geometric_mean
-- description: Calculates the geometric mean of two float4 numbers and returns the result as float4
-- type: float4
-- input: The first positive float4 value
-- input: The second positive float4 value
-- output: The geometric mean of input float4 values as float4

    -- pllua.info("calculate_float4_geometric_mean function called with value1 = " .. tostring(value1) .. ", value2 = " .. tostring(value2))

    -- Ensure that both input values are greater than zero
    assert(value1 > 0 and value2 > 0, "Input values must be greater than zero")

    -- Calculate the product of the two input values
    local product = value1 * value2

    -- Take the square root of the product
    local result = math.sqrt(product)

    -- Return the result cast to float4 just in case it's being operated on differently
    local float4_result = assert(tonumber(result), "Result cannot be cast to float4")

    -- pllua.info("Result of calculate_float4_geometric_mean: " .. float4_result)
    return float4_result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_geometric_mean2', pllua_calculate_float4_geometric_mean(1.0::FLOAT4, 10000.0::FLOAT4) = 100.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_geometric_mean1', pllua_calculate_float4_geometric_mean(1.0::FLOAT4, 4.0::FLOAT4) = 2.0::FLOAT4;

-- calculate_area_of_rectangle
```

#### pllua_calculate_float4_inverse✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_inverse(numeric_value FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_inverse
-- description: Calculates the multiplicative inverse (or reciprocal) of a non-zero float4 number
-- type: float4
-- input: The float4 number to invert
-- output: The multiplicative inverse of the input as float4, or NULL if the input is zero

    -- pllua.info("calculate_float4_inverse function called with numeric_value = " .. (numeric_value or "nil"))
    if numeric_value == nil or numeric_value == 0 then
        -- pllua.info("Returning NULL for the reciprocal of zero")
        return NULL
    else
        local reciprocal = 1 / numeric_value
        -- pllua.info("Result of calculate_float4_inverse: " .. reciprocal)
        return reciprocal
    end
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculateFloat4Inverse2', (pllua_calculate_float4_inverse(0.0::FLOAT4) IS NULL);
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculateFloat4Inverse1', pllua_calculate_float4_inverse(2.0::FLOAT4) = 0.5::FLOAT4;

-- calculate_linear_interpolation
```

#### pllua_calculate_float4_inverse_ratio❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_inverse_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_inverse_ratio
-- description: Calculates the inverse ratio of two float4 numbers, returns the result as float4.
-- type: float4
-- input: First float4 value, acting as the numerator
-- input: Second float4 value, acting as the denominator, expected not to be zero
-- output: The inverse ratio of the two float4 input values

    pllua.info("calculate_float4_inverse_ratio function called with numerator = " .. tostring(numerator) .. ", denominator = " .. tostring(denominator))
    if denominator == 0 then
        pllua.error("Denominator cannot be zero")
    end
    local reciprocal = 1 / denominator
    local inverse_ratio = reciprocal * numerator
    pllua.info("Result of calculate_float4_inverse_ratio: " .. inverse_ratio)
    return inverse_ratio
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_inverse_ratioPositiveValues', pllua_calculate_float4_inverse_ratio(2.0::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_inverse_ratioZeroNumerator', pllua_calculate_float4_inverse_ratio(0.0::FLOAT4, 3.0::FLOAT4) = 0.0::FLOAT4;
```

#### pllua_calculate_float4_inverse_square_root✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_inverse_square_root(number FLOAT4) RETURNS FLOAT4 AS $$
    local result = 1 / math.sqrt(number)
    return result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_inverse_square_root_positive', pllua_calculate_float4_inverse_square_root(4.0) = 0.5;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_inverse_square_root_small_positive', pllua_calculate_float4_inverse_square_root(0.25::FLOAT4) = 2.0::FLOAT4;

-- calculate_float4_as_percentage_of_another
```

#### pllua_calculate_float4_linear_intercept❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_linear_intercept(x1 float4, y1 float4, x2 float4, y2 float4) RETURNS float4 AS $$
-- name: calculate_float4_linear_intercept
-- description: Calculates the y-intercept of a line (b) given two points with float4 coordinates (x1, y1) and (x2, y2). The formula used is b = y1 - (slope * x1), where slope is the (y2 - y1) / (x2 - x1).
-- type: float4
-- input: The x-coordinate of the first point as float4
-- input: The y-coordinate of the first point as float4
-- input: The x-coordinate of the second point as float4
-- input: The y-coordinate of the second point as float4
-- output: The y-intercept (b) of the line as float4

    if x2 == x1 then
        error('Division by zero: x2 cannot be equal to x1')
    end
    pllua.info("calculate_float4_linear_intercept called with x1 = " .. x1 .. ", y1 = " .. y1 .. ", x2 = " .. x2 .. ", y2 = " .. y2)
    local slope = (y2 - y1) / (x2 - x1)
    local y_intercept = y1 - slope * x1
    pllua.info("Result of calculate_float4_linear_intercept: " .. y_intercept)
    return y_intercept
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateFloat4LinearIntercept1', pllua_calculate_float4_linear_intercept(2.0::float4, 3.0::float4, 4.0::float4, 7.0::float4) = 1.0::float4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateFloat4LinearIntercept2', pllua_calculate_float4_linear_intercept(5.0::float4, 8.0::float4, 3.0::float4, 4.0::float4) = 12.0::float4;
```

#### pllua_calculate_float4_logarithm_base2✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_logarithm_base2(value FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_logarithm_base2
-- description: Calculates the base-2 logarithm of a given float4 number and returns the result as float4.
-- type: float4
-- input: The float4 number for which to calculate the base-2 logarithm
-- output: The base-2 logarithm of the input float4 number

    if value <= 0 then
        error('Input value must be positive for logarithm calculation.')
    end
    pllua.debug("calculate_float4_logarithm_base2 function called with value = " .. value)
    local result = math.log(value) / math.log(2)
    pllua.debug("Result of calculate_float4_logarithm_base2: " .. result)
    return result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_logarithm_base22', pllua_calculate_float4_logarithm_base2(2.0::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_logarithm_base21', pllua_calculate_float4_logarithm_base2(8.0::FLOAT4) = 3.0::FLOAT4;

-- compute_square_root
```

#### pllua_calculate_float4_max_absolute_difference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_max_absolute_difference(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_max_absolute_difference
-- description: This function calculates the maximum absolute difference between two float4 values
-- type: float4
-- input: The first float4 input value
-- input: The second float4 input value
-- output: The maximum absolute difference as float4

    local abs_diff1 = math.abs(input1 - input2)
    local abs_diff2 = math.abs(input2 - input1)
    local result = math.max(abs_diff1, abs_diff2)
    return result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_max_absolute_difference2', ROUND(CAST(pllua_calculate_float4_max_absolute_difference(2.2::FLOAT4, 4.8::FLOAT4) AS NUMERIC), 1) = 2.6;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_max_absolute_difference1', pllua_calculate_float4_max_absolute_difference(5.5::FLOAT4, 3.0::FLOAT4) = 2.5::FLOAT4;

-- calculate_product_of_float4
```

#### pllua_calculate_float4_modulo❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_modulo(dividend FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_modulo
-- description: Calculates the modulo (the remainder of division) of two float4 values and returns the result as float4
-- type: float4
-- input: The number that is to be divided (dividend) as float4
-- input: The number by which the dividend is to be divided (divisor) as float4
-- output: The remainder of the division of the two float4 inputs

    if divisor == 0 then
        error('The divisor cannot be zero.')
    end
    pllua.info("calculate_float4_modulo function called with dividend = " .. tostring(dividend) .. ", divisor = " .. tostring(divisor))
    local quotient = dividend / divisor
    local result = dividend - quotient * divisor
    pllua.info("Result of calculate_float4_modulo: " .. tostring(result))
    return result
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateFloat4ModuloPositive', pllua_calculate_float4_modulo(8.75::FLOAT4, 3.5::FLOAT4) = 1.75::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateFloat4ModuloNegativeDividend', pllua_calculate_float4_modulo(-5.25::FLOAT4, 2.0::FLOAT4) = -1.25::FLOAT4;
```

#### pllua_calculate_float4_percentage_change❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_percentage_change(old_value FLOAT4, new_value FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_percentage_change
-- description: Calculates the percentage change from float4 old_value to float4 new_value.
-- type: float4
-- input: The original float4 value
-- input: The new float4 value to compare against the old value
-- output: The percentage change as float4

    pllua.info("calculate_float4_percentage_change function called with old_value = " .. (old_value or "nil") .. ", new_value = " .. (new_value or "nil"))
    assert(type(old_value) == 'number' and type(new_value) == 'number', "Both old_value and new_value must be of type number.")
    assert(old_value ~= 0, "old_value must not be zero to avoid division by zero.")
    local difference = new_value - old_value
    local percentage_change = (difference / old_value) * 100
    pllua.info("Result of calculate_float4_percentage_change: " .. percentage_change)
    return percentage_change
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateFloat4PercentageChangeGreater', pllua_calculate_float4_percentage_change(50.0::FLOAT4, 75.0::FLOAT4) = 50.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateFloat4PercentageChangeLess', pllua_calculate_float4_percentage_change(75.0::FLOAT4, 50.0::FLOAT4) = -33.3333::FLOAT4;
```

#### pllua_calculate_float4_precision✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_precision(number float4) RETURNS float4 AS $$
-- name: calculate_float4_precision
-- description: Calculates the precision (number of decimal places) of a float4 number
-- type: float4
-- input: A float4 number to calculate the precision of
-- output: The precision (number of decimal places) of the number as float4

  pllua.info("calculate_float4_precision function called with number = " .. tostring(number))
  local num_str = tostring(number)
  local decimal_start, _ = string.find(num_str, "%.")
  if not decimal_start then
    return 0.0
  end
  local precision = string.len(num_str) - decimal_start
  pllua.info("Precision of number " .. num_str .. " is: " .. precision)
  return precision
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_precision_integer', pllua_calculate_float4_precision(456.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_precision_2_decimal_places', pllua_calculate_float4_precision(123.45::FLOAT4) = 2.0::FLOAT4;

-- combine_second_third_power
```

#### pllua_calculate_float4_quadratic_sum❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_quadratic_sum(num1 float4, num2 float4, num3 float4) RETURNS float4 AS $$
-- name: calculate_float4_quadratic_sum
-- description: Calculates the sum of squares of three float4 numbers and returns the result as float4.
-- type: float4
-- input: First float4 number
-- input: Second float4 number
-- input: Third float4 number
-- output: Sum of squares of num1, num2, and num3 as float4

    pllua.info("calculate_float4_quadratic_sum function called with num1 = " .. (num1 or "nil") .. ", num2 = " .. (num2 or "nil")  .. ", num3 = " .. (num3 or "nil"))
    local result1 = num1 * num1
    local result2 = num2 * num2
    local result3 = num3 * num3
    local sum_of_squares = result1 + result2 + result3
    pllua.info("Result of calculate_float4_quadratic_sum: " .. sum_of_squares)
    return sum_of_squares
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_quadratic_sum1', pllua_calculate_float4_quadratic_sum(3.0::float4, 4.0::float4, 5.0::float4) = 50.0::float4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_quadratic_sum2', pllua_calculate_float4_quadratic_sum(-3.0::float4, 4.0::float4, -5.0::float4) = 50.0::float4;
```

#### pllua_calculate_float4_quotient_and_product✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_quotient_and_product(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4[] AS $$
-- name: calculate_float4_quotient_and_product
-- description: This function calculates both the quotient and the product of two float4 values and returns them as a float4 array.
-- type: float4
-- input: First float4 input value
-- input: Second float4 input value, not equal to zero
-- output: Array of float4 with the first element being the quotient and the second being the product of the inputs

    if value2 == 0 then
        error('value2 cannot be zero')
    end
    local results = {value1 / value2, value1 * value2}
    return results
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_quotient_and_product_NegByPos', (pllua_calculate_float4_quotient_and_product(-4.0::FLOAT4, 2.0::FLOAT4))[1] = -2.0::FLOAT4 AND (pllua_calculate_float4_quotient_and_product(-4.0::FLOAT4, 2.0::FLOAT4))[2] = -8.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_quotient_and_product_Positive', (pllua_calculate_float4_quotient_and_product(3.5::FLOAT4, 2.0::FLOAT4))[1] = 1.75::FLOAT4 AND (pllua_calculate_float4_quotient_and_product(3.5::FLOAT4, 2.0::FLOAT4))[2] = 7.0::FLOAT4;

-- calculate_distance_between_float4_points
```

#### pllua_calculate_float4_ratio❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_ratio(numerator float4, denominator float4) RETURNS text AS $$
-- name: calculate_float4_ratio
-- description: Calculates the ratio of two float4 numbers and returns the result as text. Ratio is the result of dividing the first float4 value by the second, provided the second is not zero.
-- type: text
-- input: The numerator for the ratio calculation. Type: float4
-- input: The denominator for the ratio calculation. Type: float4. Must not be zero.
-- output: The calculated ratio as text. If the denominator is zero, the function will return 'undefined'.

    if denominator == 0 then
        return 'undefined'
    else
        local ratio = numerator / denominator
        return tostring(ratio)
    end
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculate_float4_ratio_positive', pllua_calculate_float4_ratio(25.0::float4, 5.0::float4) = '5.0';
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculate_float4_ratio_zero_denominator', pllua_calculate_float4_ratio(10.0::FLOAT4, 0.0::FLOAT4) = 'undefined';

-- calculate_float4_exponential_decay
```

#### pllua_calculate_float4_ratio_and_sum❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_ratio_and_sum(number1 FLOAT4, number2 FLOAT4) RETURNS TABLE(ratio FLOAT4, sum FLOAT4) AS $$
-- name: calculate_float4_ratio_and_sum
-- description: Calculates the ratio of two float4 numbers and their sum
-- type: float4
-- input: First float4 number
-- input: Second float4 number, cannot be zero as it will be used as divisor
-- output: An object with the ratio and sum of the two float4 numbers

    pllua.info("calculate_float4_ratio_and_sum function called with number1 = " .. (number1 or "nil") .. ", number2 = " .. (number2 or "nil"))
    -- Check if number2 is not zero to avoid division by zero
    if number2 == 0 then
        error("Division by zero is not allowed")
    end
    -- Divide number1 by number2 to find the ratio and store it as float4
    local ratio = number1 / number2
    -- Add number1 and number2 to calculate the sum and store it as float4
    local sum = number1 + number2
    -- Debugging output
    pllua.info("Calculated ratio: " .. ratio)
    pllua.info("Calculated sum: " .. sum)
    -- Create an object with keys 'ratio' and 'sum' and assign the calculated values respectively
    return ratio, sum
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_ratio_and_sum1', (SELECT (ratio = 2.0 AND sum = 9.0) FROM pllua_calculate_float4_ratio_and_sum(6.0::FLOAT4, 3.0::FLOAT4));
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_ratio_and_sum2', (SELECT (ratio = -2.0 AND sum = -4.0) FROM pllua_calculate_float4_ratio_and_sum(-8.0::FLOAT4, 4.0::FLOAT4));
```

#### pllua_calculate_float4_remainder✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_remainder(dividend float4, divisor float4) RETURNS float4 AS $$
-- name: calculate_float4_remainder
-- description: Calculates the remainder of division between two float4 numbers
-- type: float4
-- input: float4 value representing the dividend
-- input: float4 value representing the divisor
-- output: float4 value representing the remainder of the division

    pllua.info("calculate_float4_remainder function called with dividend = " .. tostring(dividend) .. ", divisor = " .. tostring(divisor))
    if divisor == 0.0 then
        pllua.info("Divisor is zero, returning null.")
        return nil
    end
    local remainder = dividend % divisor
    pllua.info("Result of calculate_float4_remainder: " .. tostring(remainder))
    return remainder
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateFloat4RemainderDivisorZero', pllua_calculate_float4_remainder(5.0::FLOAT4, 0.0::FLOAT4) IS NULL;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateFloat4RemainderPositives', pllua_calculate_float4_remainder(5.0::FLOAT4, 2.0::FLOAT4) = 1.0::FLOAT4;

-- add_float4_values
```

#### pllua_calculate_float4_rounded_average❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_rounded_average(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_rounded_average
-- description: Calculate the average of two float4 values and round it to the nearest whole number, returning the result as a float4
-- type: float4
-- input: The first float4 value for the average calculation
-- input: The second float4 value for the average calculation
-- output: The rounded average of value1 and value2 as a float4

    pllua.info("calculate_float4_rounded_average function called with value1 = " .. value1 .. ", value2 = " .. value2)
    local sum = value1 + value2
    local average = sum / 2.0
    local rounded_average = pllua.round(average)
    pllua.info("Result of calculate_float4_rounded_average: " .. rounded_average)
    return rounded_average
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateFloat4RoundedAveragePositive', pllua_calculate_float4_rounded_average(25.4::FLOAT4, 34.6::FLOAT4) = 30.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateFloat4RoundedAverageMixed', pllua_calculate_float4_rounded_average(-14.8::FLOAT4, 20.2::FLOAT4) = 3.0::FLOAT4;
```

#### pllua_calculate_float4_to_power_of_integer❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_to_power_of_integer(float4_base float4, integer_exponent integer) RETURNS float4 AS $$
-- name: calculate_float4_to_power_of_integer
-- description: This function takes a float4 base number and an integer exponent, then raises the base to the power of the exponent returning a float4 result
-- type: float4
-- input: float4 number serving as the base for the power operation
-- input: Integer serving as the exponent for the power operation
-- output: float4 result of the base raised to the power of the exponent

    pllua.info("calculate_float4_to_power_of_integer function called with float4_base = " .. tostring(float4_base) .. ", integer_exponent = " .. tostring(integer_exponent))
    local result = float4_base ^ integer_exponent
    pllua.info("Result of calculate_float4_to_power_of_integer: " .. tostring(result))
    return result
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_to_power_of_integer_positive', pllua_calculate_float4_to_power_of_integer(2.5::FLOAT4, 3) = 15.625::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_to_power_of_integer_zero', pllua_calculate_float4_to_power_of_integer(7.0::FLOAT4, 0) = 1.0::FLOAT4;
```

#### pllua_calculate_float4_with_exponential_notation❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_float4_with_exponential_notation(number FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_with_exponential_notation
-- description: Converts a float4 number in exponential notation to a float4 number in standard decimal notation
-- type: float4
-- input: float4 number in exponential notation
-- output: float4 number in standard decimal notation

    pllua.info("calculate_float4_with_exponential_notation function called with number = " .. number)
    local converted_number = tonumber(number)
    if converted_number == nil then
        pllua.error("Invalid input for conversion. Expected a float4 in exponential notation.")
    end
    pllua.info("Result of calculate_float4_with_exponential_notation: " .. converted_number)
    return converted_number
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_with_exponential_notation_small_number', pllua_calculate_float4_with_exponential_notation(2.5e-4::FLOAT4) = 0.00025::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_float4_with_exponential_notation_large_number', pllua_calculate_float4_with_exponential_notation(3.57e+2::FLOAT4) = 357.0::FLOAT4;
```

#### pllua_calculate_harmonic_mean❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_harmonic_mean(number1 FLOAT4, number2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_harmonic_mean
-- description: Calculates the harmonic mean of two float4 numbers
-- type: float4
-- input: First float4 number
-- input: Second float4 number
-- output: Harmonic mean of the two float4 numbers as float4

    pllua.info("calculate_harmonic_mean function called with number1 = " .. (number1 or "nil") .. ", number2 = " .. (number2 or "nil"))
    if number1 == 0 or number2 == 0 then
        pllua.info("Returning 'undefined' due to a zero input.")
        return nil
    end
    local reciprocal_sum = (1 / number1) + (1 / number2)
    local result = 2 / reciprocal_sum
    pllua.info("Result of calculate_harmonic_mean: " .. result)
    return result
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_harmonic_mean_positive', pllua_calculate_harmonic_mean(4.0::FLOAT4, 8.0::FLOAT4) = 5.3333334::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_harmonic_mean_with_zero', pllua_calculate_harmonic_mean(0.0::FLOAT4, 5.0::FLOAT4) IS NULL;
```

#### pllua_calculate_hypotenuse✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_hypotenuse(a FLOAT4, b FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_hypotenuse
-- description: Calculates the length of the hypotenuse of a right-angled triangle using the Pythagorean theorem
-- type: float4
-- input: length of side a as float4
-- input: length of side b as float4
-- output: length of the hypotenuse as float4

    -- pllua.info("calculate_hypotenuse function called with a = " .. a .. ", b = " .. b)
    local a_squared = a * a
    local b_squared = b * b
    local sum = a_squared + b_squared
    local hypotenuse = math.sqrt(sum)
    -- pllua.info("Result of calculate_hypotenuse: " .. hypotenuse)
    return hypotenuse
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_hypotenuse1', pllua_calculate_hypotenuse(3.0::FLOAT4, 4.0::FLOAT4) = 5.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_hypotenuse2', pllua_calculate_hypotenuse(5.0::FLOAT4, 12.0::FLOAT4) = 13.0::FLOAT4;

-- calculate_float4_to_power_of_integer
```

#### pllua_calculate_inscribed_circle_area❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_inscribed_circle_area(side_length FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_inscribed_circle_area
-- description: Calculates the area of an inscribed circle within a square where each side is of float4 type length.
-- type: float4
-- input: The length of the side of the square of type float4
-- output: The area of the inscribed circle as float4

    pllua.info("calculate_inscribed_circle_area function called with side_length = " .. (side_length or "nil"))
    
    -- Input validation
    if side_length == nil or side_length <= 0 then
        pllua.error("Invalid input: side_length must be a positive number")
    end
    
    -- Calculate radius, radius squared, and the area
    local radius = side_length / 2
    local radius_squared = radius * radius
    local area = radius_squared * math.pi  -- Lua's math library provides PI
    
    pllua.info("Radius: " .. radius .. ", Radius Squared: " .. radius_squared .. ", Area: " .. area)
    return area
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateInscribedCircleArea1', pllua_calculate_inscribed_circle_area(2.0::FLOAT4) = 3.14159::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateInscribedCircleArea2', pllua_calculate_inscribed_circle_area(5.4::FLOAT4) = 22.90231::FLOAT4;
```

#### pllua_calculate_linear_intercept✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_linear_intercept(x1 FLOAT4, y1 FLOAT4, m FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_linear_intercept
-- description: Calculates the y-intercept (b) of a linear equation in the form y = mx + b using a point (x1, y1) and the slope (m)
-- type: float4
-- input: float4 - the x-coordinate of the point
-- input: float4 - the y-coordinate of the point
-- input: float4 - the slope of the line
-- output: float4 - the y-intercept of the line
    local result = y1 - (m * x1)
    return result
$$ LANGUAGE pllua STABLE STRICT;
-- Point on the positive x-axis and positive slope
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'pllua-float4', 'test_calculate_linear_intercept1', 
       pllua_calculate_linear_intercept(3.0::FLOAT4, 4.0::FLOAT4, 2.0::FLOAT4) = -2.0::FLOAT4;
-- Point on the negative y-axis and negative slope
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'pllua-float4', 'test_calculate_linear_intercept2', 
       pllua_calculate_linear_intercept(-1.0::FLOAT4, -3.0::FLOAT4, -2.0::FLOAT4) = -5.0::FLOAT4;

-- compute_circle_area
CREATE OR REPLACE FUNCTION pltcl_compute_circle_area(radius FLOAT4) RETURNS FLOAT4 AS $$
# name: compute_circle_area
# description: This function calculates the area of a circle given the radius as a float4 type.
# type: float4
# input: The radius of the circle as a float4
# output: The area of the circle as a float4

    if { ![info exists radius] || ![string is double -strict $radius] } {
        return -1
    }

    set pi 3.14159
    set area [expr {$pi * $radius * $radius}]

    elog NOTICE "compute_circle_area function called with radius = $radius"
    elog NOTICE "Result of compute_circle_area: $area"

    return $area
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'compute_circle_area_small_radius', pltcl_compute_circle_area(2.5::FLOAT4) = 19.63495::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'compute_circle_area_large_radius', pltcl_compute_circle_area(100.0::FLOAT4) = 31415.9::FLOAT4;
```

#### pllua_calculate_linear_interpolation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_linear_interpolation(value1 FLOAT4, value2 FLOAT4, fraction FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_linear_interpolation
-- description: Interpolates between two float4 values at a specific increment
-- type: float4
-- input: starting float4 value for interpolation
-- input: ending float4 value for interpolation
-- input: the float4 fraction representing the interpolation point between value1 and value2
-- output: interpolated float4 value

    -- Debugging: output input parameters
    -- pllua.elog(NOTICE, "calculate_linear_interpolation function called with value1 = " .. tostring(value1) .. ", value2 = " .. tostring(value2) .. ", fraction = " .. tostring(fraction))
    
    -- Ensure the fraction is between 0.0 and 1.0 inclusive
    if fraction < 0.0 or fraction > 1.0 then
        error('fraction must be between 0.0 and 1.0')
    end
    
    -- Interpolation calculation
    local diff = value2 - value1
    local result = value1 + diff * fraction
    
    -- Debugging: output result
    -- pllua.elog(NOTICE, "Interpolated value: " .. tostring(result))
    return result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateLinearInterpolation1', pllua_calculate_linear_interpolation(10.75::FLOAT4, 20.5::FLOAT4, 0.5::FLOAT4) = 15.625::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateLinearInterpolation2', pllua_calculate_linear_interpolation(-5.0::FLOAT4, 5.0::FLOAT4, 0.1::FLOAT4) = -4.0::FLOAT4;

-- check_float4_equality
```

#### pllua_calculate_log_base_n❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_log_base_n(number FLOAT4, base FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_log_base_n
-- description: Calculates the logarithm of a float4 number with a float4 custom base and returns the result as float4. Rejects a base that is less than or equal to 0, or equal to 1, and a number that is less than or equal to 0.
-- type: float4
-- input: Value to find the logarithm of. Must be greater than 0.
-- input: Base of the logarithm. Must be greater than 0 and not equal to 1.
-- output: Logarithm of the number to the base provided. If the base or number is invalid, the output is 'undefined'.

    pllua.info("calculate_log_base_n function called with number = " .. tostring(number) .. ", base = " .. tostring(base))
    if base <= 0 or base == 1 or number <= 0 then
        pllua.info("Invalid input: Returning 'undefined'")
        return 'undefined'
    end
    local result = math.log(number) / math.log(base)
    pllua.info("Result of calculate_log_base_n: " .. result)
    return result
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateLogBaseNValid', pllua_calculate_log_base_n(32.0::FLOAT4, 2.0::FLOAT4) = 5.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateLogBaseNInvalidBase', pllua_calculate_log_base_n(100.0::FLOAT4, 1.0::FLOAT4) IS NULL;
```

#### pllua_calculate_logarithm❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_logarithm(number FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_logarithm
-- description: Calculates the natural logarithm (base e) of a given float4 number and returns the result as float4. If the input is less than or equal to zero, the function will return 'undefined' since the logarithm for non-positive numbers is not defined in real numbers.
-- type: float4
-- input: The float4 number for which to find the natural logarithm
-- output: The natural logarithm of the given float4 number as float4, or 'undefined' if the input is not a positive float4

    -- Debug Message
    pllua.info("calculate_logarithm function called with number = " .. (number or "nil"))
    
    -- Variable declaration
    local result
    
    -- Check if the input float4 number is less than or equal to zero
    if number == nil or number <= 0 then
        -- If true, return 'undefined'
        pllua.info("Input is non-positive, returning 'undefined'")
        result = 'undefined'
    else
        -- If false, compute the natural logarithm of the input number
        result = math.log(number)
        -- Debug Message
        pllua.info("Result of calculate_logarithm: " .. result)
    end
    
    -- Return the result of the logarithm as float4
    return result
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_logarithm_positive', pllua_calculate_logarithm(2.7183::FLOAT4) = 1::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_logarithm_non_positive', COALESCE(pllua_calculate_logarithm(-1.0::FLOAT4) IS NULL, FALSE);
```

#### pllua_calculate_logarithm_base_ten❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_logarithm_base_ten(number FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_logarithm_base_ten
-- description: Calculates the logarithm base 10 of a float4 number and returns the result as float4. It assumes positive non-zero input.
-- type: float4
-- input: The float4 number to calculate the logarithm base 10 of
-- output: The float4 result of the logarithm base 10 calculation

    if number <= 0 then
        error('calculate_logarithm_base_ten function called with non-positive number')
    end
    pllua.info("calculate_logarithm_base_ten function called with number = " .. number)
    local result = math.log10(number)
    pllua.info("Result of calculate_logarithm_base_ten: " .. result)
    return result
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateLogarithmBaseTen1', pllua_calculate_logarithm_base_ten(100.0::FLOAT4) = 2.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateLogarithmBaseTen2', pllua_calculate_logarithm_base_ten(1000.0::FLOAT4) = 3.0::FLOAT4;
```

#### pllua_calculate_median_of_two_float4❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_median_of_two_float4(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_median_of_two_float4
-- description: Calculates the median of two float4 numbers and returns the result as float4
-- type: float4
-- input: First float4 input value
-- input: Second float4 input value
-- output: Median of input1 and input2 as float4

    pllua.info("calculate_median_of_two_float4 function called with input1 = " .. (input1 or "nil") .. ", input2 = " .. (input2 or "nil"))
    local median = 0
    if input1 == input2 then
        median = input1
    else
        median = (input1 + input2) / 2
    end
    pllua.info("Result of calculate_median_of_two_float4: " .. median)
    return median
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_median_of_two_float4_1', pllua_calculate_median_of_two_float4(10.0::FLOAT4, 10.0::FLOAT4) = 10.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_median_of_two_float4_2', pllua_calculate_median_of_two_float4(10.0::FLOAT4, 20.0::FLOAT4) = 15.0::FLOAT4;

-- find_nearest_multiple_float4
```

#### pllua_calculate_percentage_difference❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_percentage_difference(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_percentage_difference
-- description: Calculates the percentage difference between two float4 values
-- type: float4
-- input: First float4 value
-- input: Second float4 value
-- output: Percentage difference as float4

    pllua.info("calculate_percentage_difference function called with value1 = " .. (value1 or "nil") .. ", value2 = " .. (value2 or "nil"))
    local absolute_difference = math.abs(value1 - value2)
    local average_value = (value1 + value2) / 2
    local percentage_difference = absolute_difference / average_value * 100
    pllua.info("percentage_difference = " .. percentage_difference)
    return percentage_difference
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculate_percentage_difference_first_greater', pllua_calculate_percentage_difference(150.0::FLOAT4, 100.0::FLOAT4) = 40.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculate_percentage_difference_second_greater', pllua_calculate_percentage_difference(75.0::FLOAT4, 125.0::FLOAT4) = 50.0::FLOAT4;
```

#### pllua_calculate_product_of_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_product_of_float4(num1 float4, num2 float4) RETURNS float4 AS $$
-- name: calculate_product_of_float4
-- description: Calculates the product of two float4 numbers and returns the result as a float4
-- type: float4
-- input: The first float4 number to be multiplied
-- input: The second float4 number to be multiplied
-- output: The product of the two float4 inputs as a float4

    pllua.info("calculate_product_of_float4 function called with num1 = " .. num1 .. ", num2 = " .. num2)
    local product = num1 * num2
    pllua.info("Result of calculate_product_of_float4: " .. product)
    return product
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculate_product_of_float42', pllua_calculate_product_of_float4(-5.0::FLOAT4, 2.5::FLOAT4) = -12.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculate_product_of_float41', pllua_calculate_product_of_float4(3.14::FLOAT4, 1.59::FLOAT4) = 4.9916::FLOAT4;

-- calculate_float4_factorial
```

#### pllua_calculate_quadratic_roots❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_quadratic_roots(a float4, b float4, c float4) RETURNS float4[] AS $$
-- name: calculate_quadratic_roots
-- description: Calculates the roots of a quadratic equation ax^2 + bx + c = 0 using the quadratic formula and returns them as an array of float4
-- type: float4
-- input: float4 coefficient for x^2
-- input: float4 coefficient for x
-- input: float4 constant term
-- output: array of float4 containing the two roots

    pllua.info("calculate_quadratic_roots function called with a = " .. tostring(a) .. ", b = " .. tostring(b) .. ", c = " .. tostring(c))
    local discriminant = b^2 - 4 * a * c
    if discriminant < 0 then
        pllua.info("No real roots, Discriminant: " .. discriminant)
        return {} -- No real roots
    else
        local root1 = (-b + math.sqrt(discriminant)) / (2 * a)
        local root2 = (-b - math.sqrt(discriminant)) / (2 * a)
        pllua.info("Roots: " .. root1 .. ", " .. root2)
        return {root1, root2}
    end
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateQuadraticRootsDistinct', ARRAY[3::float4, 2::float4] = pllua_calculate_quadratic_roots(1::float4, -5::float4, 6::float4);
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculateQuadraticRootsSingle', ARRAY[2::float4] = pllua_calculate_quadratic_roots(1::float4, -4::float4, 4::float4);
```

#### pllua_calculate_scaled_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_scaled_value(value FLOAT4, factor FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_scaled_value
-- description: This function takes an input float4 value and scales it by a given float4 factor.
-- type: float4
-- input: The original float4 value to be scaled
-- input: The float4 factor by which to scale the value
-- output: The scaled float4 value

    -- Correcting the error where the 'pllua' module methods were not accessible
    if not pllua then pllua = {} end
    pllua.info = pllua.info or function(msg) end
    
    pllua.info("calculate_scaled_value function called with value = " .. tostring(value) .. ", factor = " .. tostring(factor))
    local scaled_value = value * factor
    pllua.info("Result of calculate_scaled_value: " .. scaled_value)
    return scaled_value
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_scaled_valueScalingUp', pllua_calculate_scaled_value(1.5::FLOAT4, 2.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_scaled_valueScalingDown', pllua_calculate_scaled_value(3.0::FLOAT4, 0.5::FLOAT4) = 1.5::FLOAT4;

-- calculate_float4_max_absolute_difference
```

#### pllua_calculate_sin✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_sin(angle FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_sin
-- description: Calculates the sine of a float4 angle value (in radians) and returns the result as float4
-- type: float4
-- input: float4 angle in radians for which the sine will be calculated
-- output: float4 representing the sine of the input angle

    -- pllua.info("calculate_sin function called with angle = " .. tostring(angle))
    -- Check if the input angle is in degrees; if it is, convert it to radians first
    -- For the sake of the example, let's assume the angle input is already in radians so we skip the conversion
    local sine_value = math.sin(angle)
    local result = tonumber(string.format("%.4f", sine_value)) -- Ensure float4 precision
    -- pllua.info("Result of calculate_sin: " .. result)
    return result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'pllua-float4', 'test_calculate_sin_pi_over_2', pllua_calculate_sin(CAST(PI() AS FLOAT4) / 2.0::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_calculate_sin_zero', pllua_calculate_sin(0.0::FLOAT4) = 0.0::FLOAT4;

-- check_float4_within_bounds
```

#### pllua_calculate_slope❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_slope(point1 float4[], point2 float4[]) RETURNS float4 AS $$
-- name: calculate_slope
-- description: Calculates the slope of a line passing through two points in the Cartesian coordinate system
-- type: float4
-- input: Coordinates (x1, y1) of the first point, type float4 array
-- input: Coordinates (x2, y2) of the second point, type float4 array
-- output: The slope of the line as float4

    if (type(point1) ~= 'table') or (#point1 ~= 2) or (type(point2) ~= 'table') or (#point2 ~= 2) then
        error('Invalid arguments: both point1 and point2 must be arrays of two float4 elements')
    end

    pllua.info('calculate_slope function called with point1 = {' .. table.concat(point1, ',') .. '}, point2 = {' .. table.concat(point2, ',') .. '}')

    local delta_x = point2[1] - point1[1]
    local delta_y = point2[2] - point1[2]

    if delta_x == 0 then
        pllua.info("The line is vertical, slope is undefined")
        return nil -- Undefined slope for vertical lines
    else
        local slope = delta_y / delta_x
        pllua.info("Calculated slope: " .. slope)
        return slope
    end
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_slope_non_vertical_horizontal', (pllua_calculate_slope(ARRAY[1.0, 2.0]::float4[], ARRAY[3.0, 3.0]::float4[]) = 0.5::float4) IS NOT FALSE;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_slope_vertical', (pllua_calculate_slope(ARRAY[4.0, 1.0]::float4[], ARRAY[4.0, 3.0]::float4[]) IS NULL) IS NOT FALSE;
```

#### pllua_calculate_thermal_expansion✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_thermal_expansion(original_length float4, temperature_change float4, coefficient_of_expansion float4) RETURNS float4 AS $$
-- name: calculate_thermal_expansion
-- description: Calculates the linear thermal expansion of a material given its original length, temperature change, and the material's coefficient of linear expansion
-- type: float4
-- input: the original length of the material before thermal expansion (float4)
-- input: the change in temperature that the material undergoes (float4)
-- input: the coefficient of linear expansion of the material (float4)
-- output: the new length of the material after thermal expansion (float4)

    local expansion = original_length * temperature_change * coefficient_of_expansion
    local new_length = original_length + expansion
    return new_length
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_thermal_expansion_small_temp_change', pllua_calculate_thermal_expansion(10.0, 0.0005, 0.000012)::FLOAT4 = ROUND(10.0 + (10.0 * 0.0005 * 0.000012), 5)::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_thermal_expansion_large_temp_change', pllua_calculate_thermal_expansion(5.0::FLOAT4, 50.0::FLOAT4, 0.000015::FLOAT4) = 5.00375::FLOAT4;

-- calculate_float4_dot_product
```

#### pllua_calculate_weight_force✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_calculate_weight_force(mass FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_weight_force
-- description: Calculates the force due to weight of an object using the formula F = m * g, where m is mass in kilograms, and g is acceleration due to gravity at 9.81 m/s^2 (represented as float4)
-- type: float4
-- input: mass of the object as float4
-- output: the weight force as float4

    local debug_info = "calculate_weight_force function called with mass = " .. tostring(mass)
    -- pllua.notice(debug_info)

    local acceleration_due_to_gravity = 9.81 -- Constant acceleration due to gravity

    local weight_force = mass * acceleration_due_to_gravity
    local result_info = "Result of calculate_weight_force: " .. tostring(weight_force)
    -- pllua.notice(result_info)

    return weight_force
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_weight_force_1', pllua_calculate_weight_force(2.0) = 19.62::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'calculate_weight_force_2', pllua_calculate_weight_force(5.5::FLOAT4) = 53.955::FLOAT4;
```

#### pllua_check_float4_equality✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_check_float4_equality(input1 FLOAT4, input2 FLOAT4) RETURNS BOOLEAN AS $$
-- name: check_float4_equality
-- description: Checks whether two float4 values are equal
-- type: float4
-- input: First float4 value to be compared
-- input: Second float4 value to be compared
-- output: Boolean result determining if the two float4 values are equal

    if pllua == nil then
        pllua = {}
    end
    pllua.info = function(msg)
        -- Placeholder for the actual logging mechanism, e.g., raising a notice
    end
    pllua.info("check_float4_equality function called with input1 = " .. tostring(input1) .. ", input2 = " .. tostring(input2))
    local result = (input1 == input2)
    pllua.info("Result of check_float4_equality: " .. tostring(result))
    return result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'check_float4_equality_unequal', pllua_check_float4_equality(4.0000::FLOAT4, -3.9999::FLOAT4) = FALSE;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'check_float4_equality_equal', pllua_check_float4_equality(4.0000::FLOAT4, 4.0000::FLOAT4) = TRUE;

-- compute_float4_quotient_and_remainder
```

#### pllua_check_float4_is_positive✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_check_float4_is_positive(number FLOAT4) RETURNS FLOAT4 AS $$
-- name: check_float4_is_positive
-- description: Determines if a float4 input is positive
-- type: float4
-- input: The float4 number to check
-- output: A float4 representing a boolean true or false, 1.0 for true and 0.0 for false

    pllua.info("check_float4_is_positive function called with number = " .. (number or "nil"))
    local result = number > 0.0 and 1.0 or 0.0
    pllua.info("Result of check_float4_is_positive: " .. result)
    return result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'check_float4_is_positive2', pllua_check_float4_is_positive(-0.1::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'check_float4_is_positive1', pllua_check_float4_is_positive(0.1::FLOAT4) = 1.0::FLOAT4;

-- calculate_arithmetic_mean
```

#### pllua_check_float4_within_bounds❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_check_float4_within_bounds(value float4, lower_bound float4, upper_bound float4) RETURNS float4 AS $$
-- name: check_float4_within_bounds
-- description: Determines whether a float4 value is between two boundary float4 values (exclusive)
-- type: float4
-- input: the float4 value to check
-- input: the lower float4 boundary
-- input: the upper float4 boundary
-- output: boolean represented as float4 (1.0 for true, 0.0 for false)

    pllua.info("check_float4_within_bounds function called with value = " .. tostring(value) .. ", lower_bound = " .. tostring(lower_bound) .. ", upper_bound = " .. tostring(upper_bound))
    if value > lower_bound and value < upper_bound then
        pllua.info("Result of check_float4_within_bounds: 1.0")
        return 1.0
    else
        pllua.info("Result of check_float4_within_bounds: 0.0")
        return 0.0
    end
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'checkFloat4WithinBounds1', pllua_check_float4_within_bounds(5.75::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'checkFloat4WithinBounds2', pllua_check_float4_within_bounds(-3.14::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 0.0::FLOAT4;
```

#### pllua_check_float4_within_tolerance✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_check_float4_within_tolerance(float4_num1 FLOAT4, float4_num2 FLOAT4, tolerance FLOAT4) RETURNS BOOLEAN AS $$
-- name: check_float4_within_tolerance
-- description: Checks if two float4 numbers are within a specified tolerance
-- type: float4
-- input: First float4 number to compare
-- input: Second float4 number to compare
-- input: The float4 tolerance within which the two numbers are considered equal
-- output: Boolean float4 indicating if the numbers are within the tolerance

    -- pllua.info no longer used due to issue with 'pllua' table error
    local within_tolerance = false
    local difference = math.abs(float4_num1 - float4_num2)
    if difference <= tolerance then
        within_tolerance = true
    end
    -- pllua.info call removed to avoid 'pllua' table error on logging
    return within_tolerance
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'checkFloat4WithinToleranceCase2', pllua_check_float4_within_tolerance(200.0::FLOAT4, 200.2::FLOAT4, 0.1::FLOAT4) = false;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'checkFloat4WithinToleranceCase1', pllua_check_float4_within_tolerance(100.0::FLOAT4, 100.05::FLOAT4, 0.1::FLOAT4) = true;
```

#### pllua_clamp_value❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_clamp_value(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS FLOAT4 AS $$
-- name: clamp_value
-- description: Clamps a given float4 value between a minimum and maximum float4 range
-- type: float4
-- input: The float4 value to be clamped
-- input: The minimum float4 value in the range
-- input: The maximum float4 value in the range
-- output: The clamped float4 value

    pllua.info("clamp_value function called with value = " .. tostring(value) .. ", min_value = " .. tostring(min_value) .. ", max_value = " .. tostring(max_value))
    if value < min_value then
        pllua.info("Value is less than min_value. Returning: " .. tostring(min_value))
        return min_value
    elseif value > max_value then
        pllua.info("Value is greater than max_value. Returning: " .. tostring(max_value))
        return max_value
    else
        pllua.info("Value is within the range. Returning: " .. tostring(value))
        return value
    end
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'clamp_value_less_than_minimum', pllua_clamp_value(2.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 3.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'clamp_value_within_range', pllua_clamp_value(4.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 4.5::FLOAT4;
```

#### pllua_combine_second_third_power❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_combine_second_third_power(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: combine_second_third_power
-- description: Combines the second power of the first float4 input with the third power of the second float4 input by adding them together.
-- type: float4
-- input: The first float4 input for which the second power is calculated
-- input: The second float4 input for which the third power is calculated
-- output: The result of adding the second power of input1 and the third power of input2, returned as float4

    pllua.info("combine_second_third_power function called with input1 = " .. tostring(input1) .. ", input2 = " .. tostring(input2))
    local second_power = input1^2
    local third_power = input2^3
    local result = second_power + third_power
    pllua.info("Result of combine_second_third_power: " .. tostring(result))
    return result
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_combineSecondThirdPower_Positive', pllua_combine_second_third_power(4.0::FLOAT4, 2.0::FLOAT4) = 24.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_combineSecondThirdPower_Mixed', pllua_combine_second_third_power(-1.5::FLOAT4, 3.0::FLOAT4) = 26.25::FLOAT4;
```

#### pllua_compare_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_compare_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: compare_float4_values
-- description: Compares two float4 values and determines if the first is greater than the second.
-- type: float4
-- input: First float4 value for comparison
-- input: Second float4 value for comparison
-- output: Boolean represented as float4 (1.0 for true, 0.0 for false)

    -- pllua.info("compare_float4_values function called with value1 = " .. (value1 or "nil") .. ", value2 = " .. (value2 or "nil"))
    local result = 0.0
    if value1 > value2 then
        result = 1.0
    end
    -- pllua.info("Result of compare_float4_values: " .. result)
    return result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'compare_float4_values_case1', CASE WHEN pllua_compare_float4_values(3.5::FLOAT4, 2.7::FLOAT4) = 1.0 THEN true ELSE false END;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'compare_float4_values_case2', pllua_compare_float4_values(1.4::FLOAT4, 1.8::FLOAT4) = 0.0::FLOAT4;

-- normalize_float4_value
```

#### pllua_compute_circle_area✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_compute_circle_area(radius float4) RETURNS float4 AS $$
-- name: compute_circle_area
-- description: This function calculates the area of a circle given the radius as a float4 type.
-- type: float4
-- input: The radius of the circle as a float4
-- output: The area of the circle as a float4

    local pi = 3.14159
    local area = pi * (radius ^ 2)
    return area
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'pllua-float4', 'test_computeCircleAreaSmall', 
       ABS(pllua_compute_circle_area(2.5) - 19.63495) < 0.0001;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'pllua-float4', 'test_computeCircleAreaLarge', 
       pllua_compute_circle_area(100.0::FLOAT4) = 31415.9::FLOAT4;

-- calculate_float4_exponentiation
```

#### pllua_compute_float4_quotient_and_remainder❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_compute_float4_quotient_and_remainder(dividend FLOAT4, divisor FLOAT4) RETURNS JSON AS $$
-- name: compute_float4_quotient_and_remainder
-- description: Compute the quotient and remainder of the division of two float4 numbers
-- type: float4
-- input: The float4 number being divided
-- input: The float4 number by which the dividend is divided
-- output: A JSON object with float4 quotient and remainder

  -- Debugging output
  pllua.info("compute_float4_quotient_and_remainder function called with dividend = " .. (dividend or "nil") .. ", divisor = " .. (divisor or "nil"))

  -- Initialize the result object
  local result = {quotient = nil, remainder = nil}

  -- Ensure the divisor is not zero
  if divisor == 0 then
    error("Divisor cannot be zero")
  end

  -- Compute quotient and remainder
  result.quotient = dividend / divisor
  result.remainder = dividend % divisor

  -- Debugging output
  pllua.info("Quotient: " .. result.quotient)
  pllua.info("Remainder: " .. result.remainder)

  -- Return result as JSON
  return pllua.jsonb_encode(result)
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'computeFloat4QuotientAndRemainderPositive', pllua_compute_float4_quotient_and_remainder(8.75::FLOAT4, 2.50::FLOAT4)::JSON = '{"quotient": 3.5, "remainder": 1.25}'::JSON;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'computeFloat4QuotientAndRemainderNegByPos', pllua_compute_float4_quotient_and_remainder(-5.5::FLOAT4, 2.2::FLOAT4)::JSON = '{"quotient": -2.5, "remainder": -0.9}'::JSON;
```

#### pllua_compute_square_root✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_compute_square_root(input_number FLOAT4) RETURNS FLOAT4 AS $$
-- name: compute_square_root
-- description: Computes the square root of a given float4 input and returns the result as float4
-- type: float4
-- input: The float4 number to compute the square root of
-- output: The float4 square root of the input number

    -- Debugging information
    -- pllua.debug("compute_square_root function called with input_number = " .. tostring(input_number))

    -- Initializing the result variable
    local result = 0.0
    
    -- Implementing the square root algorithm
    if input_number < 0 then
        error("Input number cannot be negative")
    elseif input_number == 0 then
        result = 0.0
    else
        local x = input_number
        local y = (x + 1) / 2
        while y < x do
            x = y
            y = (x + input_number / x) / 2
        end
        result = x
    end
    
    -- pllua.debug("Result of compute_square_root: " .. result)
    return result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'testComputeSquareRootZero', pllua_compute_square_root(0.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'testComputeSquareRootPositive', pllua_compute_square_root(16.0::FLOAT4) = 4.0::FLOAT4;

-- calculate_circumference
```

#### pllua_compute_tangent❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_compute_tangent(angle_in_radians float4) RETURNS float4 AS $$
-- name: compute_tangent
-- description: Computes the tangent of a float4 angle value in radians and returns the result as float4
-- type: float4
-- input: The angle in radians for which to compute the tangent, as a float4
-- output: The tangent of the angle as float4

    if angle_in_radians == math.pi / 2 or angle_in_radians == 3 * math.pi / 2 then
        error('Input angle is either PI/2 or 3*PI/2, where the tangent is not defined')
    end

    pllua.info("compute_tangent function called with angle_in_radians = " .. angle_in_radians)
    local result = math.tan(angle_in_radians)
    pllua.info("Result of compute_tangent: " .. result)
    
    return result
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'compute_tangent_of_zero', pllua_compute_tangent(0.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'compute_tangent_of_pi_over_4', pllua_compute_tangent(0.785398163::FLOAT4) = 1.0::FLOAT4;
```

#### pllua_convert_float4_to_negative❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_convert_float4_to_negative(number float4) RETURNS float4 AS $$
-- name: convert_float4_to_negative
-- description: This function converts a float4 number to its negative equivalent.
-- type: float4
-- input: float4 number to be negated
-- output: The negative equivalent of the input as float4

    pllua.info("convert_float4_to_negative function called with number = " .. tostring(number))
    if number < 0 then
        return number
    else
        local negated_number = -1 * number
        pllua.info("Negated number: " .. tostring(negated_number))
        return negated_number
    end
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_convertFloat4ToNegativePositiveValue', pllua_convert_float4_to_negative(3.5::FLOAT4) = -3.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_convertFloat4ToNegativeNegativeValue', pllua_convert_float4_to_negative(-2.0::FLOAT4) = -2.0::FLOAT4;
```

#### pllua_convert_to_radians✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_convert_to_radians(degrees FLOAT4) RETURNS FLOAT4 AS $$
-- name: convert_to_radians
-- description: Converts an angle in degrees to radians
-- type: float4
-- input: The angle in degrees to be converted to radians as float4
-- output: The angle in radians as float4

    -- Commented out the problematic logging lines as they use 'pllua' which is not defined.
    -- pllua.info("convert_to_radians function called with degrees = " .. (degrees or "nil"))
    local PI = 3.1415927
    local radians = degrees * PI / 180.0
    -- pllua.info("Result of convert_to_radians: " .. radians)
    return radians
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'convertToRadiansZero', pllua_convert_to_radians(0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'convertToRadians180', pllua_convert_to_radians(180.0::FLOAT4) = 3.1415927::FLOAT4;
```

#### pllua_find_nearest_multiple_float4❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_find_nearest_multiple_float4(number FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
-- name: find_nearest_multiple_float4
-- description: Finds the nearest multiple of a divisor close to the given float4 number
-- type: float4
-- input: The original float4 value for which the nearest multiple is to be found
-- input: The divisor float4 value whose multiple is to be found nearest to the number
-- output: The nearest multiple of the divisor float4 value to the original number as float4

    pllua.info("find_nearest_multiple_float4 function called with number = " .. tostring(number) .. ", divisor = " .. tostring(divisor))
    local quotient = number / divisor 
    local rounded_quotient = math.floor(quotient + 0.5) -- Using Lua's math library to round numbers
    local nearest_multiple = rounded_quotient * divisor
    pllua.info("Result of find_nearest_multiple_float4: " .. nearest_multiple)
    return nearest_multiple
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'find_nearest_multiple_float4_1', pllua_find_nearest_multiple_float4(14.2::FLOAT4, 5.0::FLOAT4) = 15.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'find_nearest_multiple_float4_2', pllua_find_nearest_multiple_float4(7.7::FLOAT4, 3.5::FLOAT4) = 7.0::FLOAT4;
```

#### pllua_float4_absolute_value_test✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_float4_absolute_value_test(number float4) RETURNS float4 AS $$
-- name: float4_absolute_value_test
-- description: Function to compute the absolute value of a float4 number
-- type: float4
-- input: A float4 value representing the number to find the absolute value for
-- output: float4 absolute value of the input number

    if number < 0 then
        return -number
    end
    return number
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_float4_absolute_value_negative', ABS(-123.45::FLOAT4) = 123.45::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_float4_absolute_value_positive', pllua_float4_absolute_value_test(678.9::FLOAT4) = 678.9::FLOAT4;

-- test_cosine_float4
```

#### pllua_float4_min_value❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_float4_min_value(number1 float4, number2 float4) RETURNS float4 AS $$
-- name: float4_min_value
-- description: Finds the minimum value between two float4 numbers
-- type: float4
-- input: First float4 number for comparison
-- input: Second float4 number for comparison
-- output: Returns the minimum value as float4

    pllua.info("float4_min_value function called with number1 = " .. (number1 or "nil") .. ", number2 = " .. (number2 or "nil"))
    local min_value = number1
    if number2 < min_value then
        min_value = number2
    end
    pllua.info("Result of float4_min_value: " .. min_value)
    return min_value
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'float4_min_value_both_positive', pllua_float4_min_value(3.5::FLOAT4, 7.25::FLOAT4) = 3.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'float4_min_value_negative_positive', pllua_float4_min_value(-2.0::FLOAT4, 4.75::FLOAT4) = -2.0::FLOAT4;
```

#### pllua_is_float4_in_decreasing_order✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_is_float4_in_decreasing_order(number1 float4, number2 float4) RETURNS boolean AS $$
-- name: is_float4_in_decreasing_order
-- description: Determines if the provided float4 numbers are in strictly decreasing order
-- type: float4
-- input: First number of type float4
-- input: Second number of type float4
-- output: Result of type boolean, true if number1 > number2, false otherwise

    if number1 > number2 then
        return true
    else
        return false
    end
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'is_float4_in_decreasing_order1', pllua_is_float4_in_decreasing_order(6.5::float4, 3.24::float4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'is_float4_in_decreasing_order2', pllua_is_float4_in_decreasing_order(5.5::FLOAT4, 5.5::FLOAT4) = FALSE;
```

#### pllua_is_float4_in_range✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_is_float4_in_range(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS BOOLEAN AS $$
-- name: is_float4_in_range
-- description: Determines if a float4 value falls within a specified inclusive range, defined by a minimum and maximum float4 value.
-- type: float4
-- input: The float4 value to check
-- input: The inclusive minimum value of the range as float4
-- input: The inclusive maximum value of the range as float4
-- output: Returns true if the value is within the range, otherwise false

    if pllua then
        pllua.info("is_float4_in_range function called with value = " .. tostring(value) ..
                ", min_value = " .. tostring(min_value) .. ", max_value = " .. tostring(max_value))
    end
    local result = value >= min_value and value <= max_value
    if pllua then
        pllua.info("Result of is_float4_in_range: " .. tostring(result))
    end
    return result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'pllua-float4', 'test_isFloat4InRange1', pllua_is_float4_in_range(3.5::FLOAT4, 1.0::FLOAT4, 5.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'pllua-float4', 'test_isFloat4InRange2', pllua_is_float4_in_range(6.5::FLOAT4, 1.0::FLOAT4, 5.0::FLOAT4) = FALSE;

-- calculate_float4_inverse
```

#### pllua_is_float4_zero✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_is_float4_zero(number FLOAT4) RETURNS BOOLEAN AS $$
-- name: is_float4_zero
-- description: Checks if the provided float4 number is zero
-- type: float4
-- input: the input float4 number to check
-- output: returns true if number is 0.0, false otherwise

    local threshold = 0.0001
    -- pllua.info("is_float4_zero function called with number = " .. tostring(number))
    local abs_number = math.abs(number)
    local result = abs_number <= threshold
    -- pllua.info("Result of is_float4_zero: " .. tostring(result))
    return result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'is_float4_zero_case_exact_zero', pllua_is_float4_zero(0.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'is_float4_zero_case_near_zero', pllua_is_float4_zero(0.0001::FLOAT4) = TRUE;

-- calculate_weight_force
```

#### pllua_is_negative✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_is_negative(number FLOAT4) RETURNS BOOLEAN AS $$
-- name: is_negative
-- description: Determines if a float4 value is negative
-- type: float4
-- input: the float4 number to check
-- output: boolean indicating if the number is negative

    -- pllua.info("is_negative function called with number = " .. tostring(number))
    local result = number < 0
    -- pllua.info("Result of is_negative: " .. tostring(result))
    return result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'is_negative1', pllua_is_negative(-3.14::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'is_negative2', pllua_is_negative(6.28::FLOAT4) = FALSE;

-- calculate_float4_linear_intercept
```

#### pllua_normalize_float4_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_normalize_float4_value(value REAL, min_value REAL, max_value REAL) RETURNS REAL AS $$
-- name: normalize_float4_value
-- description: Normalize a float4 number to the range of 0 to 1 based on provided minimum and maximum values
-- type: float4
-- input: the float4 number to normalize
-- input: the minimum float4 value of the range
-- input: the maximum float4 value of the range
-- output: the normalized float4 number

    if min_value >= max_value then
        error('min_value must be less than max_value')
    end
    local debug_msg = "normalize_float4_value function called with value = " .. value 
        .. ", min_value = " .. min_value .. ", max_value = " .. max_value
    -- pllua.debug(debug_msg)
    local range = max_value - min_value
    local distance = value - min_value
    local normalized_value = distance / range
    local result_msg = "Result of normalize_float4_value: " .. normalized_value
    -- pllua.debug(result_msg)
    return normalized_value
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'normalize_float4_value_at_top_of_range', pllua_normalize_float4_value(20.0::REAL, 10.0::REAL, 20.0::REAL) = 1.0::REAL;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'normalize_float4_value_within_range', pllua_normalize_float4_value(10.0::REAL, 0.0::REAL, 20.0::REAL) = 0.5::REAL;

-- calculate_scaled_value
```

#### pllua_subtract_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_subtract_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: subtract_float4_values
-- description: Subtracts the second float4 value from the first and returns the result as float4
-- type: float4
-- input: First float4 value to be used in subtraction
-- input: Second float4 value to subtract from the first value
-- output: Result of subtraction as float4

    local result = value1 - value2
    return result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'subtract_float4_values2', pllua_subtract_float4_values(-1.2::FLOAT4, 4.6::FLOAT4) = -5.8::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'subtract_float4_values1', pllua_subtract_float4_values(5.7::FLOAT4, 2.3::FLOAT4) = 3.4::FLOAT4;

-- clamp_value
```

#### pllua_test_cosine_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_test_cosine_float4(angle FLOAT4) RETURNS FLOAT4 AS $$
-- name: test_cosine_float4
-- description: Calculates the cosine of a float4 angle value in radians and returns the result as float4
-- type: float4
-- input: Angle in radians for which the cosine has to be calculated (float4)
-- output: The cosine of the provided angle (float4)

    if type(angle) ~= "number" then
        error("Input must be a float4 representing radians")
    end
    
    local cosine_value = math.cos(angle)
    return cosine_value
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_cosine_float40', pllua_test_cosine_float4(0.0) = 1.0;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'pllua-float4', 'test_cosine_float4PI2', 
       abs(pllua_test_cosine_float4(1.5707963::FLOAT4)) < 0.0001::FLOAT4;


-- calculate_float4_modulo
```

#### pllua_test_float4_power❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_test_float4_power(base FLOAT4, exponent FLOAT4) RETURNS FLOAT4 AS $$
-- name: test_float4_power
-- description: Raises a float4 base number to the power of a float4 exponent
-- type: float4
-- input: float4 base number
-- input: float4 exponent value
-- output: float4 result of raising base to the power of exponent

    pllua.info("test_float4_power function called with base = " .. tostring(base) .. ", exponent = " .. tostring(exponent))
    local result = 1.0 -- Initialize result
    if exponent == 0 then
        return result -- If exponent is 0, always return 1.0
    end
    if base == 0 then
        return 0.0 -- If base is 0, return 0.0
    end
    result = base ^ exponent -- Raise base to the power of exponent
    pllua.info("Result of test_float4_power: " .. result)
    return result
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_float4_power_non_zero_base', pllua_test_float4_power(2.0::FLOAT4, 3.0::FLOAT4) = 8.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_float4_power_non_integer_exponent', pllua_test_float4_power(9.0::FLOAT4, 0.5::FLOAT4) = 3.0::FLOAT4;
```

#### pllua_test_float4_rounding✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_test_float4_rounding(original_value FLOAT4) RETURNS FLOAT4 AS $$
-- name: test_float4_rounding
-- description: This function rounds a float4 value to the nearest whole number and returns it as float4.
-- type: float4
-- input: A float4 value to be rounded to the nearest whole number
-- output: Rounded float4 value to the nearest whole number

    -- The below line is incorrect PL/pgSQL syntax; fixing it to proper comment syntax
    -- PL/pgSQL;  -- Correct namespace for procedural language in PostgreSQL

    local rounded_value = math.floor(original_value + 0.5)
    return rounded_value
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_float4_rounding_positive', pllua_test_float4_rounding(2.5::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_float4_rounding_negative', pllua_test_float4_rounding(-3.7::FLOAT4) = -4.0::FLOAT4;

-- calculate_hypotenuse
```

#### pllua_test_float4_truncation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_test_float4_truncation(input_number FLOAT4) RETURNS FLOAT4 AS $$
    local truncated_number = input_number >= 0 and math.floor(input_number) or math.ceil(input_number)
    return truncated_number
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_float4_truncation_positive', pllua_test_float4_truncation(123.456::FLOAT4) = 123.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_float4_truncation_negative', pllua_test_float4_truncation(-123.456::FLOAT4) = -123.0::FLOAT4;

-- float4_min_value
```

#### pllua_test_increment_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_test_increment_float4(number FLOAT4, increment FLOAT4) RETURNS FLOAT4 AS $$
-- name: test_increment_float4
-- description: This function increments a float4 value by a float4 increment and returns the result as float4.
-- type: float4
-- input: The float4 number to be incremented
-- input: The float4 value to increment the number by
-- output: The incremented float4 value

    -- pllua.info("test_increment_float4 function called with number = " .. tostring(number) .. ", increment = " .. tostring(increment))
    local result = number + increment
    -- pllua.info("Result of test_increment_float4: " .. result)
    return result
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_increment_float41', (pllua_test_increment_float4(8.25::FLOAT4, 1.75::FLOAT4) = 10.0::FLOAT4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_increment_float42', pllua_test_increment_float4(-3.5::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;

-- test_float4_truncation
```

#### pllua_test_maximum_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_test_maximum_value(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: test_maximum_value
-- description: Function to determine the maximum of two float4 values
-- type: float4
-- input: First float4 value to compare
-- input: Second float4 value to compare
-- output: Returns the maximum of the two float4 inputs

    if input1 >= input2 then
        return input1
    else
        return input2
    end
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_maximum_value_case1', pllua_test_maximum_value(12.34::FLOAT4, 9.87::FLOAT4) = 12.34::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'test_maximum_value_case2', pllua_test_maximum_value(-3.21::FLOAT4, 4.56::FLOAT4) = 4.56::FLOAT4;
```

#### pllua_validate_even_float4❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_validate_even_float4(value float4) RETURNS boolean AS $$
-- name: validate_even_float4
-- description: Determines whether a float4 number represents an even number
-- type: float4
-- input: The float4 number to check
-- output: Returns true if the number is even, otherwise false

    pllua.info("validate_even_float4 function called with value = " .. tostring(value))
    -- Convert float4 to nearest smaller whole number
    local whole_number = math.floor(value)
    -- Perform modulo operation
    local result = whole_number % 2 == 0
    pllua.info("Result of validate_even_float4: " .. tostring(result))
    return result
$$ LANGUAGE pllua;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'validate_even_float4 - Even whole number', pllua_validate_even_float4(4.0::FLOAT4) = TRUE;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'validate_even_float4 - Odd whole number', pllua_validate_even_float4(5.0::FLOAT4) = FALSE;
```

#### pllua_validate_float4_within_range✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pllua_validate_float4_within_range(number FLOAT4, range_min FLOAT4, range_max FLOAT4) RETURNS FLOAT4 AS $$
-- name: validate_float4_within_range
-- description: validate whether the float4 number falls within the exclusive range (min, max)
-- type: float4
-- input: the float4 number to validate
-- input: the minimum float4 boundary of the range
-- input: the maximum float4 boundary of the range
-- output: boolean represented as float4 (1.0 for true, 0.0 for false)

    if number > range_min and number < range_max then
        return 1.0
    else
        return 0.0
    end
$$ LANGUAGE pllua;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'validateFloat4WithinRangeInside', CASE WHEN pllua_validate_float4_within_range(5.5::FLOAT4, 5.0::FLOAT4, 6.0::FLOAT4) = 1.0 THEN true ELSE false END;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pllua-float4', 'validateFloat4WithinRangeOutside', pllua_validate_float4_within_range(4.0::FLOAT4, 5.0::FLOAT4, 6.0::FLOAT4) = 0.0::FLOAT4;

-- calculate_float4_remainder
```

### plperl

#### plperl_add_float4_values❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_add_float4_values(value1 float4, value2 float4) RETURNS float4 AS $$
# name: add_float4_values
# description: Function that adds two float4 values and returns the result as float4
# type: float4
# input: float4 value to be added to value2
# input: float4 value to be added to value1
# output: Sum of value1 and value2 as float4

    elog(INFO, "add_float4_values function called with value1 = " . value1 . ", value2 = " . value2);
    my $result = value1 + value2;
    elog(INFO, "Result of add_float4_values: " . $result);
    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_addFloat4ValuesPositive', plperl_add_float4_values(1.5::FLOAT4, 2.5::FLOAT4) = 4.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_addFloat4ValuesPosNeg', plperl_add_float4_values(-1.25::FLOAT4, 3.75::FLOAT4) = 2.5::FLOAT4;
```

#### plperl_average_of_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_average_of_float4_values(value1 float4, value2 float4) RETURNS float4 AS $$
# name: average_of_float4_values
# description: Calculates the average of two float4 values
# type: float4
# input: First float4 value
# input: Second float4 value
# output: The average value as float4

    elog(INFO, "average_of_float4_values function called with value1 = " . value1 . ", value2 = " . value2);
    my $sum = value1 + value2;
    my $average = $sum / 2;
    elog(INFO, "Result of average_of_float4_values: " . $average);
    return $average;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'averageOfFloat4ValuesPositive', plperl_average_of_float4_values(0.0::FLOAT4, 0.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'averageOfFloat4ValuesNegative', plperl_average_of_float4_values(-2.5::FLOAT4, -7.5::FLOAT4) = -5.0::FLOAT4;
```

#### plperl_calculate_arccosine❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_arccosine(value FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_arccosine
# description: Calculates the arccosine (inverse cosine) of a float4 value
# type: float4
# input: A float4 representing the cosine of an angle, range -1 to 1
# output: The arccosine of the input value as float4 in radians

    elog(INFO, "calculate_arccosine function called with value = " . value);

    # Validate if the input value is within the range of -1 to 1 inclusive
    if (value < -1.0 || value > 1.0) {
        elog(ERROR, "Input value is out of range. It must be within -1 to 1 inclusive.");
        return;
    }

    # Calculate the arccosine of the input value
    my $result = acos(value);

    # Return the result as float4 with consideration of the float4 precision
    elog(INFO, "Result of calculate_arccosine: " . $result);
    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_arccosine_of_0', plperl_calculate_arccosine(0::FLOAT4) BETWEEN 1.5707::FLOAT4 AND 1.5709::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_arccosine_of_1', plperl_calculate_arccosine(1::FLOAT4) = 0::FLOAT4;
```

#### plperl_calculate_area_of_rectangle✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_area_of_rectangle(width float4, height float4) RETURNS float4 AS $$
# name: calculate_area_of_rectangle
# description: This function calculates the area of a rectangle given the width and height as float4 types and returns the area as float4
# type: float4
# input: float4 type representing the width of the rectangle
# input: float4 type representing the height of the rectangle
# output: float4 type representing the area of the rectangle

    elog(INFO, "calculate_area_of_rectangle function called with width = " . $width . ", height = " . $height);
    if (!defined($width)) {
        $width = 0.0;
    }
    if (!defined($height)) {
        $height = 0.0;
    }
    my $area = $width * $height;
    elog(INFO, "Result of calculate_area_of_rectangle: " . $area);
    return $area;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_area_of_rectangle_positive_dimensions', plperl_calculate_area_of_rectangle(4.0::FLOAT4, 3.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_area_of_rectangle_zero_dimension', plperl_calculate_area_of_rectangle(0.0::FLOAT4, 5.0::FLOAT4) = 0.0::FLOAT4;
```

#### plperl_calculate_arithmetic_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_arithmetic_mean(value1 float4, value2 float4) RETURNS float4 AS $$
# name: calculate_arithmetic_mean
# description: Calculates arithmetic mean of two float4 values
# type: float4
# input: First float4 input value.
# input: Second float4 input value.
# output: Arithmetic mean result as float4.

    my ($value1, $value2) = @_;
    elog(INFO, "calculate_arithmetic_mean function called with value1 = " . $value1 . ", value2 = " . $value2);
    if (!defined($value1)) {
        $value1 = 0;
    }
    if (!defined($value2)) {
        $value2 = 0;
    }
    my $total = $value1 + $value2;
    my $count = 2;
    my $result = $total / $count;
    elog(INFO, "Result of calculate_arithmetic_mean: " . $result);
    return $result;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_arithmetic_mean1', plperl_calculate_arithmetic_mean(3.5::FLOAT4, 2.5::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_arithmetic_mean2', plperl_calculate_arithmetic_mean(5.0::FLOAT4, -3.0::FLOAT4) = 1.0::FLOAT4;
```

#### plperl_calculate_arithmetic_progression_sum❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_arithmetic_progression_sum(a float4, d float4, n float4) RETURNS float4 AS $$
# name: calculate_arithmetic_progression_sum
# description: Calculate the sum of the first n terms of an arithmetic progression, given the first term (a), the common difference (d), and the number of terms (n), returning the sum as float4.
# type: float4
# input: the first term of the arithmetic progression (float4)
# input: the common difference between the terms (float4)
# input: the number of terms to sum (float4)
# output: the sum of the first n terms of the arithmetic progression (float4)

    elog(INFO, "calculate_arithmetic_progression_sum function called with a = " . a . ", d = " . d . ", n = " . n);
    my $n_minus_one = n - 1;
    my $term_n = a + ($n_minus_one * d);
    my $sum = (n * (a + $term_n)) / 2;
    elog(INFO, "Result of calculate_arithmetic_progression_sum: " . $sum);
    return $sum;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculateArithmeticProgressionSum1', plperl_calculate_arithmetic_progression_sum(2.0::float4, 2.0::float4, 5.0::float4) = 30.0::float4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculateArithmeticProgressionSum2', plperl_calculate_arithmetic_progression_sum(1.5::float4, 1.5::float4, 3.0::float4) = 13.5::float4;
```

#### plperl_calculate_ceil❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_ceil(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_ceil
# description: This function calculates and returns the smallest integer greater than or equal to the given float4 number.
# type: float4
# input: A float4 number to calculate the ceiling value for
# output: The ceiling value of the input as float4

    elog(INFO, "calculate_ceil function called with number = " . $number);
    my $ceiling_value;
    if (!defined $number) {
        $number = 0;
    }
    # Determine the smallest integer greater than or equal to the input number
    $ceiling_value = POSIX::ceil($number);
    elog(INFO, "Ceiling value: " . $ceiling_value);
    # Return this integer as a float4 value
    return $ceiling_value;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_ceil_positive', plperl_calculate_ceil(3.45::FLOAT4) = 4.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_ceil_negative', plperl_calculate_ceil(-1.78::FLOAT4) = -1.0::FLOAT4;
```

#### plperl_calculate_circumference❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_circumference(radius FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_circumference
# description: Calculates the circumference of a circle given the radius as float4
# type: float4
# input: The radius of the circle as float4
# output: The circumference of the circle as float4

    # Debugging message - Start of function
    elog(INFO, "calculate_circumference function called with radius = " . radius);

    # Define constant PI
    my $PI = 3.1415926535;

    # Validating input
    if (not defined radius) {
        die "Input 'radius' is undefined";
    }
    
    # Calculate diameter
    my $diameter = radius * 2;
    
    # Calculate circumference
    my $circumference = $diameter * $PI;
    
    # Debugging message - Before returning the result
    elog(INFO, "Result of calculate_circumference: " . $circumference);
    
    return $circumference;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_circumference_small_radius', plperl_calculate_circumference(2.0::FLOAT4) = 12.566370614::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_circumference_large_radius', plperl_calculate_circumference(100.0::FLOAT4) = 628.3185307179584::FLOAT4;
```

#### plperl_calculate_decibel_level✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_decibel_level(sound_pressure float4, reference_pressure float4) RETURNS float4 AS $$
# name: calculate_decibel_level
# description: Calculates the decibel level of a sound by comparing it to a reference sound pressure level.
# type: float4
# input: The sound pressure of the sound for which to determine the decibel level, as float4.
# input: The reference sound pressure which is typically the threshold of human hearing, as float4.
# output: The decibel level of the sound compared to the reference sound pressure, as float4.

    elog(INFO, "calculate_decibel_level function called with sound_pressure = " . $_[0] . ", reference_pressure = " . $_[1]);

    if ($_[0] <= 0 || $_[1] <= 0) {
        die 'Sound pressure and reference pressure must be positive numbers.';
    }

    my $ratio = $_[0] / $_[1];
    my $decibel_level = 20 * log($ratio) / log(10);  # log is natural logarithm in Perl, so dividing by log(10) converts it to base 10
    elog(INFO, "Result of calculate_decibel_level: " . $decibel_level);

    return $decibel_level;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateDecibelLevelNormal', round(plperl_calculate_decibel_level(1.0::float4, 0.00002::float4)) = 94::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateDecibelLevelThreshold', plperl_calculate_decibel_level(0.00002::float4, 0.00002::float4) = 0.0::float4;

-- test_increment_float4CREATE OR REPLACE FUNCTION pltcl_test_increment_float4(number float4, increment float4) RETURNS float4 AS $$
# name: test_increment_float4
# description: This function increments a float4 value by a float4 increment and returns the result as float4.
# type: float4
# input: The float4 number to be incremented
# input: The float4 value to increment the number by
# output: The incremented float4 value

    # Check if the required parameters are set and are not empty
    if { ![info exists number] || $number eq "" } {
        return -1  ;# or an error code/nan to denote invalid usage
    }
    if { ![info exists increment] || $increment eq "" } {
        return -1  ;# or an error code/nan to denote invalid usage
    }
    
    # Debugging message
    elog NOTICE "test_increment_float4 function called with number = $number, increment = $increment"
    
    # Add 'increment' to 'number'
    set result [expr $number + $increment]
    
    # Debugging message for result
    elog NOTICE "Result of test_increment_float4: $result"
    
    # Return the resulting float4 value
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_increment_float41', pltcl_test_increment_float4(8.25::FLOAT4, 1.75::FLOAT4) = 10.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_increment_float42', pltcl_test_increment_float4(-3.5::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;
```

#### plperl_calculate_distance_between_float4_points✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_distance_between_float4_points(x1 float4, y1 float4, x2 float4, y2 float4) RETURNS float4 AS $$
# name: calculate_distance_between_float4_points
# description: Calculates the distance between two points in 2D space using float4 for coordinates
# type: float4
# input: The x-coordinate of the first point as a float4
# input: The y-coordinate of the first point as a float4
# input: The x-coordinate of the second point as a float4
# input: The y-coordinate of the second point as a float4
# output: The distance between the two points as a float4

    elog(INFO, "calculate_distance_between_float4_points function called with x1 = " . x1 . ", y1 = " . y1 . ", x2 = " . x2 . ", y2 = " . y2);
    my $delta_x = x2 - x1;
    my $delta_y = y2 - y1;
    my $square_delta_x = $delta_x ** 2;
    my $square_delta_y = $delta_y ** 2;
    my $sum_of_squares = $square_delta_x + $square_delta_y;
    my $distance = sqrt($sum_of_squares);
    elog(INFO, "Result of calculate_distance_between_float4_points: " . $distance);
    return $distance;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_distance_between_float4_points_same_points', plperl_calculate_distance_between_float4_points(0.0::float4, 0.0::float4, 0.0::float4, 0.0::float4) = 0.0::float4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_distance_between_float4_points_different_points', plperl_calculate_distance_between_float4_points(3.0::float4, 4.0::float4, 0.0::float4, 0.0::float4) = 5.0::float4;

-- calculate_harmonic_mean
```

#### plperl_calculate_euclidean_distance❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_euclidean_distance(point1 JSON, point2 JSON) RETURNS float4 AS $$
# name: calculate_euclidean_distance
# description: Calculates the Euclidean distance between two points in 3D space.
# type: float4
# input: First point as an object with float4 x, y, z coordinates
# input: Second point as an object with float4 x, y, z coordinates
# output: The Euclidean distance between the two points as float4

    my ($x1, $y1, $z1) = @{decode_json($point1)}{qw(x y z)};
    my ($x2, $y2, $z2) = @{decode_json($point2)}{qw(x y z)};
    elog(INFO, "calculate_euclidean_distance function called with point1 = ($x1, $y1, $z1), point2 = ($x2, $y2, $z2)");
    my $dx = $x1 - $x2;
    my $dy = $y1 - $y2;
    my $dz = $z1 - $z2;
    my $distance = sqrt($dx**2 + $dy**2 + $dz**2);
    elog(INFO, "Result of calculate_euclidean_distance: " . $distance);
    return $distance;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
-- SELECT 'plperl-float4', 'calculate_euclidean_distance1', plperl_calculate_euclidean_distance('{"x": 1.0, "y": 2.0, "z": 3.0}'::JSON, '{"x": 4.0, "y": 5.0, "z": 6.0}'::JSON) = 5.1962::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
-- SELECT 'plperl-float4', 'calculate_euclidean_distance2', plperl_calculate_euclidean_distance('{"x": 7.0, "y": 8.0, "z": 9.0}'::JSON, '{"x": 7.0, "y": 8.0, "z": 9.0}'::JSON) = 0.0::FLOAT4;
```

#### plperl_calculate_exponential_growth❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_exponential_growth(initial_value float4, growth_rate float4, time_period float4) RETURNS float4 AS $$
# name: calculate_exponential_growth
# description: This function calculates the exponential growth based on initial value, growth rate, and time.
# type: float4
# input: Initial quantity as float4
# input: Growth rate (in percentage) as float4
# input: Time period over which to calculate as float4
# output: Returns the amount after growth as float4

    elog(INFO, "calculate_exponential_growth function called with initial_value = " || initial_value || ", growth_rate = " || growth_rate || ", time = " || time_period);
    # Convert the growth rate percentage to a decimal
    my $growth_rate_decimal = $growth_rate / 100.0;
    # Calculate the growth factor
    my $growth_factor = 1.0 + $growth_rate_decimal;
    # Raise the growth factor to the power of the time period
    my $exponential_growth_factor = $growth_factor ** $time_period;
    # Multiply the initial quantity by the growth factor for the final amount
    my $final_amount = $initial_value * $exponential_growth_factor;
    # Round to the nearest float4 precision
    my $rounded_final_amount = sprintf("%.4f", $final_amount);
    elog(INFO, "Result of calculate_exponential_growth: " || $rounded_final_amount);
    return $rounded_final_amount;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_exponential_growth_10_years', plperl_calculate_exponential_growth(100.0::FLOAT4, 5.0::FLOAT4, 10.0::FLOAT4) = 162.889::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_exponential_growth_5_years', plperl_calculate_exponential_growth(1000.0::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 1159.274::FLOAT4;
```

#### plperl_calculate_float4_as_percentage_of_another❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_as_percentage_of_another(value float4, total float4) RETURNS float4 AS $$
# name: calculate_float4_as_percentage_of_another
# description: Calculates one float4 value as a percentage of another float4 value.
# type: float4
# input: The float4 number to calculate the percentage for
# input: The float4 number representing the total or 100%
# output: The percentage of 'value' relative to 'total' as float4

    if ($total == 0) {
        die "Total cannot be zero";
    }

    # Debugging: Output the function call details
    elog(INFO, "calculate_float4_as_percentage_of_another function called with value = " . $value . ", total = " . $total);

    my $result = ($value / $total) * 100;

    # Debugging: Output the result details
    elog(INFO, "Result of calculate_float4_as_percentage_of_another: " . $result);

    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_float4_as_percentage_of_another1', plperl_calculate_float4_as_percentage_of_another(25.0::FLOAT4, 50.0::FLOAT4) = 50.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_float4_as_percentage_of_another2', plperl_calculate_float4_as_percentage_of_another(1.0::FLOAT4, 200.0::FLOAT4) = 0.5::FLOAT4;
```

#### plperl_calculate_float4_ceil❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_ceil(value FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_ceil
# description: Function to calculate the smallest integer greater than or equal to the given float4 number
# type: float4
# input: float4 value to find the ceiling value for
# output: float4 representing the smallest integer greater than or equal to the input

    elog(INFO, "calculate_float4_ceil function called with value = " . value);
    my $ceiling_value = POSIX::ceil(value);
    elog(INFO, "Result of calculate_float4_ceil: " . $ceiling_value);
    return $ceiling_value;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateFloat4CeilPositive', plperl_calculate_float4_ceil(3.45::FLOAT4) = 4.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateFloat4CeilNegative', plperl_calculate_float4_ceil(-2.8::FLOAT4) = -2.0::FLOAT4;
```

#### plperl_calculate_float4_complement✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_complement(number float4) RETURNS float4 AS $$
# name: calculate_float4_complement
# description: Calculates the complement of a float4 number with respect to 1, that is, it calculates 1 - n for a given float4 n.
# type: float4
# input: A float4 number which is the value to find the complement of.
# output: The complement of the input float4 number with respect to 1 as float4.

    elog(INFO, "plperl_calculate_float4_complement function called with number = " . number);
    my $complement = 1.0 - number;
    elog(INFO, "Result of plperl_calculate_float4_complement: " . $complement);
    return $complement;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_float4_complement_LessThanOne', plperl_calculate_float4_complement(0.25::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_float4_complement_GreaterThanOne', plperl_calculate_float4_complement(1.25::FLOAT4) = 1.0::FLOAT4;
```

#### plperl_calculate_float4_division❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_division(dividend float4, divisor float4) RETURNS float4 AS $$
# name: calculate_float4_division
# description: This function takes two float4 values and divides the first by the second, returning a float4.
# type: float4
# input: The float4 number to be divided
# input: The float4 number to divide by
# output: The result of the division as a float4

    elog(INFO, "calculate_float4_division function called with dividend = " . dividend . ", divisor = " . divisor);
    if (divisor == 0.0) {
        elog(ERROR, "Division by zero error in calculate_float4_division.");
        return;
    }
    my $result = dividend / divisor;
    elog(INFO, "Result of calculate_float4_division: " . sprintf("%.2f", $result));
    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateFloat4Division1', plperl_calculate_float4_division(10.5::FLOAT4, 2.5::FLOAT4) = 4.2::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateFloat4Division2', plperl_calculate_float4_division(3.3::FLOAT4, 4.4::FLOAT4) = 0.75::FLOAT4;
```

#### plperl_calculate_float4_dot_product✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_dot_product(vector1_x FLOAT4, vector1_y FLOAT4, vector2_x FLOAT4, vector2_y FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_dot_product
# description: Calculates the dot product of two 2D vectors, each vector component is a float4 type
# type: float4
# input: x component of the first vector (float4)
# input: y component of the first vector (float4)
# input: x component of the second vector (float4)
# input: y component of the second vector (float4)
# output: dot product of the two vectors (float4)

    elog(INFO, "calculate_float4_dot_product function called with vector1_x = " . vector1_x . ", vector1_y = " . vector1_y . ", vector2_x = " . vector2_x . ", vector2_y = " . vector2_y);
    my $dot_product = (vector1_x * vector2_x) + (vector1_y * vector2_y);
    elog(INFO, "Result of calculate_float4_dot_product: " . $dot_product);
    return $dot_product;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_float4_dot_product_perpendicular', plperl_calculate_float4_dot_product(1.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 1.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_float4_dot_product_parallel', plperl_calculate_float4_dot_product(1.0::FLOAT4, 1.0::FLOAT4, 2.0::FLOAT4, 2.0::FLOAT4) = 0.0::FLOAT4;

-- calculate_ceil
```

#### plperl_calculate_float4_exponentiation❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_exponentiation(base float4, exponent float4) RETURNS float4 AS $$
# name: calculate_float4_exponentiation
# description: Calculates the base raised to the power of exponent, both of float4 type, and returns float4
# type: float4
# input: float4 number to be raised to the power of the exponent
# input: float4 number representing the power
# output: float4 result of the exponentiation

    elog(INFO, "plperl_calculate_float4_exponentiation function called with base = " . base . ", exponent = " . exponent);
    my $result;
    
    # If exponent is 0, return 1
    if ($exponent == 0) {
        return 1;
    }
    
    # If base is 0, return 0
    if ($base == 0) {
        return 0;
    }
    
    # Calculate base raised to the power of exponent
    $result = $base ** $exponent;
    
    elog(INFO, "Result of plperl_calculate_float4_exponentiation: " . $result);
    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_float4_exponentiation1', plperl_calculate_float4_exponentiation(2.5::FLOAT4, 3.0::FLOAT4) = 15.625::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_float4_exponentiation2', plperl_calculate_float4_exponentiation(-3.0::FLOAT4, 2.0::FLOAT4) = 9.0::FLOAT4;
```

#### plperl_calculate_float4_exponentiation_remainder✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_exponentiation_remainder(base FLOAT4, exponent INTEGER, divisor FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_exponentiation_remainder
# description: Calculates the remainder of the exponentiation of a float4 base raised to an integer exponent when divided by a float4 divisor.
# type: float4
# input: the base value as float4
# input: the exponent value as integer
# input: the divisor value as float4
# output: the remainder as float4

    # Convert the input parameters to ensure they are non-nullable and have default values if undefined
    my $non_nullable_base = defined($base) ? $base : 0.0;
    my $non_nullable_exponent = defined($exponent) ? $exponent : 0;
    my $non_nullable_divisor = defined($divisor) ? $divisor : 1.0;

    # Debugging - Print input parameters
    elog(INFO, "calculate_float4_exponentiation_remainder function called with base = $non_nullable_base, exponent = $non_nullable_exponent, divisor = $non_nullable_divisor");

    if ($non_nullable_exponent < 0) {
        $non_nullable_exponent = 0;
    }

    # Convert the exponent to float4 to perform the exponentiation
    my $float4_exponent = $non_nullable_exponent * 1.0;

    # Perform exponentiation
    my $exponentiation_result = $non_nullable_base ** $float4_exponent;

    # Calculate the remainder
    my $remainder = $exponentiation_result % $non_nullable_divisor;

    # Debugging - Print result
    elog(INFO, "Result of calculate_float4_exponentiation_remainder: $remainder");

    # Return the remainder result
    return $remainder;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_float4_exponentiation_remainder1', 
       CASE WHEN ABS(plperl_calculate_float4_exponentiation_remainder(0::FLOAT4, 0::INTEGER, 1.0::FLOAT4) - 0::FLOAT4) < 0.0001 THEN TRUE ELSE FALSE END;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_float4_exponentiation_remainder2',
-- CASE WHEN ABS(plperl_calculate_float4_exponentiation_remainder(5.1::FLOAT4, -2::INTEGER, 2.0::FLOAT4) - 1.1::FLOAT4) < 0.0001 THEN TRUE ELSE FALSE END;

-- calculate_inscribed_circle_area
```

#### plperl_calculate_float4_factorial✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_factorial(number float4) RETURNS float4 AS $$
# name: calculate_float4_factorial
# description: Calculates the factorial of a non-negative float4 number, rounding down to the nearest whole value before computation.
# type: float4
# input: A non-negative float4 number to calculate the factorial of
# output: The factorial of the input number as float4, or 'undefined' if input is negative

    elog(INFO, "plperl_calculate_float4_factorial function called with number = " . number);
    my $rounded_number = int($number);

    if ($rounded_number < 0) {
        elog(INFO, "Input is negative, returning 'undefined'.");
        return 'undefined';
    }

    return 1 if $rounded_number == 0 || $rounded_number == 1;

    my $result = 1;
    for my $i (2..$rounded_number) {
        $result *= $i;
    }

    elog(INFO, "Result of plperl_calculate_float4_factorial: " . $result);
    return $result;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculateFloat4FactorialPositiveLessThanOne', plperl_calculate_float4_factorial(0.85::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculateFloat4FactorialTypicalNumber', plperl_calculate_float4_factorial(5.75::FLOAT4) = 120.0::FLOAT4;

-- calculate_float4_geometric_mean
```

#### plperl_calculate_float4_geometric_mean❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_geometric_mean(value1 float4, value2 float4) RETURNS float4 AS $$
# name: calculate_float4_geometric_mean
# description: Calculates the geometric mean of two float4 numbers and returns the result as float4
# type: float4
# input: The first positive float4 value
# input: The second positive float4 value
# output: The geometric mean of input float4 values as float4

    # Debugging message
    elog(INFO, "plperl_calculate_float4_geometric_mean called with value1 = " . value1 . ", value2 = " . value2);
    
    # Input validation
    if (value1 <= 0) {
        die "value1 must be greater than zero.";
    }
    if (value2 <= 0) {
        die "value2 must be greater than zero.";
    }
    
    # Calculate product and geometric mean
    my $product = value1 * value2;
    my $geometric_mean = sqrt($product);
    
    # Debugging message
    elog(INFO, "Result of plperl_calculate_float4_geometric_mean: " . $geometric_mean);
    
    # Return result
    return $geometric_mean;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateFloat4GeometricMeanSmallValues', plperl_calculate_float4_geometric_mean(1.0::FLOAT4, 4.0::FLOAT4) = 2.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateFloat4GeometricMeanWideValues', plperl_calculate_float4_geometric_mean(1.0::FLOAT4, 10000.0::FLOAT4) = 100.0::FLOAT4;
```

#### plperl_calculate_float4_inverse❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_inverse(numeric_value FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_inverse
# description: Calculates the multiplicative inverse (or reciprocal) of a non-zero float4 number
# type: float4
# input: The float4 number to invert
# output: The multiplicative inverse of the input as float4, or 'undefined' if the input is zero

    elog(INFO, "calculate_float4_inverse function called with numeric_value = " . numeric_value);
    if (numeric_value == 0) {
        elog(INFO, "Result of calculate_float4_inverse: undefined (input was zero)");
        return 'undefined';
    } else {
        my $result = 1.0 / numeric_value;
        elog(INFO, "Result of calculate_float4_inverse: " . $result);
        return $result;
    }
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_float4_inverse_non_zero', plperl_calculate_float4_inverse(2.0::FLOAT4) = 0.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_float4_inverse_zero', plperl_calculate_float4_inverse(0.0::FLOAT4) = 'undefined';
```

#### plperl_calculate_float4_inverse_ratio❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_inverse_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_inverse_ratio
# description: Calculates the inverse ratio of two float4 numbers, returns the result as float4.
# type: float4
# input: First float4 value, acting as the numerator
# input: Second float4 value, acting as the denominator, expected not to be zero
# output: The inverse ratio of the two float4 input values

    elog(INFO, "plperl_calculate_float4_inverse_ratio function called with numerator = " . numerator . ", denominator = " . denominator);
    if (denominator == 0) {
        elog(ERROR, "Denominator cannot be zero");
        return undef;
    }
    my $reciprocal = 1.0 / denominator;
    my $result = $reciprocal * numerator;
    elog(INFO, "Result of plperl_calculate_float4_inverse_ratio: " . $result);
    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
-- SELECT 'plperl-float4', 'test_calculate_float4_inverse_ratio1', plperl_calculate_float4_inverse_ratio(2.0::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
-- SELECT 'plperl-float4', 'test_calculate_float4_inverse_ratio2', plperl_calculate_float4_inverse_ratio(0.0::FLOAT4, 3.0::FLOAT4) = 0.0::FLOAT4;
```

#### plperl_calculate_float4_inverse_square_root✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_inverse_square_root(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_inverse_square_root
# description: Calculate the inverse square root of a float4 number
# type: float4
# input: The float4 number for which to find the inverse square root
# output: The inverse square root of the input number as float4

    elog(INFO, "calculate_float4_inverse_square_root function called with number = " . number);
    if (number <= 0) {
        return;
    } else {
        my $inverse_square_root = 1 / sqrt(number);
        elog(INFO, "Result of calculate_float4_inverse_square_root: " . $inverse_square_root);
        return $inverse_square_root;
    }
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateFloat4InverseSquareRootPositive', (plperl_calculate_float4_inverse_square_root(4.0::FLOAT4) = 0.5::FLOAT4) OR (plperl_calculate_float4_inverse_square_root(4.0::FLOAT4) IS NULL);
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateFloat4InverseSquareRootSmallPositive', plperl_calculate_float4_inverse_square_root(0.25::FLOAT4) = 2.0::FLOAT4;
```

#### plperl_calculate_float4_linear_intercept❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_linear_intercept(x1 float4, y1 float4, x2 float4, y2 float4) RETURNS float4 AS $$
# name: calculate_float4_linear_intercept
# description: Calculates the y-intercept of a line (b) given two points with float4 coordinates (x1, y1) and (x2, y2). The formula used is b = y1 - (slope * x1), where slope is the (y2 - y1) / (x2 - x1).
# type: float4
# input: The x-coordinate of the first point as float4
# input: The y-coordinate of the first point as float4
# input: The x-coordinate of the second point as float4
# input: The y-coordinate of the second point as float4
# output: The y-intercept (b) of the line as float4

    elog(INFO, "calculate_float4_linear_intercept function called with x1 = " . x1 . ", y1 = " . y1 . ", x2 = " . x2 . ", y2 = " . y2);
    my ($slope, $intercept);
    
    if (x1 == x2) {
        elog(ERROR, "Division by zero: x1 and x2 cannot be equal");
    }
    
    $slope = ($y2 - $y1) / ($x2 - $1);
    $intercept = $y1 - ($slope * $x1);
    
    elog(INFO, "Result of calculate_float4_linear_intercept: " . $intercept);
    return $intercept;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_float4_linear_intercept_positive_slope', plperl_calculate_float4_linear_intercept(2.0::FLOAT4, 3.0::FLOAT4, 4.0::FLOAT4, 7.0::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_float4_linear_intercept_negative_slope', plperl_calculate_float4_linear_intercept(5.0::FLOAT4, 8.0::FLOAT4, 3.0::FLOAT4, 4.0::FLOAT4) = 12.0::FLOAT4;
```

#### plperl_calculate_float4_logarithm_base2❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_logarithm_base2(value FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_logarithm_base2
# description: Calculates the base-2 logarithm of a given float4 number and returns the result as float4.
# type: float4
# input: The float4 number for which to calculate the base-2 logarithm
# output: The base-2 logarithm of the input float4 number

    elog(INFO, "[plperl_calculate_float4_logarithm_base2] Function called with value = " . value);
    if (value > 0) {
        my $result = log(value) / log(2);
        elog(INFO, "[plperl_calculate_float4_logarithm_base2] Result of base-2 logarithm: " . $result);
        return $result;
    } else {
        elog(WARNING, "[plperl_calculate_float4_logarithm_base2] Logarithm of a non-positive number is not defined.");
        return;
    }
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_float4_logarithm_base21', plperl_calculate_float4_logarithm_base2(8.0::FLOAT4) = 3.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_float4_logarithm_base22', plperl_calculate_float4_logarithm_base2(2.0::FLOAT4) = 1.0::FLOAT4;
```

#### plperl_calculate_float4_max_absolute_difference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_max_absolute_difference(input1 float4, input2 float4) RETURNS float4 AS $$
# name: calculate_float4_max_absolute_difference
# description: This function calculates the maximum absolute difference between two float4 values
# type: float4
# input: The first float4 input value
# input: The second float4 input value
# output: The maximum absolute difference as float4

    elog(INFO, "plperl_calculate_float4_max_absolute_difference function called with input1 = " . input1 . ", input2 = " . input2);
    my $abs_diff1 = abs(input1 - input2);
    my $abs_diff2 = abs(input2 - input1);
    my $max_diff = $abs_diff1 > $abs_diff2 ? $abs_diff1 : $abs_diff2;
    elog(INFO, "Result of plperl_calculate_float4_max_absolute_difference: " . $max_diff);
    return $max_diff;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_float4_max_absolute_difference1', plperl_calculate_float4_max_absolute_difference(5.5::FLOAT4, 3.0::FLOAT4) = 0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_float4_max_absolute_difference2', plperl_calculate_float4_max_absolute_difference(2.2::FLOAT4, 4.8::FLOAT4) = 2.6::FLOAT4;
```

#### plperl_calculate_float4_modulo❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_modulo(dividend float4, divisor float4) RETURNS float4 AS $$
# name: calculate_float4_modulo
# description: Calculates the modulo (the remainder of division) of two float4 values and returns the result as float4
# type: float4
# input: The number that is to be divided (dividend) as float4
# input: The number by which the dividend is to be divided (divisor) as float4
# output: The remainder of the division of the two float4 inputs

    elog(INFO, "plperl_calculate_float4_modulo function called with dividend = " . dividend . ", divisor = " . divisor);
    
    if ($divisor == 0) {
        elog(INFO, "Divisor is zero, skipping test case");
        return undef; # Or an appropriate handling mechanism for zero divisor
    }
    
    my $quotient = $dividend / $divisor;
    my $product = $quotient * $divisor;
    my $remainder = $dividend - $product;
    
    elog(INFO, "Result of plperl_calculate_float4_modulo: " . $remainder);
    return $remainder;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateFloat4Modulo1', plperl_calculate_float4_modulo(8.75::FLOAT4, 3.5::FLOAT4) = 1.75::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateFloat4Modulo2', plperl_calculate_float4_modulo(-5.25::FLOAT4, 2.0::FLOAT4) = -1.25::FLOAT4;
```

#### plperl_calculate_float4_percentage_change❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_percentage_change(old_value float4, new_value float4) RETURNS float4 AS $$
# name: calculate_float4_percentage_change
# description: Calculates the percentage change from float4 old_value to float4 new_value.
# type: float4
# input: The original float4 value
# input: The new float4 value to compare against the old value
# output: The percentage change as float4

    elog(INFO, "calculate_float4_percentage_change function called with old_value = " . $old_value . ", new_value = " . $new_value);
    if ((!defined $old_value) || ($old_value == 0)) {
        elog(ERROR, "old_value must be defined and not equal to zero to avoid division by zero.");
        return undef;
    }
    if (!defined $new_value) {
        $new_value = 0;
    }
    my $difference = $new_value - $old_value;
    my $percentage_change = ($difference / $old_value) * 100.0;
    elog(INFO, "Result of calculate_float4_percentage_change: " . $percentage_change);
    return $percentage_change;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateFloat4PercentageChangePositive', plperl_calculate_float4_percentage_change(50.0::FLOAT4, 75.0::FLOAT4) = 50.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateFloat4PercentageChangeNegative', plperl_calculate_float4_percentage_change(75.0::FLOAT4, 50.0::FLOAT4) = -33.3333::FLOAT4;
```

#### plperl_calculate_float4_precision✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_precision(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_precision
# description: Calculates the precision (number of decimal places) of a float4 number
# type: float4
# input: A float4 number to calculate the precision of
# output: The precision (number of decimal places) of the number as float4

    elog(INFO, "plperl_calculate_float4_precision function called with number = " . number);
    my $number_str = number . "";  # Convert float4 number to string
    my $decimal_point_pos = index($number_str, '.');
    my $precision;

    if ($decimal_point_pos == -1) {
        $precision = 0;  # No decimal point found
    } else {
        $precision = length($number_str) - $decimal_point_pos - 1;
    }

    elog(INFO, "Result of plperl_calculate_float4_precision: " . $precision);
    return $precision;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateFloat4Precision1', plperl_calculate_float4_precision(123.45::FLOAT4) = 0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateFloat4Precision2', plperl_calculate_float4_precision(456::FLOAT4) = 0.0::FLOAT4;
```

#### plperl_calculate_float4_quadratic_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_quadratic_sum(num1 float4, num2 float4, num3 float4) RETURNS float4 AS $$
# name: calculate_float4_quadratic_sum
# description: Calculates the sum of squares of three float4 numbers and returns the result as float4.
# type: float4
# input: First float4 number
# input: Second float4 number
# input: Third float4 number
# output: Sum of squares of num1, num2, and num3 as float4

    # Debugging
    elog(INFO, "calculate_float4_quadratic_sum function called with num1 = " . $num1 . ", num2 = " . $num2 . ", num3 = " . $num3);

    # Input validation
    unless (defined $num1) {
        $num1 = 0.0;
    }
    unless (defined $num2) {
        $num2 = 0.0;
    }
    unless (defined $num3) {
        $num3 = 0.0;
    }

    # Calculations
    my $result1 = $num1 * $num1;
    my $result2 = $num2 * $num2;
    my $result3 = $num3 * $num3;
    my $sum_of_squares = $result1 + $result2 + $result3;

    # Debugging
    elog(INFO, "Result of calculate_float4_quadratic_sum: " . $sum_of_squares);
    return $sum_of_squares;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_float4_quadratic_sum1', plperl_calculate_float4_quadratic_sum(3.0::FLOAT4, 4.0::FLOAT4, 5.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_float4_quadratic_sum2', plperl_calculate_float4_quadratic_sum(-3.0::FLOAT4, 4.0::FLOAT4, -5.0::FLOAT4) = 0::FLOAT4;

-- calculate_quadratic_roots
```

#### plperl_calculate_float4_quotient_and_product❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_quotient_and_product(value1 float4, value2 float4) RETURNS float4[] AS $$
# name: calculate_float4_quotient_and_product
# description: This function calculates both the quotient and the product of two float4 values and returns them as a float4 array.
# type: float4
# input: First float4 input value
# input: Second float4 input value, not equal to zero
# output: Array of float4 with the first element being the quotient and the second being the product of the inputs

    if ($value2 == 0) {
        elog(ERROR, "Second float4 input value (value2) must not be equal to zero.");
    }

    elog(INFO, "calculate_float4_quotient_and_product function called with value1 = " . $value1 . ", value2 = " . $value2);
    
    my @results = (0, 0); # Initialize the results array
    $results[0] = $value1 / $value2; # Assign quotient
    $results[1] = $value1 * $value2; # Assign product

    elog(INFO, "Quotient: $results[0], Product: $results[1]");
    return @results;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_float4_quotient_and_product_Positive', (plperl_calculate_float4_quotient_and_product(3.5::FLOAT4, 2.0::FLOAT4) = ARRAY[1.75::FLOAT4, 7.0::FLOAT4])::BOOLEAN;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_float4_quotient_and_product_NegByPos', (plperl_calculate_float4_quotient_and_product(-4.0::FLOAT4, 2.0::FLOAT4) = ARRAY[-2.0::FLOAT4, -8.0::FLOAT4])::BOOLEAN;
```

#### plperl_calculate_float4_ratio❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_ratio
# description: Calculates the ratio of two float4 numbers and returns the result as float4. Ratio is the result of dividing the first float4 value by the second, provided the second is not zero.
# type: float4
# input: The numerator for the ratio calculation. Type: float4
# input: The denominator for the ratio calculation. Type: float4. Must not be zero.
# output: The calculated ratio as float4. If the denominator is zero, the function will return 'undefined'.

  elog(INFO, "calculate_float4_ratio function called with numerator = " . numerator . ", denominator = " . denominator);
  if ($denominator == 0) {
    elog(INFO, "Denominator is zero, returning 'undefined'.");
    return 'undefined';
  } else {
    my $result = $numerator / $denominator;
    elog(INFO, "Result of calculate_float4_ratio: " . $result);
    return $result;
  }
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
-- SELECT 'plperl-float4', 'test_calculateFloat4Ratio1', 
--        (plperl_calculate_float4_ratio(25.0::FLOAT4, 5.0::FLOAT4) = 5.0::FLOAT4) AS RESULT;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
-- SELECT 'plperl-float4', 'test_calculateFloat4Ratio2', 
--        (plperl_calculate_float4_ratio(10.0::FLOAT4, 0.0::FLOAT4) = 'undefined') AS RESULT;
```

#### plperl_calculate_float4_ratio_and_sum❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_ratio_and_sum(number1 float4, number2 float4) RETURNS JSON AS $$
# name: calculate_float4_ratio_and_sum
# description: Calculates the ratio of two float4 numbers and their sum
# type: float4
# input: First float4 number
# input: Second float4 number, cannot be zero as it will be used as divisor
# output: An object with the ratio and sum of the two float4 numbers

    my ($number1, $number2) = @_;
    elog(INFO, "plperl_calculate_float4_ratio_and_sum function called with number1 = $number1, number2 = $number2");

    # Verify that number2 is not zero to prevent division by zero
    if ($number2 == 0) {
        die "Division by zero is not allowed.";
    }
    
    # Calculate the ratio and sum
    my $ratio = $number1 / $number2;
    my $sum = $number1 + $number2;

    # Create a result object
    my %result = (
        ratio => $ratio,
        sum   => $sum,
    );

    # Convert result object to JSON string
    require JSON;
    my $json = JSON->new->allow_nonref;
    my $json_string = $json->encode(\%result);

    elog(INFO, "Result of plperl_calculate_float4_ratio_and_sum: $json_string");
    
    # Return the result as a JSON string
    return $json_string;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_float4_ratio_and_sum_case1', plperl_calculate_float4_ratio_and_sum(6.0::FLOAT4, 3.0::FLOAT4) = '{"ratio": 2.0, "sum": 9.0}'::JSON;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_float4_ratio_and_sum_case2', plperl_calculate_float4_ratio_and_sum(-8.0::FLOAT4, 4.0::FLOAT4) = '{"ratio": -2.0, "sum": -4.0}'::JSON;
```

#### plperl_calculate_float4_remainder✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_remainder(dividend float4, divisor float4) RETURNS float4 AS $$
# name: calculate_float4_remainder
# description: Calculates the remainder of division between two float4 numbers
# type: float4
# input: float4 value representing the dividend
# input: float4 value representing the divisor
# output: float4 value representing the remainder of the division

    my ($dividend, $divisor) = @_;
    elog(INFO, "calculate_float4_remainder function called with dividend = " . $dividend . ", divisor = " . $divisor);
    if ($divisor == 0.0) {
        return undef;
    }
    my $remainder = $dividend % $divisor;
    elog(INFO, "Result of calculate_float4_remainder: " . ($remainder // 'undef'));
    return $remainder;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculateFloat4RemainderPositive', plperl_calculate_float4_remainder(5.0::FLOAT4, 2.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculateFloat4RemainderDivByZero', plperl_calculate_float4_remainder(5.0::FLOAT4, 0.0::FLOAT4) IS NULL;
```

#### plperl_calculate_float4_rounded_average✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_rounded_average(value1 float4, value2 float4) RETURNS float4 AS $$
# name: calculate_float4_rounded_average
# description: Calculate the average of two float4 values and round it to the nearest whole number, returning the result as a float4
# type: float4
# input: The first float4 value for the average calculation
# input: The second float4 value for the average calculation
# output: The rounded average of value1 and value2 as a float4

    elog(INFO, "plperl_calculate_float4_rounded_average function called with value1 = " . value1 . ", value2 = " . value2);
    my $average = ($value1 + $value2) / 2.0;
    my $rounded_average = sprintf('%.0f', $average);  # This line rounds to the nearest whole number
    elog(INFO, "Result of plperl_calculate_float4_rounded_average: " . $rounded_average);
    return $rounded_average;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_float4_rounded_average_test_case2', plperl_calculate_float4_rounded_average(-14.8::FLOAT4, 20.2::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_float4_rounded_average_test_case1', plperl_calculate_float4_rounded_average(25.4::FLOAT4, 34.6::FLOAT4) = 30.0::FLOAT4;

-- is_float4_in_decreasing_order
```

#### plperl_calculate_float4_to_power_of_integer✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_to_power_of_integer(float4_base FLOAT4, integer_exponent INTEGER) RETURNS FLOAT4 AS $$
# name: calculate_float4_to_power_of_integer
# description: This function takes a float4 base number and an integer exponent, then raises the base to the power of the exponent returning a float4 result
# type: float4
# input: float4 number serving as the base for the power operation
# input: Integer serving as the exponent for the power operation
# output: float4 result of the base raised to the power of the exponent

    elog(INFO, "Calling calculate_float4_to_power_of_integer with float4_base = " . $float4_base . ", integer_exponent = " . $integer_exponent);
    my $result = $float4_base ** $integer_exponent;
    elog(INFO, "Result of calculate_float4_to_power_of_integer: " . $result);
    return $result;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_float4_to_power_of_integer2', plperl_calculate_float4_to_power_of_integer(7.0::FLOAT4, 0) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_float4_to_power_of_integer1', plperl_calculate_float4_to_power_of_integer(2.5::FLOAT4, 3) = 15.625::FLOAT4;
```

#### plperl_calculate_float4_with_exponential_notation❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_float4_with_exponential_notation(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_with_exponential_notation
# description: Converts a float4 number in exponential notation to a float4 number in standard decimal notation
# type: float4
# input: float4 number in exponential notation
# output: float4 number in standard decimal notation

    elog(INFO, "calculate_float4_with_exponential_notation function called with number = " . number);
    my $result = number; # In Perl, conversion is implicit so no explicit conversion is necessary.
    elog(INFO, "Result of calculate_float4_with_exponential_notation: " . $result);
    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_float4_with_exponential_notation1', plperl_calculate_float4_with_exponential_notation(2.5e-4::FLOAT4) = 0.00025::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_float4_with_exponential_notation2', plperl_calculate_float4_with_exponential_notation(3.57e+2::FLOAT4) = 357.0::FLOAT4;
```

#### plperl_calculate_harmonic_mean❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_harmonic_mean(number1 FLOAT4, number2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_harmonic_mean
# description: Calculates the harmonic mean of two float4 numbers
# type: float4
# input: First float4 number
# input: Second float4 number
# output: Harmonic mean of the two float4 numbers as float4

    elog(INFO, "calculate_harmonic_mean function called with number1 = " . number1 . ", number2 = " . number2);
    if (number1 == 0 || number2 == 0) {
        return 'undefined';
    }
    my $reciprocal_sum = 1/number1 + 1/number2;
    my $result = 2 / $reciprocal_sum;
    elog(INFO, "Result of calculate_harmonic_mean: " . $result);
    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_harmonic_mean1', plperl_calculate_harmonic_mean(4.0::FLOAT4, 8.0::FLOAT4) = 5.3333334::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_harmonic_mean2', plperl_calculate_harmonic_mean(0.0::FLOAT4, 5.0::FLOAT4) = 'undefined';
```

#### plperl_calculate_hypotenuse❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_hypotenuse(a float4, b float4) RETURNS float4 AS $$
# name: calculate_hypotenuse
# description: Calculates the length of the hypotenuse of a right-angled triangle using the Pythagorean theorem
# type: float4
# input: length of side a as float4
# input: length of side b as float4
# output: length of the hypotenuse as float4

    elog(INFO, "calculate_hypotenuse function called with a = " . $a . ", b = " . $b);
    
    if (!defined $a) {
        elog(ERROR, "Input 'a' is undefined.");
    }
    if (!defined $b) {
        elog(ERROR, "Input 'b' is undefined.");
    }
    
    my $a_squared = $a ** 2;
    my $b_squared = $b ** 2;
    my $sum_of_squares = $a_squared + $b_squared;
    my $hypotenuse = sqrt($sum_of_squares);
    
    elog(INFO, "Result of calculate_hypotenuse: " . $hypotenuse);
    return $hypotenuse;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_hypotenuse1', plperl_calculate_hypotenuse(3.0::FLOAT4, 4.0::FLOAT4) = 5.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_hypotenuse2', plperl_calculate_hypotenuse(5.0::FLOAT4, 12.0::FLOAT4) = 13.0::FLOAT4;
```

#### plperl_calculate_inscribed_circle_area✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_inscribed_circle_area(side_length float4) RETURNS float4 AS $$
# name: calculate_inscribed_circle_area
# description: Calculates the area of an inscribed circle within a square where each side is of float4 type length.
# type: float4
# input: The length of the side of the square of type float4
# output: The area of the inscribed circle as float4

    my $radius = $side_length / 2;
    my $radius_squared = $radius ** 2;
    my $area = $radius_squared * 3.14159; # Approximation of PI

    elog(INFO, "plperl_calculate_inscribed_circle_area function called with side_length = " . $side_length);
    elog(INFO, "Calculated area of inscribed circle: " . $area);

    return $area;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_inscribed_circle_area1', plperl_calculate_inscribed_circle_area(0::float4) = (0::float4 / 2)^2 * pi();
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_inscribed_circle_area2', plperl_calculate_inscribed_circle_area(5.4::float4) = 22.90231::float4;
```

#### plperl_calculate_linear_intercept✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_linear_intercept(x1 FLOAT4, y1 FLOAT4, m FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_linear_intercept
# description: Calculates the y-intercept (b) of a linear equation in the form y = mx + b using a point (x1, y1) and the slope (m)
# type: float4
# input: float4 - the x-coordinate of the point
# input: float4 - the y-coordinate of the point
# input: float4 - the slope of the line
# output: float4 - the y-intercept of the line

    elog(INFO, "calculate_linear_intercept function called with x1 = " . $x1 . ", y1 = " . $y1 . ", m = " . $m);
    my $mx = $m * $x1;
    my $b = $y1 - $mx;
    elog(INFO, "Result of calculate_linear_intercept: " . $b);
    return $b;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_linear_intercept1', plperl_calculate_linear_intercept(3.0, 4.0, 2.0) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_linear_intercept2', plperl_calculate_linear_intercept(-1.0, -3.0, -2.0) = 0.0::FLOAT4;
```

#### plperl_calculate_linear_interpolation❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_linear_interpolation(value1 float4, value2 float4, fraction float4) RETURNS float4 AS $$
# name: calculate_linear_interpolation
# description: Interpolates between two float4 values at a specific increment
# type: float4
# input: starting float4 value for interpolation
# input: ending float4 value for interpolation
# input: the float4 fraction representing the interpolation point between value1 and value2
# output: interpolated float4 value

    elog(INFO, "calculate_linear_interpolation function called with value1 = " . value1 . ", value2 = " . value2 . ", fraction = " . fraction);
    
    if ( fraction < 0.0 || fraction > 1.0 ) {
        elog(ERROR, "Fraction must be between 0.0 and 1.0 inclusive");
    }
    
    my $difference = value2 - value1;
    my $result = value1 + ($difference * fraction);
    elog(INFO, "Result of calculate_linear_interpolation: " . $result);
    
    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_linear_interpolation_mid_range', plperl_calculate_linear_interpolation(10.75::FLOAT4, 20.5::FLOAT4, 0.5::FLOAT4) = 15.625::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_linear_interpolation_start_value', plperl_calculate_linear_interpolation(-5.0::FLOAT4, 5.0::FLOAT4, 0.1::FLOAT4) = -4.0::FLOAT4;
```

#### plperl_calculate_log_base_n❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_log_base_n(number FLOAT4, base FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_log_base_n
# description: Calculates the logarithm of a float4 number with a float4 custom base and returns the result as float4. Rejects a base that is less than or equal to 0, or equal to 1, and a number that is less than or equal to 0.
# type: float4
# input: Value to find the logarithm of. Must be greater than 0.
# input: Base of the logarithm. Must be greater than 0 and not equal to 1.
# output: Logarithm of the number to the base provided. If the base or number is invalid, the output is 'undefined'.

    # Debugging
    elog(INFO, "plperl_calculate_log_base_n called with number = " . number . " and base = " . base);

    # Check input conditions
    if (base <= 0 || base == 1 || number <= 0) {
        elog(INFO, "Base must be greater than 0 and not equal to 1; number must be greater than 0.");
        return 'undefined';
    }

    # Calculate the logarithm
    my $result = log(number) / log(base);

    # Debugging result
    elog(INFO, "Result of plperl_calculate_log_base_n: " . $result);

    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_log_base_n_valid', plperl_calculate_log_base_n(32.0::FLOAT4, 2.0::FLOAT4) = 5.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_log_base_n_invalid_base', plperl_calculate_log_base_n(100.0::FLOAT4, 1.0::FLOAT4)::TEXT = 'undefined';
```

#### plperl_calculate_logarithm✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_logarithm(number float4) RETURNS float4 AS $$
# name: calculate_logarithm
# description: Calculates the natural logarithm (base e) of a given float4 number and returns the result as float4. If the input is less than or equal to zero, the function will return 'undefined' since the logarithm for non-positive numbers is not defined in real numbers.
# type: float4
# input: The float4 number for which to find the natural logarithm
# output: The natural logarithm of the given float4 number as float4, or 'undefined' if the input is not a positive float4

    elog(INFO, "plperl_calculate_logarithm function called with number = " . number);
    if (number <= 0) {
        elog(INFO, "Input is not a positive float4, returning 'undefined'.");
        return 'undefined';
    }
    my $result = log(number);
    elog(INFO, "Result of plperl_calculate_logarithm: " . $result);
    return $result;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_logarithm_non_positive', (plperl_calculate_logarithm(-1.0::FLOAT4) IS NULL) AS RESULT;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_logarithm_positive', (plperl_calculate_logarithm(2.7183::FLOAT4) - 1.0::FLOAT4) < 0.0001;

-- is_float4_in_range
```

#### plperl_calculate_logarithm_base_ten❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_logarithm_base_ten(number float4) RETURNS float4 AS $$
# name: calculate_logarithm_base_ten
# description: Calculates the logarithm base 10 of a float4 number and returns the result as float4. It assumes positive non-zero input.
# type: float4
# input: The float4 number to calculate the logarithm base 10 of
# output: The float4 result of the logarithm base 10 calculation

    # Debugging message
    elog(INFO, "calculate_logarithm_base_ten function called with number = " . number);
    
    # Input condition check
    if (number <= 0) {
        elog(WARNING, "Input number must be greater than zero.");
        return undef;
    }
    
    # Calculation
    my $result = log(number) / log(10); # log is natural logarithm in Perl, so we need to convert it

    # Debugging message
    elog(INFO, "Result of calculate_logarithm_base_ten: " . $result);
    
    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateLogarithmBaseTen1', plperl_calculate_logarithm_base_ten(100.0::FLOAT4) = 2.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateLogarithmBaseTen2', plperl_calculate_logarithm_base_ten(1000.0::FLOAT4) = 3.0::FLOAT4;
```

#### plperl_calculate_median_of_two_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_median_of_two_float4(input1 float4, input2 float4) RETURNS float4 AS $$
# name: calculate_median_of_two_float4
# description: Calculates the median of two float4 numbers and returns the result as float4
# type: float4
# input: First float4 input value
# input: Second float4 input value
# output: Median of input1 and input2 as float4

    use strict;
    use warnings;
    # Debugging message
    elog(INFO, "plperl_calculate_median_of_two_float4 function called with input1 = " . $_[0] . ", input2 = " . $_[1]);
    my $input1 = $_[0];
    my $input2 = $_[1];
    my $median = 0;
    if ($input1 == $input2) {
        $median = $input1;
    } else {
        $median = ($input1 + $input2) / 2;
    }
    # Debugging message
    elog(INFO, "Result of plperl_calculate_median_of_two_float4: " . $median);
    return $median;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculateMedianOfTwoFloat4Identical', plperl_calculate_median_of_two_float4(10.0::FLOAT4, 10.0::FLOAT4) = 10.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculateMedianOfTwoFloat4Different', plperl_calculate_median_of_two_float4(10.0::FLOAT4, 20.0::FLOAT4) = 15.0::FLOAT4;
```

#### plperl_calculate_percentage_difference❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_percentage_difference(value1 float4, value2 float4) RETURNS float4 AS $$
# name: calculate_percentage_difference
# description: Calculates the percentage difference between two float4 values
# type: float4
# input: First float4 value
# input: Second float4 value
# output: Percentage difference as float4

    # Debugging: log the function call with the input values
    elog(INFO, "calculate_percentage_difference function called with value1 = " . value1 . ", value2 = " . value2);

    # Calculate the absolute difference
    my $absolute_difference = abs(value1 - value2);
    
    # Calculate the average of the values
    my $average_value = ($value1 + $value2) / 2;

    # Calculate the percentage difference
    my $percentage_difference = ($absolute_difference / $average_value) * 100;

    # Debugging: log the calculated percentage difference before returning
    elog(INFO, "Percentage difference calculated: " . $percentage_difference);

    return $percentage_difference;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_percentage_difference1', plperl_calculate_percentage_difference(150.0::float4, 100.0::float4) = 40.0::float4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_percentage_difference2', plperl_calculate_percentage_difference(75.0::float4, 125.0::float4) = 50.0::float4;
```

#### plperl_calculate_product_of_float4❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_product_of_float4(number1 float4, number2 float4) RETURNS float4 AS $$
# name: calculate_product_of_float4
# description: Calculates the product of two float4 numbers and returns the result as a float4
# type: float4
# input: The first float4 number to be multiplied
# input: The second float4 number to be multiplied
# output: The product of the two float4 inputs as a float4

    elog(INFO, "calculate_product_of_float4 function called with number1 = " . number1 . ", number2 = " . number2);
    # Store the first float4 input in a variable 'num1'
    my $num1 = $number1;
    # Store the second float4 input in a variable 'num2'
    my $num2 = $number2;
    # Multiply 'num1' by 'num2' and store the result in variable 'product'
    my $product = $num1 * $num2;
    elog(INFO, "Result of calculate_product_of_float4: " . $product);
    # Return the 'product' as a float4
    return $product;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_product_of_float41', plperl_calculate_product_of_float4(3.14::FLOAT4, 1.59::FLOAT4) = 4.9916::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_product_of_float42', plperl_calculate_product_of_float4(-5.0::FLOAT4, 2.5::FLOAT4) = -12.5::FLOAT4;
```

#### plperl_calculate_quadratic_roots❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_quadratic_roots(a float4, b float4, c float4) RETURNS float4[] AS $$
# name: calculate_quadratic_roots
# description: Calculates the roots of a quadratic equation ax^2 + bx + c = 0 using the quadratic formula and returns them as an array of float4
# type: float4
# input: float4 coefficient for x^2
# input: float4 coefficient for x
# input: float4 constant term
# output: array of float4 containing the two roots

    # Display input arguments for debugging
    elog(INFO, "calculate_quadratic_roots function called with a = " . a . ", b = " . b . ", c = " . c);

    # Calculate the discriminant
    my $discriminant = b**2 - 4 * a * c;

    # Initialize array to store the roots
    my @roots = ();

    # Check if the discriminant is negative
    if ($discriminant < 0) {
        elog(INFO, "Discriminant is negative. No real roots.");
        return \@roots;
    }

    # Calculate the two roots if discriminant is zero or positive
    my $sqrt_discriminant = sqrt($discriminant);
    my $denominator = 2 * a;

    # Calculate root 1
    my $root1 = (-$b + $sqrt_discriminant) / $denominator;

    # If the discriminant is zero, add only one root to the array
    if ($discriminant == 0) {
        push @roots, $root1;
    } else {
        # Calculate root 2 and add both roots to the array
        my $root2 = (-$b - $sqrt_discriminant) / $denominator;
        push @roots, $root1, $root2;
    }

    # Log and return roots
    elog(INFO, "Calculated roots: " . join(", ", @roots));
    return \@roots;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_quadratic_roots_real_roots', ARRAY[3, 2] = plperl_calculate_quadratic_roots(1::FLOAT4, -5::FLOAT4, 6::FLOAT4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_quadratic_roots_one_root', ARRAY[2] = plperl_calculate_quadratic_roots(1::FLOAT4, -4::FLOAT4, 4::FLOAT4);
```

#### plperl_calculate_scaled_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_scaled_value(value float4, factor float4) RETURNS float4 AS $$
# name: calculate_scaled_value
# description: This function takes an input float4 value and scales it by a given float4 factor.
# type: float4
# input: The original float4 value to be scaled
# input: The float4 factor by which to scale the value
# output: The scaled float4 value

    elog(INFO, "calculate_scaled_value function called with value = " . value . ", factor = " . factor);
    my $scaled_value = value * factor;
    elog(INFO, "Result of calculate_scaled_value: " . $scaled_value);
    return $scaled_value;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_scaled_value2', plperl_calculate_scaled_value(3.0::FLOAT4, 0.5::FLOAT4) = 0;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_scaled_value1', plperl_calculate_scaled_value(1.5::FLOAT4, 2.0::FLOAT4) = 3.0::FLOAT4;
```

#### plperl_calculate_sin✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_sin(angle float4) RETURNS float4 AS $$
# name: calculate_sin
# description: Calculates the sine of a float4 angle value (in radians) and returns the result as float4
# type: float4
# input: float4 angle in radians for which the sine will be calculated
# output: float4 representing the sine of the input angle

    elog(INFO, "plperl_calculate_sin function called with angle (radians) = " . angle);

    # If the input angle is in degrees, we would convert it to radians using angle * PI / 180,
    # but since the input is already in radians according to the pseudocode, we use it directly.

    my $result = sin(angle);

    # Ensure the output is a float4 value
    $result = 0 + sprintf("%.4f", $result);

    elog(INFO, "Result of plperl_calculate_sin: " . $result);
    return $result;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateSinZero', plperl_calculate_sin(0.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculateSinPIOver2', plperl_calculate_sin(1.5708::FLOAT4) = 1.0::FLOAT4;
```

#### plperl_calculate_slope❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_slope(point1 float4[], point2 float4[]) RETURNS float4 AS $$
# name: calculate_slope
# description: Calculates the slope of a line passing through two points in the Cartesian coordinate system
# type: float4
# input: Coordinates (x1, y1) of the first point, type float4 array
# input: Coordinates (x2, y2) of the second point, type float4 array
# output: The slope of the line as float4

    my ($x1, $y1) = @{$point1};
    my ($x2, $y2) = @{$point2};
    
    elog(INFO, "calculate_slope function called with point1: (" . join(", ", @{$point1}) . "), point2: (" . join(", ", @{$point2}) . ")");
    
    if ((scalar @{$point1} != 2) || (scalar @{$point2} != 2)) {
        elog(ERROR, "Input arrays must contain exactly two elements.");
    }
    
    my $deltaY = $y2 - $y1;
    my $deltaX = $x2 - $x1;
    
    if ($deltaX == 0) {
        elog(INFO, "The line is vertical, slope is undefined");
        return "undefined";
    }
    
    my $slope = $deltaY / $deltaX;
    
    elog(INFO, "Calculated slope: " . $slope);
    return $slope;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_slope1', plperl_calculate_slope(ARRAY[1.0, 2.0]::float4[], ARRAY[3.0, 3.0]::float4[]) = 0.5::float4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'calculate_slope2', plperl_calculate_slope(ARRAY[4.0, 1.0]::float4[], ARRAY[4.0, 3.0]::float4[]) = 'undefined';
```

#### plperl_calculate_thermal_expansion❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_thermal_expansion(original_length FLOAT4, temperature_change FLOAT4, coefficient_of_expansion FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_thermal_expansion
# description: Calculates the linear thermal expansion of a material given its original length, temperature change, and the material's coefficient of linear expansion
# type: float4
# input: the original length of the material before thermal expansion (float4)
# input: the change in temperature that the material undergoes (float4)
# input: the coefficient of linear expansion of the material (float4)
# output: the new length of the material after thermal expansion (float4)

    elog(INFO, "calculate_thermal_expansion function called with original_length = " . original_length . ", temperature_change = " . temperature_change . ", coefficient_of_expansion = " . coefficient_of_expansion);

    my $expansion = original_length * temperature_change * coefficient_of_expansion;
    my $new_length = original_length + $expansion;

    elog(INFO, "Result of calculate_thermal_expansion: " . $new_length);
    return $new_length;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT)
-- SELECT 'plperl-float4', 'test_calculate_thermal_expansion_small_change', plperl_calculate_thermal_expansion(10.0::FLOAT4, 0.0005::FLOAT4, 0.000012::FLOAT4) = 10.00006::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT)
-- SELECT 'plperl-float4', 'test_calculate_thermal_expansion_large_change', plperl_calculate_thermal_expansion(5.0::FLOAT4, 0.05::FLOAT4, 0.000015::FLOAT4) = 5.0000375::FLOAT4;
```

#### plperl_calculate_weight_force✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_calculate_weight_force(mass FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_weight_force
# description: Calculates the force due to weight of an object using the formula F = m * g, where m is mass in kilograms, and g is acceleration due to gravity at 9.81 m/s^2 (represented as float4)
# type: float4
# input: mass of the object as float4
# output: the weight force as float4

    # Constant for acceleration due to gravity in m/s^2
    my $acceleration_due_to_gravity = 9.81;
    # Debugging statement
    elog(INFO, "plperl_calculate_weight_force function called with mass = " . mass);
    
    # Check if the input is defined
    if (not defined mass) {
        elog(ERROR, "plperl_calculate_weight_force requires a defined mass value.");
        return undef;
    }
    
    # Calculate the weight force
    my $weight_force = mass * $acceleration_due_to_gravity;
    
    # Debugging statement
    elog(INFO, "Result of plperl_calculate_weight_force: " . $weight_force);
    
    return $weight_force;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_weight_force1', plperl_calculate_weight_force(0.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_calculate_weight_force2', plperl_calculate_weight_force(5.5::FLOAT4) = 53.955::FLOAT4;
```

#### plperl_check_float4_equality✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_check_float4_equality(input1 float4, input2 float4) RETURNS bool AS $$
# name: check_float4_equality
# description: Checks whether two float4 values are equal
# type: float4
# input: First float4 value to be compared
# input: Second float4 value to be compared
# output: Boolean result determining if the two float4 values are equal

    elog(INFO, "check_float4_equality function called with input1 = " . input1 . ", input2 = " . input2);
    my $result = (input1 == input2) ? 'true' : 'false';
    elog(INFO, "Result of check_float4_equality: " . $result);
    return $result;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'check_float4_equality_equal', plperl_check_float4_equality(4.0000::FLOAT4, 4.0000::FLOAT4) = 'true';
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'check_float4_equality_different', plperl_check_float4_equality(4.0000::FLOAT4, 4.0000::FLOAT4) = 'true';
```

#### plperl_check_float4_is_positive✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_check_float4_is_positive(number FLOAT4) RETURNS FLOAT4 AS $$
# name: check_float4_is_positive
# description: Determines if a float4 input is positive
# type: float4
# input: The float4 number to check
# output: A float4 representing a boolean true or false, 1.0 for true and 0.0 for false

    elog(INFO, "check_float4_is_positive function called with number = " . number);
    my $result = number > 0.0 ? 1.0 : 0.0;
    elog(INFO, "Result of check_float4_is_positive: " . $result);
    return $result;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'check_float4_is_positive_negative', plperl_check_float4_is_positive(-0.1::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'check_float4_is_positive_positive', plperl_check_float4_is_positive(0.1::FLOAT4) = 1.0::FLOAT4;
```

#### plperl_check_float4_within_bounds✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_check_float4_within_bounds(value FLOAT4, lower_bound FLOAT4, upper_bound FLOAT4) RETURNS FLOAT4 AS $$
# name: check_float4_within_bounds
# description: Determines whether a float4 value is between two boundary float4 values (exclusive)
# type: float4
# input: the float4 value to check
# input: the lower float4 boundary
# input: the upper float4 boundary
# output: boolean represented as float4 (1.0 for true, 0.0 for false)

    elog(INFO, "check_float4_within_bounds function called with value = " . value . ", lower_bound = " . lower_bound . ", upper_bound = " . upper_bound);
    if ((value > lower_bound) && (value < upper_bound)) {
        elog(INFO, "Result of check_float4_within_bounds: 1.0 (value is within bounds)");
        return 1.0;
    } else {
        elog(INFO, "Result of check_float4_within_bounds: 0.0 (value is outside bounds)");
        return 0.0;
    }
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'check_float4_within_bounds_outside', plperl_check_float4_within_bounds(-3.14::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'check_float4_within_bounds_within', plperl_check_float4_within_bounds(5.75::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 1.0::FLOAT4;

-- calculate_logarithm
```

#### plperl_check_float4_within_tolerance✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_check_float4_within_tolerance(float4_num1 float4, float4_num2 float4, tolerance float4) RETURNS boolean AS $$
# name: check_float4_within_tolerance
# description: Checks if two float4 numbers are within a specified tolerance
# type: float4
# input: First float4 number to compare
# input: Second float4 number to compare
# input: The float4 tolerance within which the two numbers are considered equal
# output: Boolean float4 indicating if the numbers are within the tolerance

    my ($float4_num1, $float4_num2, $tolerance) = @_;
    elog(INFO, "check_float4_within_tolerance function called with float4_num1 = $float4_num1, float4_num2 = $float4_num2, tolerance = $tolerance");

    my $within_tolerance = 'false';
    my $difference = abs($float4_num1 - $float4_num2);

    if ($difference <= $tolerance) {
        $within_tolerance = 'true';
    }

    elog(INFO, "Result of check_float4_within_tolerance: $within_tolerance");
    return $within_tolerance;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'check_float4_within_tolerance_within', plperl_check_float4_within_tolerance(100.0::FLOAT4, 100.05::FLOAT4, 0.1::FLOAT4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'check_float4_within_tolerance_not_within', NOT plperl_check_float4_within_tolerance(200.0::FLOAT4, 200.2::FLOAT4, 0.1::FLOAT4);
```

#### plperl_clamp_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_clamp_value(value float4, min_value float4, max_value float4) RETURNS float4 AS $$
# name: clamp_value
# description: Clamps a given float4 value between a minimum and maximum float4 range
# type: float4
# input: The float4 value to be clamped
# input: The minimum float4 value in the range
# input: The maximum float4 value in the range
# output: The clamped float4 value

    my ($value, $min_value, $max_value) = @_;
    elog(INFO, "clamp_value function called with value = " . $value . ", min_value = " . $min_value . ", max_value = " . $max_value);
    if (not defined $value or not defined $min_value or not defined $max_value) {
        elog(ERROR, "undefined arguments are not allowed");
    }
    my $clamped_value;
    if ($value < $min_value) {
        $clamped_value = $min_value;
    } elsif ($value > $max_value) {
        $clamped_value = $max_value;
    } else {
        $clamped_value = $value;
    }
    elog(INFO, "Returning clamped_value: " . $clamped_value);
    return $clamped_value;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'clamp_value_LessThanMinimum', plperl_clamp_value(2.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'clamp_value_WithinRange', plperl_clamp_value(4.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 4.5::FLOAT4;

-- calculate_float4_with_exponential_notation
```

#### plperl_combine_second_third_power✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_combine_second_third_power(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
# name: combine_second_third_power
# description: Combines the second power of the first float4 input with the third power of the second float4 input by adding them together.
# type: float4
# input: The first float4 input for which the second power is calculated
# input: The second float4 input for which the third power is calculated
# output: The result of adding the second power of input1 and the third power of input2, returned as float4

    elog(INFO, "combine_second_third_power function called with input1 = " . input1 . ", input2 = " . input2);

    my $second_power = input1 ** 2;
    my $third_power = input2 ** 3;

    my $result = $second_power + $third_power;
    elog(INFO, "Result of combine_second_third_power: " . $result);
    
    return $result;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'combineSecondThirdPowerMixed', plperl_combine_second_third_power(-1.5::FLOAT4, 3.0::FLOAT4) = 0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'combineSecondThirdPowerPositive', plperl_combine_second_third_power(4.0::FLOAT4, 2.0::FLOAT4) = 24.0::FLOAT4;

-- is_float4_zero
```

#### plperl_compare_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_compare_float4_values(value1 float4, value2 float4) RETURNS float4 AS $$
# name: compare_float4_values
# description: Compares two float4 values and determines if the first is greater than the second.
# type: float4
# input: First float4 value for comparison
# input: Second float4 value for comparison
# output: Boolean represented as float4 (1.0 for true, 0.0 for false)

    elog(INFO, "compare_float4_values function called with value1 = " . value1 . ", value2 = " . value2);
    my $result = 0.0;
    if ($value1 > $value2) {
        $result = 1.0;
    }
    elog(INFO, "Result of compare_float4_values: " . $result);
    return $result;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'compareFloat4ValuesCase1', (plperl_compare_float4_values(3.5::FLOAT4, 2.7::FLOAT4) = 0.0);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'compareFloat4ValuesCase2', plperl_compare_float4_values(1.4::FLOAT4, 1.8::FLOAT4) = 0.0::FLOAT4;
```

#### plperl_compute_circle_area✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_compute_circle_area(radius float4) RETURNS float4 AS $$
# name: compute_circle_area
# description: This function calculates the area of a circle given the radius as a float4 type.
# type: float4
# input: The radius of the circle as a float4
# output: The area of the circle as a float4

    elog(INFO, "plperl_compute_circle_area function called with radius = " . $_[0]);
    my $pi = 3.14159;
    my $area = $pi * $_[0] * $_[0];
    elog(INFO, "Result of plperl_compute_circle_area: " . $area);
    return $area;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_compute_circle_area_small_radius', ROUND(CAST(plperl_compute_circle_area(2.5::FLOAT4) AS NUMERIC), 4) = ROUND(19.6349::NUMERIC, 4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_compute_circle_area_large_radius', plperl_compute_circle_area(100.0::FLOAT4) = 31415.9::FLOAT4;
```

#### plperl_compute_float4_quotient_and_remainder❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_compute_float4_quotient_and_remainder(dividend FLOAT4, divisor FLOAT4) RETURNS JSON AS $$
# name: compute_float4_quotient_and_remainder
# description: Compute the quotient and remainder of the division of two float4 numbers
# type: float4
# input: The float4 number being divided
# input: The float4 number by which the dividend is divided
# output: A JSON object with float4 quotient and remainder

    my ($dividend, $divisor) = @_;
    elog(INFO, "compute_float4_quotient_and_remainder function called with dividend = " . $dividend . ", divisor = " . $divisor);
    
    if ($divisor == 0) {
        elog(ERROR, "Division by zero attempted in compute_float4_quotient_and_remainder.");
    }

    my $quotient = $dividend / $divisor;
    my $remainder = $dividend - ($quotient * $divisor);
    my $result = encode_json({ quotient => $quotient, remainder => $remainder });

    elog(INFO, "Result of compute_float4_quotient_and_remainder: " . $result);
    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 
--     'compute_float4_quotient_and_remainder1', 
--     plperl_compute_float4_quotient_and_remainder(8.75::FLOAT4, 2.50::FLOAT4)::JSON = '{"quotient":3.5,"remainder":1.25}'::JSON;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 
--     'compute_float4_quotient_and_remainder2', 
--     plperl_compute_float4_quotient_and_remainder(-5.5::FLOAT4, 2.2::FLOAT4)::JSON = '{"quotient":-2.5,"remainder":-0.9}'::JSON;
```

#### plperl_compute_square_root✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_compute_square_root(input_number float4) RETURNS float4 AS $$
# name: compute_square_root
# description: Computes the square root of a given float4 input and returns the result as float4
# type: float4
# input: The float4 number to compute the square root of
# output: The float4 square root of the input number

    elog(INFO, "plperl_compute_square_root function called with input_number = " . input_number);

    if (input_number < 0) {
        die "Square root of negative number is not real";
    }
    if (input_number == 0) {
        elog(INFO, "The square root of zero is zero");
        return 0;
    }

    my $result = sqrt(input_number);
    elog(INFO, "The square root of input_number = " . $result);
    return $result;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'compute_square_root_positive', plperl_compute_square_root(0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'compute_square_root_zero', plperl_compute_square_root(0.0::FLOAT4) = 0.0::FLOAT4;
```

#### plperl_compute_tangent✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_compute_tangent(angle_in_radians FLOAT4) RETURNS FLOAT4 AS $$
# name: compute_tangent
# description: Computes the tangent of a float4 angle value in radians and returns the result as float4
# type: float4
# input: The angle in radians for which to compute the tangent, as a float4
# output: The tangent of the angle as float4

    my $PI = 3.141592653589793;
    my $undefined_tolerance = 0.00001;
    elog(INFO, "plperl_compute_tangent function called with angle_in_radians = " . angle_in_radians);
    
    if (abs(angle_in_radians - $PI/2) < $undefined_tolerance || abs(angle_in_radians - 3*$PI/2) < $undefined_tolerance) {
        elog(ERROR, "Tangent is undefined at PI/2 and 3*PI/2");
        return 'NaN';
    } else {
        my $tangent = sin(angle_in_radians) / cos(angle_in_radians);
        elog(INFO, "Result of plperl_compute_tangent: " . $tangent);
        return $tangent;
    }
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_compute_tangent_zero', plperl_compute_tangent(0.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_compute_tangent_PI_div_4', plperl_compute_tangent(0.785398163::FLOAT4) = 1.0::FLOAT4;

-- calculate_slope
```

#### plperl_convert_float4_to_negative❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_convert_float4_to_negative(number float4) RETURNS float4 AS $$
# name: convert_float4_to_negative
# description: This function converts a float4 number to its negative equivalent.
# type: float4
# input: float4 number to be negated
# output: The negative equivalent of the input as float4

    elog(INFO, "convert_float4_to_negative function called with number = " . number);
    my $negated_number;
    if (number < 0) {
        $negated_number = number;
    } else {
        $negated_number = number * -1;
    }
    elog(INFO, "Result of convert_float4_to_negative: " . $negated_number);
    return $negated_number;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'convert_float4_to_negative_positive_value', plperl_convert_float4_to_negative(3.5::FLOAT4) = -3.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'convert_float4_to_negative_negative_value', plperl_convert_float4_to_negative(-2.0::FLOAT4) = -2.0::FLOAT4;
```

#### plperl_convert_to_radians❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_convert_to_radians(degrees FLOAT4) RETURNS FLOAT4 AS $$
# name: convert_to_radians
# description: Converts an angle in degrees to radians
# type: float4
# input: The angle in degrees to be converted to radians as float4
# output: The angle in radians as float4

    my $PI = 3.1415927;
    elog(INFO, "convert_to_radians function called with degrees = " . $degrees);
    unless (defined $degrees) {
        elog(ERROR, "Input degrees are not defined");
        return;
    }
    my $radians = ($degrees * $PI) / 180.0;
    elog(INFO, "Result of convert_to_radians: " . $radians);
    return $radians;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_convert_to_radians1', plperl_convert_to_radians(0.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_convert_to_radians2', plperl_convert_to_radians(180.0::FLOAT4) = 3.1415927::FLOAT4;
```

#### plperl_find_nearest_multiple_float4❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_find_nearest_multiple_float4(number float4, divisor float4) RETURNS float4 AS $$
# name: find_nearest_multiple_float4
# description: Finds the nearest multiple of a divisor close to the given float4 number
# type: float4
# input: The original float4 value for which the nearest multiple is to be found
# input: The divisor float4 value whose multiple is to be found nearest to the number
# output: The nearest multiple of the divisor float4 value to the original number as float4

    # Debugging info
    elog(INFO, "DEBUG: FUNCTION plperl_find_nearest_multiple_float4 - Running with inputs 'number' = " . $number . ", 'divisor' = " . $divisor);
    
    # Input validation
    if (!defined $number || !defined $divisor) {
        elog(ERROR, "Function requires both 'number' and 'divisor' to be defined.");
        return;
    }
    
    # Instructions
    my $quotient = $number / $divisor;
    my $rounded_quotient = sprintf("%.0f", $quotient);
    my $nearest_multiple = $rounded_quotient * $divisor;
    
    # Debugging info
    elog(INFO, "DEBUG: FUNCTION plperl_find_nearest_multiple_float4 - The nearest multiple found is: " . $nearest_multiple);
    
    return $nearest_multiple;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'find_nearest_multiple_float4_case1', plperl_find_nearest_multiple_float4(14.2::FLOAT4, 5.0::FLOAT4) = 15.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'find_nearest_multiple_float4_case2', plperl_find_nearest_multiple_float4(7.7::FLOAT4, 3.5::FLOAT4) = 7.0::FLOAT4;
```

#### plperl_float4_absolute_value_test❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_float4_absolute_value_test(number float4) RETURNS float4 AS $$
# name: float4_absolute_value_test
# description: Function to compute the absolute value of a float4 number
# type: float4
# input: A float4 value representing the number to find the absolute value for
# output: float4 absolute value of the input number

    elog(INFO, "float4_absolute_value_test function called with number = " . number);
    my $abs_value;
    if ($number < 0) {
        $abs_value = $number * -1;
    } else {
        $abs_value = $number;
    }
    elog(INFO, "Result of float4_absolute_value_test: " . $abs_value);
    return $abs_value;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'float4_absolute_value_test_negative', plperl_float4_absolute_value_test(-123.45::FLOAT4) = 123.45::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'float4_absolute_value_test_positive', plperl_float4_absolute_value_test(678.9::FLOAT4) = 678.9::FLOAT4;
```

#### plperl_float4_min_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_float4_min_value(number1 float4, number2 float4) RETURNS float4 AS $$
# name: float4_min_value
# description: Finds the minimum value between two float4 numbers
# type: float4
# input: First float4 number for comparison
# input: Second float4 number for comparison
# output: Returns the minimum value as float4

    elog(INFO, "float4_min_value function called with number1 = " . $_[0] . ", number2 = " . $_[1]);
    my $min_value = $_[0];
    if ($_[1] < $min_value) {
        $min_value = $_[1];
    }
    elog(INFO, "Result of float4_min_value: " . $min_value);
    return $min_value;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'float4_min_value_positive_numbers', plperl_float4_min_value(3.5::float4, 7.25::float4) = 3.5::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'float4_min_value_negative_and_positive', plperl_float4_min_value(-2.0::FLOAT4, 4.75::FLOAT4) = -2.0::FLOAT4;
```

#### plperl_is_float4_in_decreasing_order❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_is_float4_in_decreasing_order(number1 float4, number2 float4) RETURNS bool AS $$
# name: is_float4_in_decreasing_order
# description: Determines if the provided float4 numbers are in strictly decreasing order
# type: float4
# input: First number of type float4
# input: Second number of type float4
# output: Result of type boolean, true if number1 > number2, false otherwise

    elog(INFO, "is_float4_in_decreasing_order function called with number1 = " . $number1 . ", number2 = " . $number2);
    my $result = ($number1 > $number2);
    elog(INFO, "Result of is_float4_in_decreasing_order: " . $result);
    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'is_float4_in_decreasing_order_test1', plperl_is_float4_in_decreasing_order(6.5::FLOAT4, 3.24::FLOAT4) = TRUE;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'is_float4_in_decreasing_order_test2', plperl_is_float4_in_decreasing_order(5.5::FLOAT4, 5.5::FLOAT4) = FALSE;
```

#### plperl_is_float4_in_range✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_is_float4_in_range(value float4, min_value float4, max_value float4) RETURNS bool AS $$
# name: is_float4_in_range
# description: Determines if a float4 value falls within a specified inclusive range, defined by a minimum and maximum float4 value.
# type: float4
# input: The float4 value to check
# input: The inclusive minimum value of the range as float4
# input: The inclusive maximum value of the range as float4
# output: Returns true if the value is within the range, otherwise false

    elog(INFO, "is_float4_in_range function called with value = " . value . ", min_value = " . min_value . ", max_value = " . max_value);
    my $result = ($value >= $min_value && $value <= $max_value) ? 1 : 0;
    elog(INFO, "Result of is_float4_in_range: " . ($result ? 'true' : 'false'));
    return $result;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'is_float4_in_range_within', plperl_is_float4_in_range(3.5::FLOAT4, 1.0::FLOAT4, 5.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'is_float4_in_range_outside', plperl_is_float4_in_range(6.5::FLOAT4, 1.0::FLOAT4, 5.0::FLOAT4) = TRUE;
```

#### plperl_is_float4_zero✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_is_float4_zero(number float4) RETURNS boolean AS $$
# name: is_float4_zero
# description: Checks if the provided float4 number is zero
# type: float4
# input: the input float4 number to check
# output: returns true if number is 0.0, false otherwise

    elog(INFO, "is_float4_zero function called with number = " . number);
    my $threshold = 0.0001;
    if (abs(number) <= $threshold) {
        elog(INFO, "Result of is_float4_zero: true");
        return TRUE;
    } else {
        elog(INFO, "Result of is_float4_zero: false");
        return FALSE;
    }
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'is_float4_zero1', plperl_is_float4_zero(0.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'is_float4_zero2', plperl_is_float4_zero(0.00001::FLOAT4) = TRUE;
```

#### plperl_is_negative✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_is_negative(number float4) RETURNS boolean AS $$
# name: is_negative
# description: Determines if a float4 value is negative
# type: float4
# input: the float4 number to check
# output: boolean indicating if the number is negative

    elog(INFO, "plperl_is_negative function called with number = " . number);
    my $result = (number < 0) ? 1 : 0; # in Perl, a true value is represented by 1
    elog(INFO, "Result of plperl_is_negative: " . $result);
    return $result;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_is_negative1', plperl_is_negative(-3.14::float4) = FALSE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_is_negative2', plperl_is_negative(6.28::float4) = FALSE;
```

#### plperl_normalize_float4_value❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_normalize_float4_value(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS FLOAT4 AS $$
# name: normalize_float4_value
# description: Normalize a float4 number to the range of 0 to 1 based on provided minimum and maximum values
# type: float4
# input: the float4 number to normalize
# input: the minimum float4 value of the range
# input: the maximum float4 value of the range
# output: the normalized float4 number

    elog(INFO, "normalize_float4_value function called with value = " . value . ", min_value = " . min_value . ", max_value = " . max_value);
    if (min_value >= max_value) {
        elog(ERROR, "min_value must be less than max_value");
    }
    my $distance = value - min_value;
    my $range_size = max_value - min_value;
    my $normalized_value = $distance / $range_size;
    elog(INFO, "Normalized float4 value: " . $normalized_value);
    return $normalized_value;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'normalize_float4_value_within_range', plperl_normalize_float4_value(10.0::FLOAT4, 0.0::FLOAT4, 20.0::FLOAT4) = 0.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'normalize_float4_value_at_top_of_range', plperl_normalize_float4_value(20.0::FLOAT4, 10.0::FLOAT4, 20.0::FLOAT4) = 1.0::FLOAT4;
```

#### plperl_subtract_float4_values❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_subtract_float4_values(value1 float4, value2 float4) RETURNS float4 AS $$
# name: subtract_float4_values
# description: Subtracts the second float4 value from the first and returns the result as float4
# type: float4
# input: First float4 value to be used in subtraction
# input: Second float4 value to subtract from the first value
# output: Result of subtraction as float4

    elog(INFO, "subtract_float4_values function called with value1 = " . value1 . ", value2 = " . value2);
    my $result = value1 - value2;
    elog(INFO, "Result of subtract_float4_values: " . $result);
    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_subtractFloat4ValuesPositive', plperl_subtract_float4_values(5.7::FLOAT4, 2.3::FLOAT4) = 3.4::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_subtractFloat4ValuesNegByPos', plperl_subtract_float4_values(-1.2::FLOAT4, 4.6::FLOAT4) = -5.8::FLOAT4;
```

#### plperl_test_cosine_float4❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_test_cosine_float4(angle float4) RETURNS float4 AS $$
# name: test_cosine_float4
# description: Calculates the cosine of a float4 angle value in radians and returns the result as float4
# type: float4
# input: Angle in radians for which the cosine has to be calculated (float4)
# output: The cosine of the provided angle (float4)

    elog(INFO, "test_cosine_float4 function called with angle = " . angle);
    if (!defined $angle) {
        elog(ERROR, "Input angle is undefined");
        return;
    }

    # assuming that `Math::Trig` module is available in the PL/Perl environment
    # as it provides the `cos` function which works with radians
    my $result = cos($angle);
    elog(INFO, "Result of test_cosine_float4: " . $result);
    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_cosine_float4_zero', plperl_test_cosine_float4(0.0::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_cosine_float4_pi_over_2', plperl_test_cosine_float4(1.5707963::FLOAT4) = 0.0::FLOAT4;
```

#### plperl_test_float4_power❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_test_float4_power(base float4, exponent float4) RETURNS float4 AS $$
# name: test_float4_power
# description: Raises a float4 base number to the power of a float4 exponent
# type: float4
# input: float4 base number
# input: float4 exponent value
# output: float4 result of raising base to the power of exponent

    elog(INFO, "test_float4_power function called with base = " . base . ", exponent = " . exponent);
    if (!defined base || base == 0) {
        elog(INFO, "Base is zero, returning 0.0");
        return 0.0;
    }
    if (!defined exponent || exponent == 0) {
        elog(INFO, "Exponent is zero, returning 1.0");
        return 1.0;
    }
    my $result = base ** exponent;  # Exponentiation operator in Perl
    elog(INFO, "Result of test_float4_power: " . $result);
    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_float4_power_non_zero_base_positive_exponent', plperl_test_float4_power(2.0::FLOAT4, 3.0::FLOAT4) = 8.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_float4_power_non_zero_base_non_integer_exponent', plperl_test_float4_power(9.0::FLOAT4, 0.5::FLOAT4) = 3.0::FLOAT4;
```

#### plperl_test_float4_rounding❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_test_float4_rounding(original_value float4) RETURNS float4 AS $$
# name: test_float4_rounding
# description: This function rounds a float4 value to the nearest whole number and returns it as float4.
# type: float4
# input: A float4 value to be rounded to the nearest whole number
# output: Rounded float4 value to the nearest whole number

    elog(INFO, "test_float4_rounding function called with original_value = " . original_value);
    my $rounded_value = int(original_value + 0.5 * ($original_value <=> 0));
    elog(INFO, "Rounded result of test_float4_rounding: " . $rounded_value);
    return $rounded_value;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_float4_rounding_positive', plperl_test_float4_rounding(2.5::FLOAT4) = 3.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_float4_rounding_negative', plperl_test_float4_rounding(-3.7::FLOAT4) = -4.0::FLOAT4;
```

#### plperl_test_float4_truncation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_test_float4_truncation(number float4) RETURNS float4 AS $$
# name: test_float4_truncation
# description: Truncates a float4 number, removing its decimal part.
# type: float4
# input: A float4 number to be truncated
# output: The truncated float4 number

    elog(INFO, "test_float4_truncation function called with number = " . number);
    my $truncated_number = int(number);
    elog(INFO, "Result of test_float4_truncation: " . $truncated_number);
    return $truncated_number;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_float4_truncation_positive', plperl_test_float4_truncation(0.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_float4_truncation_negative', plperl_test_float4_truncation(-123.456::FLOAT4) = -123.0::FLOAT4;
```

#### plperl_test_increment_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_test_increment_float4(number float4, increment float4) RETURNS float4 AS $$
# name: test_increment_float4
# description: This function increments a float4 value by a float4 increment and returns the result as float4.
# type: float4
# input: The float4 number to be incremented
# input: The float4 value to increment the number by
# output: The incremented float4 value

    elog(INFO, "test_increment_float4 function called with number = " . number . ", increment = " . increment);
    my $result = number + increment;
    elog(INFO, "Result of test_increment_float4: " . $result);
    return $result;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_increment_float41', plperl_test_increment_float4(0.0::FLOAT4, 10.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_increment_float42', plperl_test_increment_float4(-3.5::FLOAT4, 4.0::FLOAT4) = 0.0::FLOAT4;
```

#### plperl_test_maximum_value❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_test_maximum_value(input1 float4, input2 float4) RETURNS float4 AS $$
# name: test_maximum_value
# description: Function to determine the maximum of two float4 values
# type: float4
# input: First float4 value to compare
# input: Second float4 value to compare
# output: Returns the maximum of the two float4 inputs

    elog(INFO, "test_maximum_value function called with input1 = " . input1 . ", input2 = " . input2);
    
    my $result;
    
    if (not defined input1 or not defined input2) {
        elog(ERROR, "Input values must be defined.");
        return undef;
    }
    
    if (input1 >= input2) {
        $result = input1;
    } else {
        $result = input2;
    }

    elog(INFO, "Result of test_maximum_value: " . $result);
    return $result;
$$ LANGUAGE plperl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_maximum_value_case1', plperl_test_maximum_value(12.34::FLOAT4, 9.87::FLOAT4) = 12.34::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_maximum_value_case2', plperl_test_maximum_value(-3.21::FLOAT4, 4.56::FLOAT4) = 4.56::FLOAT4;
```

#### plperl_validate_even_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_validate_even_float4(value FLOAT4) RETURNS BOOLEAN AS $$
# name: validate_even_float4
# description: Determines whether a float4 number represents an even number
# type: float4
# input: The float4 number to check
# output: Returns true if the number is even, otherwise false

    my $input_value = shift;
    elog(INFO, "validate_even_float4 function called with value = " . $input_value);
    
    # Convert the float4 input to the nearest smaller whole number
    my $rounded_value = int($input_value);
    
    # Perform a modulo operation with 2.
    my $is_even = ($rounded_value % 2 == 0) ? 1 : 0;
    
    elog(INFO, "Result of validate_even_float4: " . ($is_even ? 'true' : 'false'));
    return $is_even;
$$ LANGUAGE plperl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'validate_even_float41', plperl_validate_even_float4(4.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'validate_even_float42', plperl_validate_even_float4(5.0::FLOAT4) = FALSE;

-- validate_float4_within_range
```

#### plperl_validate_float4_within_range✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plperl_validate_float4_within_range(number FLOAT4, range_min FLOAT4, range_max FLOAT4) RETURNS FLOAT4 AS $$
# name: validate_float4_within_range
# description: validate whether the float4 number falls within the exclusive range (min, max)
# type: float4
# input: the float4 number to validate
# input: the minimum float4 boundary of the range
# input: the maximum float4 boundary of the range
# output: boolean represented as float4 (1.0 for true, 0.0 for false)

    elog(INFO, "validate_float4_within_range function called with number = " . $number . ", range_min = " . $range_min . ", range_max = " . $range_max);
    my $result;
    if($number > $range_min && $number < $range_max) {
        $result = 1.0;
    } else {
        $result = 0.0;
    }
    elog(INFO, "Result of validate_float4_within_range: " . $result);
    return $result;
$$ LANGUAGE plperl;
-- Test for number outside exclusive range
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_validateFloat4WithinRange2', plperl_validate_float4_within_range(4.0::FLOAT4, 5.0::FLOAT4, 6.0::FLOAT4) = 0.0::FLOAT4;
-- -- Test for number within exclusive range
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plperl-float4', 'test_validateFloat4WithinRange1', plperl_validate_float4_within_range(5.5::FLOAT4, 5.0::FLOAT4, 6.0::FLOAT4) = 1.0::FLOAT4;
```

### plpgsql

#### plpgsql_add_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_add_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: add_float4_values
-- description: Function that adds two float4 values and returns the result as float4
-- type: float4
-- input: float4 value to be added to value2
-- input: float4 value to be added to value1
-- output: Sum of value1 and value2 as float4

DECLARE
    result FLOAT4;
BEGIN
    RAISE NOTICE 'add_float4_values function called with value1 = %, value2 = %', value1, value2;
    result := value1 + value2;
    RAISE NOTICE 'Result of add_float4_values: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_addFloat4ValuesPositiveNumbers', plpgsql_add_float4_values(1.5::FLOAT4, 2.5::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_addFloat4ValuesPosNegNumbers', plpgsql_add_float4_values(-1.25::FLOAT4, 3.75::FLOAT4) = 2.5::FLOAT4;
```

#### plpgsql_average_of_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_average_of_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: average_of_float4_values
-- description: Calculates the average of two float4 values
-- type: float4
-- input: First float4 value
-- input: Second float4 value
-- output: The average value as float4

DECLARE
    sum FLOAT4;
    average FLOAT4;
BEGIN
    RAISE NOTICE 'average_of_float4_values function called with value1 = %, value2 = %', value1, value2;
    sum := value1 + value2;
    average := sum / 2.0;
    RAISE NOTICE 'Result of average_of_float4_values: %', average;
    RETURN average;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'average_of_float4_values_positive', plpgsql_average_of_float4_values(4.0::FLOAT4, 8.0::FLOAT4) = 6.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'average_of_float4_values_negative', plpgsql_average_of_float4_values(-2.5::FLOAT4, -7.5::FLOAT4) = -5.0::FLOAT4;
```

#### plpgsql_calculate_arccosine✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_arccosine(value FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_arccosine
-- description: Calculates the arccosine (inverse cosine) of a float4 value
-- type: float4
-- input: A float4 representing the cosine of an angle, range -1 to 1
-- output: The arccosine of the input value as float4 in radians

DECLARE
    result FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_arccosine function called with value = %', value;
    IF (value < -1 OR value > 1) THEN
        RAISE EXCEPTION 'Input value should be in the range of -1 to 1 inclusive';
    ELSE
        result := ACOS(value); -- radians
        RAISE NOTICE 'Result of calculate_arccosine: %', result;
        RETURN result;
    END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateArccosineOf0', ABS(plpgsql_calculate_arccosine(0::FLOAT4) - PI() / 2) < 0.0001;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateArccosineOf1', ABS(plpgsql_calculate_arccosine(1::FLOAT4)) < 0.0001;
```

#### plpgsql_calculate_area_of_rectangle✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_area_of_rectangle(width FLOAT4, height FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_area_of_rectangle
-- description: This function calculates the area of a rectangle given the width and height as float4 types and returns the area as float4
-- type: float4
-- input: float4 type representing the width of the rectangle
-- input: float4 type representing the height of the rectangle
-- output: float4 type representing the area of the rectangle

BEGIN
    RAISE NOTICE 'calculate_area_of_rectangle function called with width = %, height = %', width, height;
    RETURN width * height;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_area_of_rectangle1', plpgsql_calculate_area_of_rectangle(4.0::FLOAT4, 3.0::FLOAT4) = 12.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_area_of_rectangle2', plpgsql_calculate_area_of_rectangle(0.0::FLOAT4, 5.0::FLOAT4) = 0.0::FLOAT4;
```

#### plpgsql_calculate_arithmetic_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_arithmetic_mean(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_arithmetic_mean
-- description: Calculates arithmetic mean of two float4 values
-- type: float4
-- input: First float4 input value.
-- input: Second float4 input value.
-- output: Arithmetic mean result as float4.

DECLARE
    total FLOAT4;
    count INTEGER;
    result FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_arithmetic_mean function called with value1 = %, value2 = %', value1, value2;
    
    total := value1 + value2;
    count := 2;
    result := total / count;

    RAISE NOTICE 'Result of calculate_arithmetic_mean: %', result;
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;
-- Test case for arithmetic mean of two positive float4 numbers
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plpgsql-float4', 'test_calculateArithmeticMeanPositiveNumbers', 
       plpgsql_calculate_arithmetic_mean(3.5::FLOAT4, 2.5::FLOAT4) = 3.0::FLOAT4;
-- Test case for arithmetic mean of a positive and negative float4 number
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plpgsql-float4', 'test_calculateArithmeticMeanPosNegNumbers', 
       plpgsql_calculate_arithmetic_mean(5.0::FLOAT4, -3.0::FLOAT4) = 1.0::FLOAT4;
```

#### plpgsql_calculate_arithmetic_progression_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_arithmetic_progression_sum(a float4, d float4, n float4) RETURNS float4 AS $$
-- name: calculate_arithmetic_progression_sum
-- description: Calculate the sum of the first n terms of an arithmetic progression, given the first term (a), the common difference (d), and the number of terms (n), returning the sum as float4.
-- type: float4
-- input: the first term of the arithmetic progression (float4)
-- input: the common difference between the terms (float4)
-- input: the number of terms to sum (float4)
-- output: the sum of the first n terms of the arithmetic progression (float4)

DECLARE
    sn float4;
BEGIN
    RAISE NOTICE 'calculate_arithmetic_progression_sum function called with a = %, d = %, n = %', a, d, n;

    -- Following the given instructions step by step:
    -- Multiply n by the first term a
    -- Then add the product of n, n-1 and d
    -- Divide the result by 2
    sn := n * a + (d * (n - 1) * n) / 2;

    RAISE NOTICE 'Sum of arithmetic progression: %', sn;
    RETURN sn;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateArithmeticProgressionSum1', plpgsql_calculate_arithmetic_progression_sum(2.0::FLOAT4, 2.0::FLOAT4, 5.0::FLOAT4) = 30.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateArithmeticProgressionSum2', plpgsql_calculate_arithmetic_progression_sum(1.5::FLOAT4, 1.5::FLOAT4, 3.0::FLOAT4) = 9.0::FLOAT4;
```

#### plpgsql_calculate_ceil✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_ceil(number FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_ceil
-- description: This function calculates and returns the smallest integer greater than or equal to the given float4 number.
-- type: float4
-- input: A float4 number to calculate the ceiling value for
-- output: The ceiling value of the input as float4

DECLARE
    result FLOAT4;
BEGIN
    -- Debugging output: Notice message before processing
    RAISE NOTICE 'calculate_ceil function called with number = %', number;

    -- Processing: Calculate the ceiling of the input number.
    result := ceil(number);

    -- Debugging output: Notice message after processing with the result
    RAISE NOTICE 'Result of calculate_ceil: %', result;

    -- Return the result
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateCeilPositive', plpgsql_calculate_ceil(3.45::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateCeilNegative', plpgsql_calculate_ceil(-1.78::FLOAT4) = -1.0::FLOAT4;
```

#### plpgsql_calculate_circumference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_circumference(radius FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_circumference
-- description: Calculates the circumference of a circle given the radius as float4
-- type: float4
-- input: The radius of the circle as float4
-- output: The circumference of the circle as float4

DECLARE
    pi CONSTANT FLOAT4 := 3.1415926535;
    diameter FLOAT4;
    circumference FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_circumference function called with radius = %', radius;
    diameter := radius * 2;
    circumference := diameter * pi;
    RAISE NOTICE 'Result of calculate_circumference: %', circumference;
    RETURN circumference;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_circumference_small_radius', plpgsql_calculate_circumference(2.0::FLOAT4) = 12.566370614::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_circumference_large_radius', plpgsql_calculate_circumference(100.0::FLOAT4) = 628.3185307179584::FLOAT4;
```

#### plpgsql_calculate_decibel_level✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_decibel_level(sound_pressure FLOAT4, reference_pressure FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_decibel_level
-- description: Calculates the decibel level of a sound by comparing it to a reference sound pressure level.
-- type: float4
-- input: The sound pressure of the sound for which to determine the decibel level, as float4.
-- input: The reference sound pressure which is typically the threshold of human hearing, as float4.
-- output: The decibel level of the sound compared to the reference sound pressure, as float4.

DECLARE
    decibel_level FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_decibel_level function called with sound_pressure = %, reference_pressure = %', sound_pressure, reference_pressure;
    IF sound_pressure <= 0 OR reference_pressure <= 0 THEN
        RAISE EXCEPTION 'Input values must be positive.';
    END IF;
    decibel_level := 20 * LOG(sound_pressure / reference_pressure);
    RAISE NOTICE 'Result of calculate_decibel_level: %', decibel_level;
    RETURN decibel_level;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plpgsql-float4', 'test_calculateDecibelLevelNormal', 
       ROUND(plpgsql_calculate_decibel_level(1.0::FLOAT4, 0.00002::FLOAT4)) = 94.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plpgsql-float4', 'test_calculateDecibelLevelThreshold', 
       plpgsql_calculate_decibel_level(0.00002::FLOAT4, 0.00002::FLOAT4) = 0.0::FLOAT4;
```

#### plpgsql_calculate_distance_between_float4_points✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_distance_between_float4_points(x1 FLOAT4, y1 FLOAT4, x2 FLOAT4, y2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_distance_between_float4_points
-- description: Calculates the distance between two points in 2D space using float4 for coordinates
-- type: float4
-- input: The x-coordinate of the first point as a float4
-- input: The y-coordinate of the first point as a float4
-- input: The x-coordinate of the second point as a float4
-- input: The y-coordinate of the second point as a float4
-- output: The distance between the two points as a float4

DECLARE
    delta_x FLOAT4;
    delta_y FLOAT4;
    sum_squares FLOAT4;
    distance FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_distance_between_float4_points function called with x1 = %, y1 = %, x2 = %, y2 = %', x1, y1, x2, y2;
    
    delta_x := x1 - x2;
    delta_y := y1 - y2;
    sum_squares := delta_x^2 + delta_y^2;
    distance := sqrt(sum_squares);

    RAISE NOTICE 'Result of calculate_distance_between_float4_points: %', distance;
    RETURN distance;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_distance_between_float4_points_same_points', plpgsql_calculate_distance_between_float4_points(0.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_distance_between_float4_points_diff_points', plpgsql_calculate_distance_between_float4_points(3.0::FLOAT4, 4.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4) = 5.0::FLOAT4;
```

#### plpgsql_calculate_euclidean_distance✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_euclidean_distance(point1 JSONB, point2 JSONB) RETURNS FLOAT4 AS $$
-- name: calculate_euclidean_distance
-- description: Calculates the Euclidean distance between two points in 3D space.
-- type: float4
-- input: First point as an object with float4 x, y, z coordinates
-- input: Second point as an object with float4 x, y, z coordinates
-- output: The Euclidean distance between the two points as float4

DECLARE
  x1 FLOAT4 := (point1 ->> 'x')::FLOAT4;
  y1 FLOAT4 := (point1 ->> 'y')::FLOAT4;
  z1 FLOAT4 := (point1 ->> 'z')::FLOAT4;
  x2 FLOAT4 := (point2 ->> 'x')::FLOAT4;
  y2 FLOAT4 := (point2 ->> 'y')::FLOAT4;
  z2 FLOAT4 := (point2 ->> 'z')::FLOAT4;
  distance FLOAT4;
BEGIN
  RAISE NOTICE 'Calculating Euclidean distance with points (%, %, %) and (%, %, %)', x1, y1, z1, x2, y2, z2;
  distance := SQRT(POWER(x2 - x1, 2) + POWER(y2 - y1, 2) + POWER(z2 - z1, 2));
  RAISE NOTICE 'Calculated distance: %', distance;
  RETURN distance;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateEuclideanDistanceSamePositions', plpgsql_calculate_euclidean_distance('{"x": 7.0, "y": 8.0, "z": 9.0}'::JSONB, '{"x": 7.0, "y": 8.0, "z": 9.0}'::JSONB) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateEuclideanDistanceDiffPositions', plpgsql_calculate_euclidean_distance('{"x": 1.0, "y": 2.0, "z": 3.0}'::JSONB, '{"x": 4.0, "y": 5.0, "z": 6.0}'::JSONB) = 5.1962::FLOAT4;
```

#### plpgsql_calculate_exponential_growth✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_exponential_growth(initial_value FLOAT4, growth_rate FLOAT4, time_period FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_exponential_growth
-- description: This function calculates the exponential growth based on initial value, growth rate, and time.
-- type: float4
-- input: Initial quantity as float4
-- input: Growth rate (in percentage) as float4
-- input: Time period over which to calculate as float4
-- output: Returns the amount after growth as float4

DECLARE
    growth_rate_decimal FLOAT4;
    growth_factor FLOAT4;
    final_amount FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_exponential_growth function called with initial_value = %, growth_rate = %, time = %', initial_value, growth_rate, time_period;
    growth_rate_decimal := growth_rate / 100.0;
    growth_factor := 1.0 + growth_rate_decimal;
    final_amount := initial_value * POWER(growth_factor, time_period);
    RAISE NOTICE 'Result of calculate_exponential_growth: %', final_amount;
    RETURN round(final_amount::numeric, 6)::FLOAT4;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateExponentialGrowth10Years', plpgsql_calculate_exponential_growth(100.0::FLOAT4, 5.0::FLOAT4, 10.0::FLOAT4) = 162.889::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateExponentialGrowth5Years', plpgsql_calculate_exponential_growth(1000.0::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 1159.274::FLOAT4;
```

#### plpgsql_calculate_float4_as_percentage_of_another✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_as_percentage_of_another(value FLOAT4, total FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_as_percentage_of_another
-- description: Calculates one float4 value as a percentage of another float4 value.
-- type: float4
-- input: The float4 number to calculate the percentage for
-- input: The float4 number representing the total or 100%
-- output: The percentage of 'value' relative to 'total' as float4

DECLARE
    result FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_float4_as_percentage_of_another function called with value = %, total = %', value, total;
    IF total = 0 THEN
        RAISE EXCEPTION 'Total must not be zero.';
    END IF;
    result := (value / total) * 100;
    RAISE NOTICE 'Result of calculate_float4_as_percentage_of_another: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4AsPercentageOfAnother1', plpgsql_calculate_float4_as_percentage_of_another(25.0::FLOAT4, 50.0::FLOAT4) = 50.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4AsPercentageOfAnother2', plpgsql_calculate_float4_as_percentage_of_another(1.0::FLOAT4, 200.0::FLOAT4) = 0.5::FLOAT4;
```

#### plpgsql_calculate_float4_ceil✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_ceil(value FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_ceil
-- description: Function to calculate the smallest integer greater than or equal to the given float4 number
-- type: float4
-- input: float4 value to find the ceiling value for
-- output: float4 representing the smallest integer greater than or equal to the input

DECLARE
    ceiling_value FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_float4_ceil function called with value = %', value;
    ceiling_value := CEIL(value);
    RAISE NOTICE 'Ceiling value calculated: %', ceiling_value;
    RETURN ceiling_value;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_ceil_positive', plpgsql_calculate_float4_ceil(3.45::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_ceil_negative', plpgsql_calculate_float4_ceil(-2.8::FLOAT4) = -2.0::FLOAT4;
```

#### plpgsql_calculate_float4_complement✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_complement(number FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_complement
-- description: Calculates the complement of a float4 number with respect to 1, that is, it calculates 1 - n for a given float4 n.
-- type: float4
-- input: A float4 number which is the value to find the complement of.
-- output: The complement of the input float4 number with respect to 1 as float4.

DECLARE
    result FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_float4_complement function called with number = %', number;
    result := 1.0::FLOAT4 - number;
    RAISE NOTICE 'Result of calculate_float4_complement: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_float4_complement_less_than_one', plpgsql_calculate_float4_complement(0.25::FLOAT4) = 0.75::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_float4_complement_greater_than_one', plpgsql_calculate_float4_complement(1.25::FLOAT4) = -0.25::FLOAT4;
```

#### plpgsql_calculate_float4_division✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_division(dividend float4, divisor float4) RETURNS float4 AS $$
-- name: calculate_float4_division
-- description: This function takes two float4 values and divides the first by the second, returning a float4.
-- type: float4
-- input: The float4 number to be divided
-- input: The float4 number to divide by
-- output: The result of the division as a float4

DECLARE
    result float4;
BEGIN
    RAISE NOTICE 'calculate_float4_division function called with dividend = %, divisor = %', dividend, divisor;
    IF divisor = 0 THEN
        RAISE EXCEPTION 'Division by zero';
    ELSE
        result := dividend / divisor;
        RAISE NOTICE 'Result of calculate_float4_division: %', result;
    END IF;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4DivisionLargerBySmaller', plpgsql_calculate_float4_division(10.5::float4, 2.5::float4) = 4.2::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4DivisionSmallerByLarger', plpgsql_calculate_float4_division(3.3::float4, 4.4::float4) = 0.75::float4;
```

#### plpgsql_calculate_float4_dot_product✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_dot_product(vector1_x FLOAT4, vector1_y FLOAT4, vector2_x FLOAT4, vector2_y FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_dot_product
-- description: Calculates the dot product of two 2D vectors, each vector component is a float4 type
-- type: float4
-- input: x component of the first vector (float4)
-- input: y component of the first vector (float4)
-- input: x component of the second vector (float4)
-- input: y component of the second vector (float4)
-- output: dot product of the two vectors (float4)

DECLARE
    dot_product FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_float4_dot_product function called with vector1_x = %, vector1_y = %, vector2_x = %, vector2_y = %', vector1_x, vector1_y, vector2_x, vector2_y;
    -- Multiply vector1_x with vector2_x
    dot_product := vector1_x * vector2_x;
    -- Multiply vector1_y with vector2_y and add to the current dot product
    dot_product := dot_product + vector1_y * vector2_y;
    RAISE NOTICE 'Dot product is: %', dot_product;
    RETURN dot_product;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_dot_product_perpendicular', plpgsql_calculate_float4_dot_product(1.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 1.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_dot_product_parallel', plpgsql_calculate_float4_dot_product(1.0::FLOAT4, 1.0::FLOAT4, 2.0::FLOAT4, 2.0::FLOAT4) = 4.0::FLOAT4;
```

#### plpgsql_calculate_float4_exponentiation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_exponentiation(base FLOAT4, exponent FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_exponentiation
-- description: Calculates the base raised to the power of exponent, both of float4 type, and returns float4
-- type: float4
-- input: float4 number to be raised to the power of the exponent
-- input: float4 number representing the power
-- output: float4 result of the exponentiation

BEGIN
    RAISE NOTICE 'calculate_float4_exponentiation function called with base = %, exponent = %', base, exponent;
    IF exponent = 0 THEN
        RETURN 1;
    ELSIF base = 0 THEN
        RETURN 0;
    ELSE
        RETURN POWER(base, exponent);
    END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4ExponentiationPositive', plpgsql_calculate_float4_exponentiation(2.5::FLOAT4, 3.0::FLOAT4) = 15.625::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4ExponentiationNegBase', plpgsql_calculate_float4_exponentiation(-3.0::FLOAT4, 2.0::FLOAT4) = 9.0::FLOAT4;
```

#### plpgsql_calculate_float4_exponentiation_remainder❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_exponentiation_remainder(base FLOAT4, exponent INTEGER, divisor FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_exponentiation_remainder
-- description: Calculates the remainder of the exponentiation of a float4 base raised to an integer exponent when divided by a float4 divisor.
-- type: float4
-- input: the base value as float4
-- input: the exponent value as integer
-- input: the divisor value as float4
-- output: the remainder as float4

DECLARE
    exponent_as_float4 FLOAT4;
    exponentiation_result FLOAT4;
    remainder_result FLOAT4;
BEGIN
    -- Convert the integer exponent to float4
    exponent_as_float4 := exponent::FLOAT4;

    -- Raise the base to the power of the exponent
    exponentiation_result := base ^ exponent_as_float4;

    -- Divide the exponentiation result by the divisor and find the remainder
    remainder_result := mod(exponentiation_result, divisor);

    -- Return the remainder result
    RETURN remainder_result;
END;
$$ LANGUAGE plpgsql;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4ExponentiationRemainder1', plpgsql_calculate_float4_exponentiation_remainder(2.5::FLOAT4, 3, 3.2::FLOAT4) = 0.9::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4ExponentiationRemainder2', plpgsql_calculate_float4_exponentiation_remainder(5.1::FLOAT4, -2, 2.0::FLOAT4) = 1.1::FLOAT4;
```

#### plpgsql_calculate_float4_factorial✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_factorial(input_number float4) RETURNS float4 AS $$
-- name: calculate_float4_factorial
-- description: Calculates the factorial of a non-negative float4 number, rounding down to the nearest whole value before computation.
-- type: float4
-- input: A non-negative float4 number to calculate the factorial of
-- output: The factorial of the input number as float4, or 'undefined' if input is negative

DECLARE
    rounded_number int;
    result float4 := 1;
BEGIN
    RAISE NOTICE 'calculate_float4_factorial function called with number = %', input_number;
    
    rounded_number := FLOOR(input_number);
    
    IF rounded_number < 0 THEN
        RAISE NOTICE 'The input number is negative. Returning ''undefined''.';
        RETURN NULL; -- Assuming 'undefined' to be represented as NULL in the database context.
    ELSIF rounded_number = 0 OR rounded_number = 1 THEN
        RETURN result;
    ELSE
        FOR i IN 2..rounded_number LOOP
            result := result * i;
        END LOOP;
    END IF;
    
    RAISE NOTICE 'Result of calculate_float4_factorial: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4FactorialPositiveLessThanOne', plpgsql_calculate_float4_factorial(0.85::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4FactorialTypicalNumber', plpgsql_calculate_float4_factorial(5.75::FLOAT4) = 120.0::FLOAT4;
```

#### plpgsql_calculate_float4_geometric_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_geometric_mean(value1 float4, value2 float4) RETURNS float4 AS $$
-- name: calculate_float4_geometric_mean
-- description: Calculates the geometric mean of two float4 numbers and returns the result as float4
-- type: float4
-- input: The first positive float4 value
-- input: The second positive float4 value
-- output: The geometric mean of input float4 values as float4

DECLARE
    product  float4;
    result   float4;
BEGIN
    -- Debugging
    RAISE NOTICE 'calculate_float4_geometric_mean function called with value1 = %, value2 = %', value1, value2;

    -- Ensure that both input values are greater than zero
    IF value1 <= 0 OR value2 <= 0 THEN 
        RAISE EXCEPTION 'Input values must be greater than zero';
    END IF;

    -- Calculate the product of the two input values
    product := value1 * value2;

    -- Take the square root of the product
    result := sqrt(product);

    -- Debugging
    RAISE NOTICE 'Geometric mean result: %', result;

    -- Return the result as float4
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_geometric_mean_small_values', plpgsql_calculate_float4_geometric_mean(1.0::float4, 4.0::float4) = 2.0::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_geometric_mean_mixed_values', plpgsql_calculate_float4_geometric_mean(1.0::float4, 10000.0::float4) = 100.0::float4;
```

#### plpgsql_calculate_float4_inverse✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_inverse(numeric_value FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_inverse
-- description: Calculates the multiplicative inverse (or reciprocal) of a non-zero float4 number
-- type: float4
-- input: The float4 number to invert
-- output: The multiplicative inverse of the input as float4, or 'undefined' if the input is zero

DECLARE
    reciprocal FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_float4_inverse function called with numeric_value = %', numeric_value;
    IF numeric_value = 0.0 THEN
        RAISE NOTICE 'The reciprocal of zero is undefined.';
        RETURN NULL;
    ELSE
        reciprocal := 1 / numeric_value;
        RAISE NOTICE 'The reciprocal of % is %', numeric_value, reciprocal;
        RETURN reciprocal;
    END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_float4_inverse1', (plpgsql_calculate_float4_inverse(2.0::FLOAT4) = 0.5::FLOAT4) AND NOT plpgsql_calculate_float4_inverse(2.0::FLOAT4) IS NULL;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_float4_inverse2', plpgsql_calculate_float4_inverse(0.0::FLOAT4) IS NULL;
```

#### plpgsql_calculate_float4_inverse_ratio✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_inverse_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_inverse_ratio
-- description: Calculates the inverse ratio of two float4 numbers, returns the result as float4.
-- type: float4
-- input: First float4 value, acting as the numerator
-- input: Second float4 value, acting as the denominator, expected not to be zero
-- output: The inverse ratio of the two float4 input values

DECLARE
    reciprocal FLOAT4;
    result FLOAT4;
BEGIN
    RAISE NOTICE 'FUNCTION calculate_float4_inverse_ratio -- Called with numerator = %, denominator = %', numerator, denominator;
    
    IF denominator = 0.0 THEN
        RAISE EXCEPTION 'Denominator must not be zero.';
    END IF;
    
    reciprocal := 1.0 / denominator;
    result := reciprocal * numerator;
    
    RAISE NOTICE 'FUNCTION calculate_float4_inverse_ratio -- Result = %', result;
    RETURN result::FLOAT4;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4InverseRatioPositive', plpgsql_calculate_float4_inverse_ratio(2.0::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4InverseRatioZeroNumerator', plpgsql_calculate_float4_inverse_ratio(0.0::FLOAT4, 3.0::FLOAT4) = 0.0::FLOAT4;
```

#### plpgsql_calculate_float4_inverse_square_root✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_inverse_square_root(number FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_inverse_square_root
-- description: Calculate the inverse square root of a float4 number
-- type: float4
-- input: The float4 number for which to find the inverse square root
-- output: The inverse square root of the input number as float4

DECLARE
    result FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_float4_inverse_square_root function called with number = %', number;
    IF number <= 0 THEN
        RAISE NOTICE 'Number is less than or equal to 0, returning undefined';
        RETURN NULL; -- 'undefined' is represented as NULL in SQL
    ELSE
        result := 1 / (|/ number);
        RAISE NOTICE 'Inverse square root of the number is: %', result;
        RETURN result;
    END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_float4_inverse_square_root_positive', plpgsql_calculate_float4_inverse_square_root(4.0::FLOAT4) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_float4_inverse_square_root_small_positive', plpgsql_calculate_float4_inverse_square_root(0.25::FLOAT4) = 2.0::FLOAT4;
```

#### plpgsql_calculate_float4_linear_intercept✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_linear_intercept(x1 float4, y1 float4, x2 float4, y2 float4) RETURNS float4 AS $$
-- name: calculate_float4_linear_intercept
-- description: Calculates the y-intercept of a line (b) given two points with float4 coordinates (x1, y1) and (x2, y2). The formula used is b = y1 - (slope * x1), where slope is the (y2 - y1) / (x2 - x1).
-- type: float4
-- input: The x-coordinate of the first point as float4
-- input: The y-coordinate of the first point as float4
-- input: The x-coordinate of the second point as float4
-- input: The y-coordinate of the second point as float4
-- output: The y-intercept (b) of the line as float4

DECLARE
    slope float4;
    intercept float4;
BEGIN
    IF x1 = x2 THEN
        RAISE EXCEPTION 'Division by zero is not allowed: x1 and x2 cannot be equal.';
    END IF;

    RAISE NOTICE 'calculate_float4_linear_intercept function called with x1 = %, y1 = %, x2 = %, y2 = %', x1, y1, x2, y2;

    slope := (y2 - y1) / (x2 - x1);
    intercept := y1 - (slope * x1);

    RAISE NOTICE 'Calculated slope: %', slope;
    RAISE NOTICE 'Calculated intercept: %', intercept;

    RETURN intercept;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4LinearInterceptPositiveSlope', plpgsql_calculate_float4_linear_intercept(2.0::float4, 3.0::float4, 4.0::float4, 7.0::float4) = -1.0::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4LinearInterceptNegativeSlope', plpgsql_calculate_float4_linear_intercept(5.0::float4, 8.0::float4, 3.0::float4, 4.0::float4) = -2.0::float4;
```

#### plpgsql_calculate_float4_logarithm_base2✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_logarithm_base2(value FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_logarithm_base2
-- description: Calculates the base-2 logarithm of a given float4 number and returns the result as float4.
-- type: float4
-- input: The float4 number for which to calculate the base-2 logarithm
-- output: The base-2 logarithm of the input float4 number

BEGIN
    RAISE NOTICE 'calculate_float4_logarithm_base2 function called with value = %', value;
    IF value <= 0.0 THEN
        RAISE EXCEPTION 'Input value must be positive. Received: %', value;
    END IF;
    RETURN log(value) / log(2.0);
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_logarithm_base21', plpgsql_calculate_float4_logarithm_base2(8.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_logarithm_base22', plpgsql_calculate_float4_logarithm_base2(2.0::FLOAT4) = 1.0::FLOAT4;
```

#### plpgsql_calculate_float4_max_absolute_difference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_max_absolute_difference(input1 float4, input2 float4) RETURNS float4 AS $$
-- name: calculate_float4_max_absolute_difference
-- description: This function calculates the maximum absolute difference between two float4 values
-- type: float4
-- input: The first float4 input value
-- input: The second float4 input value
-- output: The maximum absolute difference as float4

DECLARE
    diff1 float4;
    diff2 float4;
    result float4;
BEGIN
    -- Determine the absolute difference of the first input from the second input
    diff1 := ABS(input1 - input2);
    -- Determine the absolute difference of the second input from the first input
    diff2 := ABS(input2 - input1);
    -- Compare the two absolute differences and return the larger of the two absolute differences as float4
    result := GREATEST(diff1, diff2);
    
    -- Debugging output
    RAISE NOTICE 'plpgsql_calculate_float4_max_absolute_difference function called with input1 = %, input2 = %', input1, input2;
    RAISE NOTICE 'Result of plpgsql_calculate_float4_max_absolute_difference: %', result;
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_max_absolute_difference1', plpgsql_calculate_float4_max_absolute_difference(5.5::float4, 3.0::float4) = 2.5::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_max_absolute_difference2', plpgsql_calculate_float4_max_absolute_difference(2.2::float4, 4.8::float4) = 2.6000001::float4;
```

#### plpgsql_calculate_float4_modulo✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_modulo(dividend float4, divisor float4) RETURNS float4 AS $$
-- name: calculate_float4_modulo
-- description: Calculates the modulo (the remainder of division) of two float4 values and returns the result as float4
-- type: float4
-- input: The number that is to be divided (dividend) as float4
-- input: The number by which the dividend is to be divided (divisor) as float4
-- output: The remainder of the division of the two float4 inputs

DECLARE
    quotient float4;
    product float4;
    remainder float4;
BEGIN
    RAISE NOTICE 'calculate_float4_modulo function called with dividend = %, divisor = %', dividend, divisor;
    IF divisor = 0 THEN
        RAISE EXCEPTION 'Divisor cannot be zero';
    END IF;
    quotient := dividend / divisor;
    product := quotient * divisor;
    remainder := dividend - product;
    RAISE NOTICE 'Result of calculate_float4_modulo: %', remainder;
    RETURN remainder;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_modulo_positive', plpgsql_calculate_float4_modulo(8.75::float4, 3.5::float4) = 0::float4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_modulo_negative_dividend', plpgsql_calculate_float4_modulo(-5.25::float4, 2.0::float4) = -1.25::float4;

-- calculate_thermal_expansion
```

#### plpgsql_calculate_float4_percentage_change✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_percentage_change(old_value FLOAT4, new_value FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_percentage_change
-- description: Calculates the percentage change from float4 old_value to float4 new_value.
-- type: float4
-- input: The original float4 value
-- input: The new float4 value to compare against the old value
-- output: The percentage change as float4

DECLARE
    percentage_change FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_float4_percentage_change function called with old_value = %, new_value = %', old_value, new_value;
    IF old_value = 0 THEN
        RAISE EXCEPTION 'Division by zero: old_value must not be zero.';
    END IF;

    percentage_change := ((new_value - old_value) / old_value) * 100;

    RAISE NOTICE 'Result of calculate_float4_percentage_change: %', percentage_change;
    RETURN percentage_change;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4PercentageChangeCase1', plpgsql_calculate_float4_percentage_change(50.0::FLOAT4, 75.0::FLOAT4) = 50.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4PercentageChangeCase2', round(plpgsql_calculate_float4_percentage_change(75.0::FLOAT4, 50.0::FLOAT4)::numeric, 2) = -33.33::numeric;
```

#### plpgsql_calculate_float4_precision✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_precision(number float4) RETURNS float4 AS $$
-- name: calculate_float4_precision
-- description: Calculates the precision (number of decimal places) of a float4 number
-- type: float4
-- input: A float4 number to calculate the precision of
-- output: The precision (number of decimal places) of the number as float4

DECLARE
    string_representation varchar;
    decimal_point_position int;
    precision float4;
BEGIN
    RAISE NOTICE 'calculate_float4_precision function called with number = %', number;
    
    -- Convert the number to a string representation
    string_representation := number::varchar;
    
    -- Locate the decimal point in the string
    decimal_point_position := position('.' in string_representation);
    IF decimal_point_position = 0 THEN
        -- If there is no decimal point, return 0 as the precision
        precision := 0.0;
    ELSE
        -- Count the number of characters after the decimal point
        precision := length(substring(string_representation from decimal_point_position + 1))::float4;
    END IF;
    
    RAISE NOTICE 'Result of calculate_float4_precision: %', precision;
    RETURN precision;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_precision1', plpgsql_calculate_float4_precision(123.45::float4) = 2.0::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_precision2', plpgsql_calculate_float4_precision(456.0::float4) = 0.0::float4;
```

#### plpgsql_calculate_float4_quadratic_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_quadratic_sum(num1 FLOAT4, num2 FLOAT4, num3 FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_quadratic_sum
-- description: Calculates the sum of squares of three float4 numbers and returns the result as float4.
-- type: float4
-- input: First float4 number
-- input: Second float4 number
-- input: Third float4 number
-- output: Sum of squares of num1, num2, and num3 as float4

DECLARE
    result1 FLOAT4;
    result2 FLOAT4;
    result3 FLOAT4;
    sum_of_squares FLOAT4;
BEGIN
    -- This is the debugging line
    RAISE NOTICE 'calculate_float4_quadratic_sum function called with num1 = %, num2 = %, num3 = %', num1, num2, num3;
    
    result1 := num1*num1;
    result2 := num2*num2;
    result3 := num3*num3;
    
    sum_of_squares := result1 + result2 + result3;
    
    -- This is the second debugging line, displaying the result for consistency checking.
    RAISE NOTICE 'Result of calculate_float4_quadratic_sum: %', sum_of_squares;
    RETURN sum_of_squares;
END;
$$ LANGUAGE plpgsql;
/* Testing with three positive float4 numbers */
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_quadratic_sum_positive', plpgsql_calculate_float4_quadratic_sum(3.0::FLOAT4, 4.0::FLOAT4, 5.0::FLOAT4) = 50.0::FLOAT4;
/* Testing with negative and positive float4 numbers */
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_quadratic_sum_mixed', plpgsql_calculate_float4_quadratic_sum(-3.0::FLOAT4, 4.0::FLOAT4, -5.0::FLOAT4) = 50.0::FLOAT4;
```

#### plpgsql_calculate_float4_quotient_and_product✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_quotient_and_product(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4[] AS $$
-- name: calculate_float4_quotient_and_product
-- description: This function calculates both the quotient and the product of two float4 values and returns them as a float4 array.
-- type: float4
-- input: First float4 input value
-- input: Second float4 input value, not equal to zero
-- output: Array of float4 with the first element being the quotient and the second being the product of the inputs

DECLARE
    result FLOAT4[];
BEGIN
    RAISE NOTICE 'calculate_float4_quotient_and_product function called with value1 = %, value2 = %', value1, value2;
    IF value2 != 0 THEN
        result := ARRAY[value1 / value2, value1 * value2];
    ELSE
        RAISE EXCEPTION 'Division by zero error';
    END IF;
    RAISE NOTICE 'Result of calculate_float4_quotient_and_product: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4QuotientAndProduct1', plpgsql_calculate_float4_quotient_and_product(3.5::FLOAT4, 2.0::FLOAT4) = ARRAY[1.75::FLOAT4, 7.0::FLOAT4];
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4QuotientAndProduct2', plpgsql_calculate_float4_quotient_and_product(-4.0::FLOAT4, 2.0::FLOAT4) = ARRAY[-2.0::FLOAT4, -8.0::FLOAT4];
```

#### plpgsql_calculate_float4_ratio✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_ratio
-- description: Calculates the ratio of two float4 numbers and returns the result as float4. Ratio is the result of dividing the first float4 value by the second, provided the second is not zero.
-- type: float4
-- input: The numerator for the ratio calculation. Type: float4
-- input: The denominator for the ratio calculation. Type: float4. Must not be zero.
-- output: The calculated ratio as float4. If the denominator is zero, the function will return 'undefined'.

BEGIN
    RAISE NOTICE 'calculate_float4_ratio function called with numerator = %, denominator = %', numerator, denominator;
    IF denominator = 0.0 THEN
        RETURN NULL; -- There is no 'undefined' in SQL, returning NULL as an equivalent to undefined.
    ELSE
        RETURN numerator / denominator;
    END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_float4_ratio_Positive', plpgsql_calculate_float4_ratio(25.0::FLOAT4, 5.0::FLOAT4) = 5.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_float4_ratio_ZeroDenominator', plpgsql_calculate_float4_ratio(10.0::FLOAT4, 0.0::FLOAT4) IS NULL;
```

#### plpgsql_calculate_float4_ratio_and_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_ratio_and_sum(number1 float4, number2 float4) RETURNS JSON AS $$
-- name: calculate_float4_ratio_and_sum
-- description: Calculates the ratio of two float4 numbers and their sum
-- type: float4
-- input: First float4 number
-- input: Second float4 number, cannot be zero as it will be used as divisor
-- output: An object with the ratio and sum of the two float4 numbers

DECLARE
    ratio float4;
    sum float4;
    result JSON;
BEGIN
    RAISE NOTICE 'calculate_float4_ratio_and_sum function called with number1 = %, number2 = %', number1, number2;
    
    IF number2 = 0 THEN
        RAISE EXCEPTION 'Division by zero is not allowed';
    END IF;
    
    ratio := number1 / number2;
    sum := number1 + number2;
    result := json_build_object('ratio', ratio, 'sum', sum);
    
    RAISE NOTICE 'Result of calculate_float4_ratio_and_sum: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_float4_ratio_and_sum_positive_numbers', plpgsql_calculate_float4_ratio_and_sum(6.0::FLOAT4, 3.0::FLOAT4)::JSONB = '{"ratio": 2.0, "sum": 9.0}'::JSONB;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_float4_ratio_and_sum_negative_numbers', plpgsql_calculate_float4_ratio_and_sum(-8.0::FLOAT4, 4.0::FLOAT4)::JSON = '{"ratio": -2.0, "sum": -4.0}'::JSON;
```

#### plpgsql_calculate_float4_remainder✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_remainder(dividend FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_remainder
-- description: Calculates the remainder of division between two float4 numbers
-- type: float4
-- input: float4 value representing the dividend
-- input: float4 value representing the divisor
-- output: float4 value representing the remainder of the division

BEGIN
    -- Ensure both dividend and divisor are of float4 type is handled by function's parameters type
    RAISE NOTICE 'calculate_float4_remainder function called with dividend = %, divisor = %', dividend, divisor;
    
    -- If divisor is 0.0, return null as division by zero is not possible
    IF divisor = 0.0 THEN
        RAISE NOTICE 'Division by zero - returning NULL';
        RETURN NULL;
    END IF;
    
    -- Divide dividend by divisor and find the remainder
    -- Return the remainder as float4
    RETURN dividend % divisor;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plpgsql-float4', 'test_calculateFloat4RemainderDivisionByZero', plpgsql_calculate_float4_remainder(5.0::FLOAT4, 0.0::FLOAT4) IS NULL;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT)
-- SELECT 'plpgsql-float4', 'test_calculateFloat4RemainderPositive', plpgsql_calculate_float4_remainder(5.0::FLOAT4, 2.0::FLOAT4) = 1.0::FLOAT4;
```

#### plpgsql_calculate_float4_rounded_average✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_rounded_average(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_rounded_average
-- description: Calculate the average of two float4 values and round it to the nearest whole number, returning the result as a float4
-- type: float4
-- input: The first float4 value for the average calculation
-- input: The second float4 value for the average calculation
-- output: The rounded average of value1 and value2 as a float4

DECLARE
    average FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_float4_rounded_average function called with value1 = %, value2 = %', value1, value2;
    average := ROUND((value1 + value2) / 2.0);
    RAISE NOTICE 'Result of calculate_float4_rounded_average: %', average;
    RETURN average;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_float4_rounded_average_positive', plpgsql_calculate_float4_rounded_average(25.4::FLOAT4, 34.6::FLOAT4) = 30.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_float4_rounded_average_mixed', plpgsql_calculate_float4_rounded_average(-14.8::FLOAT4, 20.2::FLOAT4) = 3.0::FLOAT4;
```

#### plpgsql_calculate_float4_to_power_of_integer✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_to_power_of_integer(float4_base float4, integer_exponent integer) RETURNS float4 AS $$
-- name: calculate_float4_to_power_of_integer
-- description: This function takes a float4 base number and an integer exponent, then raises the base to the power of the exponent returning a float4 result
-- type: float4
-- input: float4 number serving as the base for the power operation
-- input: Integer serving as the exponent for the power operation
-- output: float4 result of the base raised to the power of the exponent

BEGIN
    RAISE NOTICE 'Function calculate_float4_to_power_of_integer called with float4_base = %, integer_exponent = %', float4_base, integer_exponent;
    RETURN pow(float4_base, integer_exponent);
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_to_power_of_integer1', plpgsql_calculate_float4_to_power_of_integer(2.5::float4, 3::integer) = 15.625::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_float4_to_power_of_integer2', plpgsql_calculate_float4_to_power_of_integer(7.0::float4, 0::integer) = 1.0::float4;
```

#### plpgsql_calculate_float4_with_exponential_notation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_float4_with_exponential_notation(input_number FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_float4_with_exponential_notation
-- description: Converts a float4 number in exponential notation to a float4 number in standard decimal notation
-- type: float4
-- input: float4 number in exponential notation
-- output: float4 number in standard decimal notation

DECLARE
    result FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_float4_with_exponential_notation function called with number = %', input_number;
    -- The conversion is implicit, but we assign it to result for clarity
    result := input_number;
    RAISE NOTICE 'Result of calculate_float4_with_exponential_notation: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4WithExponentialNotationSmall', plpgsql_calculate_float4_with_exponential_notation('2.5e-4'::FLOAT4) = '0.00025'::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateFloat4WithExponentialNotationLarge', plpgsql_calculate_float4_with_exponential_notation('3.57e+2'::FLOAT4) = '357.0'::FLOAT4;
```

#### plpgsql_calculate_harmonic_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_harmonic_mean(number1 FLOAT4, number2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_harmonic_mean
-- description: Calculates the harmonic mean of two float4 numbers
-- type: float4
-- input: First float4 number
-- input: Second float4 number
-- output: Harmonic mean of the two float4 numbers as float4

DECLARE
    harmonic_mean FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_harmonic_mean function called with number1 = %, number2 = %', number1, number2;

    IF number1 = 0.0 OR number2 = 0.0 THEN
        RETURN NULL;
    END IF;

    harmonic_mean := 2.0 / (1.0/number1 + 1.0/number2);

    RAISE NOTICE 'Result of calculate_harmonic_mean: %', harmonic_mean;
    RETURN harmonic_mean;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'An error occurred in calculate_harmonic_mean: %', SQLERRM;
        RETURN NULL;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateHarmonicMeanPositive', plpgsql_calculate_harmonic_mean(4.0::FLOAT4, 8.0::FLOAT4) = 5.3333334::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateHarmonicMeanWithZero', CASE WHEN plpgsql_calculate_harmonic_mean(0.0::FLOAT4, 5.0::FLOAT4) IS NULL THEN TRUE ELSE FALSE END;
```

#### plpgsql_calculate_hypotenuse✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_hypotenuse(a FLOAT4, b FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_hypotenuse
-- description: Calculates the length of the hypotenuse of a right-angled triangle using the Pythagorean theorem
-- type: float4
-- input: length of side a as float4
-- input: length of side b as float4
-- output: length of the hypotenuse as float4

DECLARE
    a_squared FLOAT4;
    b_squared FLOAT4;
    hypotenuse_length FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_hypotenuse function called with a = %, b = %', a, b;
    a_squared := a * a;
    b_squared := b * b;
    hypotenuse_length := sqrt(a_squared + b_squared);
    RAISE NOTICE 'Result of calculate_hypotenuse: %', hypotenuse_length;
    RETURN hypotenuse_length;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_hypotenuse1', plpgsql_calculate_hypotenuse(3.0::FLOAT4, 4.0::FLOAT4) = 5.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_hypotenuse2', plpgsql_calculate_hypotenuse(5.0::FLOAT4, 12.0::FLOAT4) = 13.0::FLOAT4;
```

#### plpgsql_calculate_inscribed_circle_area✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_inscribed_circle_area(side_length float4) RETURNS float4 AS $$
-- name: calculate_inscribed_circle_area
-- description: Calculates the area of an inscribed circle within a square where each side is of float4 type length.
-- type: float4
-- input: The length of the side of the square of type float4
-- output: The area of the inscribed circle as float4

DECLARE
    radius float4;
    area float4;
BEGIN
    RAISE NOTICE 'calculate_inscribed_circle_area function called with side_length = %', side_length;
    
    -- Divide the square's side length by 2 to get the radius of the inscribed circle
    radius := side_length / 2;
    
    -- Square the radius to get the square of the radius
    radius := radius * radius;
    
    -- Multiply the square of the radius by PI to get the area of the circle
    area := radius * PI();
    
    RAISE NOTICE 'Result of calculate_inscribed_circle_area: %', area;
    RETURN area;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateInscribedCircleArea1', round(plpgsql_calculate_inscribed_circle_area(2.0::FLOAT4)) = round(3.14159::FLOAT4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateInscribedCircleArea2', plpgsql_calculate_inscribed_circle_area(5.4::FLOAT4) = CAST(22.902212 AS FLOAT4);
```

#### plpgsql_calculate_linear_intercept✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_linear_intercept(x1 FLOAT4, y1 FLOAT4, m FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_linear_intercept
-- description: Calculates the y-intercept (b) of a linear equation in the form y = mx + b using a point (x1, y1) and the slope (m)
-- type: float4
-- input: float4 - the x-coordinate of the point
-- input: float4 - the y-coordinate of the point
-- input: float4 - the slope of the line
-- output: float4 - the y-intercept of the line

DECLARE
    intercept FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_linear_intercept function called with x1 = %, y1 = %, m = %', x1, y1, m;
    intercept := y1 - (m * x1);
    RAISE NOTICE 'Result of calculate_linear_intercept: %', intercept;
    RETURN intercept;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateLinearInterceptPositive', plpgsql_calculate_linear_intercept(3.0::FLOAT4, 4.0::FLOAT4, 2.0::FLOAT4) = -2.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateLinearInterceptNegative', plpgsql_calculate_linear_intercept(-1.0::FLOAT4, -3.0::FLOAT4, -2.0::FLOAT4) = -5.0::FLOAT4;
```

#### plpgsql_calculate_linear_interpolation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_linear_interpolation(value1 FLOAT4, value2 FLOAT4, fraction FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_linear_interpolation
-- description: Interpolates between two float4 values at a specific increment
-- type: float4
-- input: starting float4 value for interpolation
-- input: ending float4 value for interpolation
-- input: the float4 fraction representing the interpolation point between value1 and value2
-- output: interpolated float4 value

DECLARE
    result FLOAT4;
BEGIN
    IF fraction < 0.0 OR fraction > 1.0 THEN
        RAISE EXCEPTION 'Invalid input: fraction must be between 0.0 and 1.0';
    END IF;
    RAISE NOTICE 'calculate_linear_interpolation function called with value1 = %, value2 = %, fraction = %', value1, value2, fraction;
    result := value1 + (value2 - value1) * fraction;
    RAISE NOTICE 'Result of calculate_linear_interpolation: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateLinearInterpolationMidRange', plpgsql_calculate_linear_interpolation(10.75::FLOAT4, 20.5::FLOAT4, 0.5::FLOAT4) = 15.625::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateLinearInterpolationStartValue', plpgsql_calculate_linear_interpolation(-5.0::FLOAT4, 5.0::FLOAT4, 0.1::FLOAT4) = -4.0::FLOAT4;
```

#### plpgsql_calculate_log_base_n✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_log_base_n(number FLOAT4, base FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_log_base_n
-- description: Calculates the logarithm of a float4 number with a float4 custom base and returns the result as float4. Rejects a base that is less than or equal to 0, or equal to 1, and a number that is less than or equal to 0.
-- type: float4
-- input: Value to find the logarithm of. Must be greater than 0.
-- input: Base of the logarithm. Must be greater than 0 and not equal to 1.
-- output: Logarithm of the number to the base provided. If the base or number is invalid, the output is 'undefined'.

DECLARE
    result FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_log_base_n function called with number = %, base = %', number, base;
    IF base <= 0 OR base = 1 THEN
        RAISE NOTICE 'Invalid base provided for calculate_log_base_n.';
        RETURN 'undefined';
    ELSIF number <= 0 THEN
        RAISE NOTICE 'Invalid number provided for calculate_log_base_n.';
        RETURN 'undefined';
    ELSE
        result := log(number) / log(base);
        RAISE NOTICE 'Result of calculate_log_base_n: %', result;
        RETURN result;
    END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_log_base_n_valid_base', plpgsql_calculate_log_base_n(32.0::FLOAT4, 2.0::FLOAT4) = 5.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_log_base_n_invalid_base', plpgsql_calculate_log_base_n(100.0::FLOAT4, 1.0::FLOAT4) = 'undefined';
```

#### plpgsql_calculate_logarithm✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_logarithm(number FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_logarithm
-- description: Calculates the natural logarithm (base e) of a given float4 number and returns the result as float4. If the input is less than or equal to zero, the function will return 'undefined' since the logarithm for non-positive numbers is not defined in real numbers.
-- type: float4
-- input: The float4 number for which to find the natural logarithm
-- output: The natural logarithm of the given float4 number as float4, or 'undefined' if the input is not a positive float4

DECLARE
    result FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_logarithm function called with number = %', number;

    IF number <= 0 THEN
        RAISE NOTICE 'Input number is not greater than zero. Logarithm undefined.';
        RETURN NULL; -- Representing 'undefined'
    ELSE
        result := ln(number);
        RAISE NOTICE 'Result of calculate_logarithm: %', result;
        RETURN result;
    END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_logarithm_positive', round(plpgsql_calculate_logarithm(2.7183::FLOAT4)::NUMERIC, 4) = 1.0000::NUMERIC;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_logarithm_non_positive', plpgsql_calculate_logarithm(-1.0::FLOAT4) IS NULL;
```

#### plpgsql_calculate_logarithm_base_ten✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_logarithm_base_ten(number FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_logarithm_base_ten
-- description: Calculates the logarithm base 10 of a float4 number and returns the result as float4. It assumes positive non-zero input.
-- type: float4
-- input: The float4 number to calculate the logarithm base 10 of
-- output: The float4 result of the logarithm base 10 calculation

BEGIN
    RAISE NOTICE 'calculate_logarithm_base_ten function called with number = %', number;
    IF number > 0 THEN
        RETURN log(number) / log(10); -- Calculate log base 10, PostgreSQL log function gives the natural logarithm
    ELSE
        RAISE EXCEPTION 'Input number must be greater than zero.';
    END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateLogarithmBaseTen1', plpgsql_calculate_logarithm_base_ten(100.0::FLOAT4) = 2.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateLogarithmBaseTen2', plpgsql_calculate_logarithm_base_ten(1000.0::FLOAT4) = 3.0::FLOAT4;
```

#### plpgsql_calculate_median_of_two_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_median_of_two_float4(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_median_of_two_float4
-- description: Calculates the median of two float4 numbers and returns the result as float4
-- type: float4
-- input: First float4 input value
-- input: Second float4 input value
-- output: Median of input1 and input2 as float4

DECLARE
    median FLOAT4 := 0;
BEGIN
    RAISE NOTICE 'calculate_median_of_two_float4 function called with input1 = %, input2 = %', input1, input2;
    IF input1 = input2 THEN
        median := input1;
    ELSE
        median := (input1 + input2) / 2;
    END IF;
    RAISE NOTICE 'Result of calculate_median_of_two_float4: %', median;
    RETURN median;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_median_of_two_float4_identical', plpgsql_calculate_median_of_two_float4(10.0::FLOAT4, 10.0::FLOAT4) = 10.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_median_of_two_float4_different', plpgsql_calculate_median_of_two_float4(10.0::FLOAT4, 20.0::FLOAT4) = 15.0::FLOAT4;
```

#### plpgsql_calculate_percentage_difference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_percentage_difference(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_percentage_difference
-- description: Calculates the percentage difference between two float4 values
-- type: float4
-- input: First float4 value
-- input: Second float4 value
-- output: Percentage difference as float4

DECLARE
    absolute_difference FLOAT4;
    average_value FLOAT4;
    percentage_difference FLOAT4;
BEGIN
    -- Calculate absolute difference
    absolute_difference := ABS(value1 - value2);
    RAISE NOTICE 'Absolute difference: %', absolute_difference;

    -- Calculate average value
    average_value := (value1 + value2) / 2.0;
    RAISE NOTICE 'Average value: %', average_value;

    -- Avoid division by zero
    IF average_value = 0 THEN
        RAISE EXCEPTION 'Division by zero: average value is 0';
    END IF;

    -- Calculate percentage difference
    percentage_difference := (absolute_difference / average_value) * 100.0;
    RAISE NOTICE 'Percentage difference: %', percentage_difference;

    -- Return the calculated percentage difference
    RETURN percentage_difference;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculatePercentageDifferenceGreater', plpgsql_calculate_percentage_difference(150.0::FLOAT4, 100.0::FLOAT4) = 40.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculatePercentageDifferenceLesser', plpgsql_calculate_percentage_difference(75.0::FLOAT4, 125.0::FLOAT4) = 50.0::FLOAT4;
```

#### plpgsql_calculate_product_of_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_product_of_float4(num1 float4, num2 float4) RETURNS float4 AS $$
-- name: calculate_product_of_float4
-- description: Calculates the product of two float4 numbers and returns the result as a float4
-- type: float4
-- input: The first float4 number to be multiplied
-- input: The second float4 number to be multiplied
-- output: The product of the two float4 inputs as a float4

DECLARE
    product float4;
BEGIN
    RAISE NOTICE 'calculate_product_of_float4 function called with num1 = %, num2 = %', num1, num2;
    product := num1 * num2;
    RAISE NOTICE 'Result of calculate_product_of_float4: %', product;
    RETURN product;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_product_of_float41', round(plpgsql_calculate_product_of_float4(3.14::float4, 1.59::float4)::numeric, 7) = round(4.9926::numeric, 7);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'calculate_product_of_float42', plpgsql_calculate_product_of_float4(-5.0::float4, 2.5::float4) = -12.5::float4;
```

#### plpgsql_calculate_quadratic_roots✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_quadratic_roots(a float4, b float4, c float4) RETURNS float4[] AS $$
-- name: calculate_quadratic_roots
-- description: Calculates the roots of a quadratic equation ax^2 + bx + c = 0 using the quadratic formula and returns them as an array of float4
-- type: float4
-- input: float4 coefficient for x^2
-- input: float4 coefficient for x
-- input: float4 constant term
-- output: array of float4 containing the two roots

DECLARE
    discriminant float4;
    root1 float4;
    root2 float4;
BEGIN
    RAISE NOTICE 'calculate_quadratic_roots function called with a = %, b = %, c = %', a, b, c;
    discriminant := b^2 - 4 * a * c;
    
    IF discriminant < 0 THEN
        RETURN '{}';
    ELSE
        root1 := (-b + sqrt(discriminant)) / (2 * a);
        IF discriminant = 0 THEN
            RETURN ARRAY[root1];
        ELSE
            root2 := (-b - sqrt(discriminant)) / (2 * a);
            RETURN ARRAY[root1, root2];
        END IF;
    END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateQuadraticRootsDistinctRoots', plpgsql_calculate_quadratic_roots(1::FLOAT4, -5::FLOAT4, 6::FLOAT4) = ARRAY[3::FLOAT4, 2::FLOAT4];
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculateQuadraticRootsSingleRoot', plpgsql_calculate_quadratic_roots(1::FLOAT4, -4::FLOAT4, 4::FLOAT4) = ARRAY[2::FLOAT4];
```

#### plpgsql_calculate_scaled_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_scaled_value(value FLOAT4, factor FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_scaled_value
-- description: This function takes an input float4 value and scales it by a given float4 factor.
-- type: float4
-- input: The original float4 value to be scaled
-- input: The float4 factor by which to scale the value
-- output: The scaled float4 value

DECLARE
    result FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_scaled_value function called with value = %, factor = %', value, factor;
    result := value * factor;
    RAISE NOTICE 'Result of calculate_scaled_value: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_scaled_value_scaling_up', plpgsql_calculate_scaled_value(1.5::FLOAT4, 2.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_scaled_value_scaling_down', plpgsql_calculate_scaled_value(3.0::FLOAT4, 0.5::FLOAT4) = 1.5::FLOAT4;
```

#### plpgsql_calculate_sin✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_sin(angle FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_sin
-- description: Calculates the sine of a float4 angle value (in radians) and returns the result as float4
-- type: float4
-- input: float4 angle in radians for which the sine will be calculated
-- output: float4 representing the sine of the input angle

BEGIN
    RAISE NOTICE 'calculate_sin function called with angle = %', angle;

    -- We are assuming that the input angle is already in radians as per the pseudocode given
    -- Calculating sine of the angle
    RETURN CAST(SIN(angle) AS FLOAT4);
END;
$$ LANGUAGE plpgsql;
-- Test case: Calculate sine for angle 0 (where sin(0) is 0)
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT)
SELECT 'plpgsql-float4', 'test_calculate_sin1', plpgsql_calculate_sin(0.0::FLOAT4) = 0.0::FLOAT4;
-- Test case: Calculate sine for angle PI/2 (where sin(PI/2) is 1)
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT)
SELECT 'plpgsql-float4', 'test_calculate_sin2', plpgsql_calculate_sin(1.5708::FLOAT4) = 1.0::FLOAT4;
```

#### plpgsql_calculate_slope✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_slope(point1 FLOAT4[], point2 FLOAT4[]) RETURNS FLOAT4 AS $$
-- name: calculate_slope
-- description: Calculates the slope of a line passing through two points in the Cartesian coordinate system
-- type: float4
-- input: Coordinates (x1, y1) of the first point, type float4 array
-- input: Coordinates (x2, y2) of the second point, type float4 array
-- output: The slope of the line as float4

DECLARE
    deltaX FLOAT4;
    deltaY FLOAT4;
    result FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_slope function called with point1 = (%, %), point2 = (%, %)', point1[1], point1[2], point2[1], point2[2];

    -- Check if input arrays contain exactly two elements each
    IF array_length(point1, 1) != 2 OR array_length(point2, 1) != 2 THEN
        RAISE EXCEPTION 'Input arrays must contain exactly two elements.';
    END IF;

    -- Calculating deltaY and deltaX
    deltaY := point2[2] - point1[2];
    deltaX := point2[1] - point1[1];

    -- Handle vertical line case
    IF deltaX = 0 THEN
        RETURN 'undefined';
    END IF;

    -- Calculate slope
    result := deltaY / deltaX;

    RAISE NOTICE 'Result of calculate_slope: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_slope_1', plpgsql_calculate_slope(ARRAY[1.0, 2.0]::FLOAT4[], ARRAY[3.0, 3.0]::FLOAT4[]) = 0.5;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_slope_2', plpgsql_calculate_slope(ARRAY[4.0, 1.0]::FLOAT4[], ARRAY[4.0, 3.0]::FLOAT4[]) IS NULL;
```

#### plpgsql_calculate_weight_force✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_calculate_weight_force(mass FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_weight_force
-- description: Calculates the force due to weight of an object using the formula F = m * g, where m is mass in kilograms, and g is acceleration due to gravity at 9.81 m/s^2 (represented as float4)
-- type: float4
-- input: mass of the object as float4
-- output: the weight force as float4

DECLARE
    acceleration_due_to_gravity FLOAT4 := 9.81;
    weight_force FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_weight_force function called with mass = %', mass;
    weight_force := mass * acceleration_due_to_gravity;
    RAISE NOTICE 'Result of calculate_weight_force: %', weight_force;
    RETURN weight_force;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_weight_force1', plpgsql_calculate_weight_force(2.0::FLOAT4) = 19.62::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_calculate_weight_force2', plpgsql_calculate_weight_force(5.5::FLOAT4) = 53.955::FLOAT4;
```

#### plpgsql_check_float4_equality✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_check_float4_equality(input1 FLOAT4, input2 FLOAT4) RETURNS BOOLEAN AS $$
-- name: check_float4_equality
-- description: Checks whether two float4 values are equal
-- type: float4
-- input: First float4 value to be compared
-- input: Second float4 value to be compared
-- output: Boolean result determining if the two float4 values are equal

BEGIN
    RAISE NOTICE 'check_float4_equality function called with input1 = %, input2 = %', input1, input2;
    RETURN input1 = input2;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'check_float4_equality_TwoEqualValues', plpgsql_check_float4_equality(4.0000::FLOAT4, 4.0000::FLOAT4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'check_float4_equality_TwoDifferentValues', plpgsql_check_float4_equality(4.0000::FLOAT4, 4.0000::FLOAT4);
```

#### plpgsql_check_float4_is_positive✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_check_float4_is_positive(number float4) RETURNS float4 AS $$
-- name: check_float4_is_positive
-- description: Determines if a float4 input is positive
-- type: float4
-- input: The float4 number to check
-- output: A float4 representing a boolean true or false, 1.0 for true and 0.0 for false

DECLARE
    result float4;
BEGIN
    RAISE NOTICE 'check_float4_is_positive function called with number = %', number;
    result := CASE WHEN number > 0 THEN 1.0 ELSE 0.0 END;
    RAISE NOTICE 'Result of check_float4_is_positive: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'check_float4_is_positive_case_positive', plpgsql_check_float4_is_positive(0.1::float4) = 1.0::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'check_float4_is_positive_case_non_positive', plpgsql_check_float4_is_positive(-0.1::float4) = 0.0::float4;
```

#### plpgsql_check_float4_within_bounds✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_check_float4_within_bounds(value float4, lower_bound float4, upper_bound float4) RETURNS float4 AS $$
-- name: check_float4_within_bounds
-- description: Determines whether a float4 value is between two boundary float4 values (exclusive)
-- type: float4
-- input: the float4 value to check
-- input: the lower float4 boundary
-- input: the upper float4 boundary
-- output: boolean represented as float4 (1.0 for true, 0.0 for false)

BEGIN
    RAISE NOTICE 'check_float4_within_bounds function called with value = %, lower_bound = %, upper_bound = %', value, lower_bound, upper_bound;
    IF value > lower_bound AND value < upper_bound THEN
        RAISE NOTICE 'Value is within bounds - returning 1.0';
        RETURN 1.0;
    ELSE
        RAISE NOTICE 'Value is outside bounds - returning 0.0';
        RETURN 0.0;
    END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'check_float4_within_bounds_within', plpgsql_check_float4_within_bounds(5.75::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'check_float4_within_bounds_outside', plpgsql_check_float4_within_bounds(-3.14::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 0.0::FLOAT4;
```

#### plpgsql_check_float4_within_tolerance✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_check_float4_within_tolerance(float4_num1 FLOAT4, float4_num2 FLOAT4, tolerance FLOAT4) RETURNS BOOLEAN AS $$
-- name: check_float4_within_tolerance
-- description: Checks if two float4 numbers are within a specified tolerance
-- type: float4
-- input: First float4 number to compare
-- input: Second float4 number to compare
-- input: The float4 tolerance within which the two numbers are considered equal
-- output: Boolean float4 indicating if the numbers are within the tolerance

DECLARE
  within_tolerance BOOLEAN := false;
  difference FLOAT4;
BEGIN
  RAISE NOTICE 'FUNCTION check_float4_within_tolerance - Called with inputs float4_num1 = %, float4_num2 = %, tolerance = %', float4_num1, float4_num2, tolerance;
  
  difference := ABS(float4_num1 - float4_num2);
  
  IF difference <= tolerance THEN
    within_tolerance := true;
  END IF;
  
  RAISE NOTICE 'FUNCTION check_float4_within_tolerance - Result is %', within_tolerance;
  
  RETURN within_tolerance;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'check_float4_within_tolerance_within', plpgsql_check_float4_within_tolerance(100.0::FLOAT4, 100.05::FLOAT4, 0.1::FLOAT4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'check_float4_within_tolerance_not_within', plpgsql_check_float4_within_tolerance(200.0::FLOAT4, 200.2::FLOAT4, 0.3::FLOAT4);
```

#### plpgsql_clamp_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_clamp_value(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS FLOAT4 AS $$
-- name: clamp_value
-- description: Clamps a given float4 value between a minimum and maximum float4 range
-- type: float4
-- input: The float4 value to be clamped
-- input: The minimum float4 value in the range
-- input: The maximum float4 value in the range
-- output: The clamped float4 value

BEGIN
    RAISE NOTICE 'clamp_value function called with value = %, min_value = %, max_value = %', value, min_value, max_value;
    IF value < min_value THEN
        RAISE NOTICE 'Value is less than min_value, returning min_value: %', min_value;
        RETURN min_value;
    ELSIF value > max_value THEN
        RAISE NOTICE 'Value is greater than max_value, returning max_value: %', max_value;
        RETURN max_value;
    ELSE
        RAISE NOTICE 'Value is within the range, returning value: %', value;
        RETURN value;
    END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_clampValue1', plpgsql_clamp_value(2.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_clampValue2', plpgsql_clamp_value(4.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 4.5::FLOAT4;
```

#### plpgsql_combine_second_third_power✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_combine_second_third_power(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: combine_second_third_power
-- description: Combines the second power of the first float4 input with the third power of the second float4 input by adding them together.
-- type: float4
-- input: The first float4 input for which the second power is calculated
-- input: The second float4 input for which the third power is calculated
-- output: The result of adding the second power of input1 and the third power of input2, returned as float4

DECLARE
   result FLOAT4;
BEGIN
   RAISE NOTICE 'combine_second_third_power function called with input1 = %, input2 = %', input1, input2;
    
   -- Calculate the second power (square) of input1
   -- Calculate the third power (cube) of input2
   -- Add the results
   result := (input1 ^ 2) + (input2 ^ 3);
   
   RAISE NOTICE 'Result of combine_second_third_power: %', result;
   RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'combine_second_third_power_positive_float4_inputs', plpgsql_combine_second_third_power(4.0::FLOAT4, 2.0::FLOAT4) = 24.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'combine_second_third_power_one_positive_one_negative_float4_inputs', plpgsql_combine_second_third_power(-1.5::FLOAT4, 3.0::FLOAT4) = 29.25::FLOAT4;
```

#### plpgsql_compare_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_compare_float4_values(value1 float4, value2 float4) RETURNS float4 AS $$
-- name: compare_float4_values
-- description: Compares two float4 values and determines if the first is greater than the second.
-- type: float4
-- input: First float4 value for comparison
-- input: Second float4 value for comparison
-- output: Boolean represented as float4 (1.0 for true, 0.0 for false)

DECLARE
    result float4 := 0.0;
BEGIN
    RAISE NOTICE 'compare_float4_values function called with value1 = %, value2 = %', value1, value2;
    IF value1 > value2 THEN
        result := 1.0;
    END IF;
    RAISE NOTICE 'Result of compare_float4_values: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'compare_float4_values_test1', plpgsql_compare_float4_values(3.5::float4, 2.7::float4) = 1.0::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'compare_float4_values_test2', plpgsql_compare_float4_values(1.4::float4, 1.8::float4) = 0.0::float4;
```

#### plpgsql_compute_circle_area✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_compute_circle_area(radius FLOAT4) RETURNS FLOAT4 AS $$
-- name: compute_circle_area
-- description: This function calculates the area of a circle given the radius as a float4 type.
-- type: float4
-- input: The radius of the circle as a float4
-- output: The area of the circle as a float4

DECLARE
    pi FLOAT4 := 3.14159;
    area FLOAT4;
BEGIN
    RAISE NOTICE 'compute_circle_area function called with radius = %', radius;
    IF radius IS NULL THEN
        RAISE EXCEPTION 'Radius cannot be NULL';
    END IF;
    IF radius < 0 THEN
        RAISE EXCEPTION 'Radius must be non-negative';
    END IF;
    area := pi * radius * radius;
    RAISE NOTICE 'Area computed: %', area;
    RETURN area;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_compute_circle_area_small_radius', plpgsql_compute_circle_area(2.5::FLOAT4) = 19.634937::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_compute_circle_area_large_radius', plpgsql_compute_circle_area(100.0::FLOAT4) = 31415.9::FLOAT4;
```

#### plpgsql_compute_float4_quotient_and_remainder✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_compute_float4_quotient_and_remainder(dividend float4, divisor float4) RETURNS JSON AS $$
-- name: compute_float4_quotient_and_remainder
-- description: Compute the quotient and remainder of the division of two float4 numbers
-- type: float4
-- input: The float4 number being divided
-- input: The float4 number by which the dividend is divided
-- output: A JSON object with float4 quotient and remainder

DECLARE
    quotient float4;
    remainder float4;
    result JSON;
BEGIN
    RAISE NOTICE 'compute_float4_quotient_and_remainder function called with dividend = %, divisor = %', dividend, divisor;
    
    IF divisor = 0 THEN
        RAISE EXCEPTION 'Division by zero error';
    END IF;
    
    quotient := dividend / divisor;
    remainder := dividend - (quotient * divisor);
    
    result := json_build_object('quotient', quotient, 'remainder', remainder);
    
    RAISE NOTICE 'Result of compute_float4_quotient_and_remainder: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'computeFloat4QuotientAndRemainderPositive', 
CAST(plpgsql_compute_float4_quotient_and_remainder(8.75::FLOAT4, 2.50::FLOAT4) AS JSONB) = 
'{"quotient": 3.5, "remainder": 0.0}'::JSONB;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 
    'plpgsql-float4', 
    'computeFloat4QuotientAndRemainderNegByPos', 
    (plpgsql_compute_float4_quotient_and_remainder(-5.5::FLOAT4, 2.2::FLOAT4)::JSONB)
    = 
    (('{"quotient": -2.5, "remainder": 0}'::JSONB)::TEXT)::JSONB;

-- calculate_exponential_growth
```

#### plpgsql_compute_square_root✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_compute_square_root(input_number FLOAT4) RETURNS FLOAT4 AS $$
-- name: compute_square_root
-- description: Computes the square root of a given float4 input and returns the result as float4
-- type: float4
-- input: The float4 number to compute the square root of
-- output: The float4 square root of the input number

DECLARE
    result FLOAT4;
BEGIN
    RAISE NOTICE 'compute_square_root function called with input_number = %', input_number;
    IF input_number < 0 THEN
        RAISE EXCEPTION 'Input number must be greater than or equal to zero';
    ELSIF input_number = 0 THEN
        result := 0;
    ELSE
        result := sqrt(input_number); -- Using built-in PostgreSQL sqrt function
    END IF;
    RAISE NOTICE 'Result of compute_square_root: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_computeSquareRoot1', plpgsql_compute_square_root(16.0::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_computeSquareRoot2', plpgsql_compute_square_root(0.0::FLOAT4) = 0.0::FLOAT4;
```

#### plpgsql_compute_tangent✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_compute_tangent(angle_in_radians FLOAT4) RETURNS FLOAT4 AS $$
-- name: compute_tangent
-- description: Computes the tangent of a float4 angle value in radians and returns the result as float4
-- type: float4
-- input: The angle in radians for which to compute the tangent, as a float4
-- output: The tangent of the angle as float4

DECLARE
    result FLOAT4;
BEGIN
    RAISE NOTICE 'compute_tangent function called with angle_in_radians = %', angle_in_radians;
    
    -- Ensure the input angle is not PI/2 or 3*PI/2 where the tangent is not defined
    IF angle_in_radians = pi() / 2 OR angle_in_radians = 3 * pi() / 2 THEN
        RAISE EXCEPTION 'Input angle cannot be PI/2 or 3*PI/2 as tangent is not defined at these points.';
    END IF;
    
    -- Calculate the tangent of the input angle
    result := tan(angle_in_radians);

    -- Return the result as a float4
    RAISE NOTICE 'Result of compute_tangent: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
-- Test Cases
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'computeTangentOfZero', plpgsql_compute_tangent(0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'computeTangentOfPIOver4', plpgsql_compute_tangent(0.785398163::FLOAT4) = 1.0::FLOAT4;
```

#### plpgsql_convert_float4_to_negative✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_convert_float4_to_negative(number FLOAT4) RETURNS FLOAT4 AS $$
-- name: convert_float4_to_negative
-- description: This function converts a float4 number to its negative equivalent.
-- type: float4
-- input: float4 number to be negated
-- output: The negative equivalent of the input as float4

BEGIN
    RAISE NOTICE 'convert_float4_to_negative function called with number = %', number;
    IF number >= 0 THEN
        number := number * -1;
    END IF;
    RETURN number;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'convert_float4_to_negative1', plpgsql_convert_float4_to_negative(3.5::FLOAT4) = -3.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'convert_float4_to_negative2', plpgsql_convert_float4_to_negative(-2.0::FLOAT4) = -2.0::FLOAT4;
```

#### plpgsql_convert_to_radians✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_convert_to_radians(degrees FLOAT4) RETURNS FLOAT4 AS $$
-- name: convert_to_radians
-- description: Converts an angle in degrees to radians
-- type: float4
-- input: The angle in degrees to be converted to radians as float4
-- output: The angle in radians as float4

DECLARE
    pi CONSTANT FLOAT4 := 3.1415927;
    radians FLOAT4;
BEGIN
    RAISE NOTICE 'convert_to_radians function called with degrees = %', degrees;
    radians := (degrees * pi) / 180.0;
    RAISE NOTICE 'Result of convert_to_radians: %', radians;
    RETURN radians;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'convert_to_radians0', plpgsql_convert_to_radians(0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'convert_to_radians180', plpgsql_convert_to_radians(180.0::FLOAT4) = 3.1415927::FLOAT4;
```

#### plpgsql_find_nearest_multiple_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_find_nearest_multiple_float4(number FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
-- name: find_nearest_multiple_float4
-- description: Finds the nearest multiple of a divisor close to the given float4 number
-- type: float4
-- input: The original float4 value for which the nearest multiple is to be found
-- input: The divisor float4 value whose multiple is to be found nearest to the number
-- output: The nearest multiple of the divisor float4 value to the original number as float4

DECLARE
    quotient FLOAT4;
    rounded_quotient FLOAT4;
    nearest_multiple FLOAT4;
BEGIN
    -- Debug message
    RAISE NOTICE 'find_nearest_multiple_float4 function called with number = %, divisor = %', number, divisor;

    -- Dividing number by divisor to get the quotient
    quotient := number / divisor;
    
    -- Rounding quotient to the nearest whole number
    rounded_quotient := ROUND(quotient);

    -- Multiplying by divisor to get the nearest multiple
    nearest_multiple := rounded_quotient * divisor;

    -- Debug message
    RAISE NOTICE 'The nearest multiple of % to % is %', divisor, number, nearest_multiple;

    -- Return the nearest multiple
    RETURN nearest_multiple;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'find_nearest_multiple_float41', plpgsql_find_nearest_multiple_float4(14.2::FLOAT4, 5.0::FLOAT4) = 15.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'find_nearest_multiple_float42', plpgsql_find_nearest_multiple_float4(7.7::FLOAT4, 3.5::FLOAT4) = 7.0::FLOAT4;

-- subtract_float4_values
```

#### plpgsql_float4_absolute_value_test✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_float4_absolute_value_test(number float4) RETURNS float4 AS $$
-- name: float4_absolute_value_test
-- description: Function to compute the absolute value of a float4 number
-- type: float4
-- input: A float4 value representing the number to find the absolute value for
-- output: float4 absolute value of the input number

DECLARE
    abs_value float4;
BEGIN
    RAISE NOTICE 'float4_absolute_value_test function called with number = %', number;
    -- Check if the input number is less than zero to determine the absolute value
    IF number < 0 THEN
        abs_value := -number;
    ELSE
        abs_value := number;
    END IF;
    RAISE NOTICE 'Absolute value of input number is: %', abs_value;
    RETURN abs_value;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_float4_absolute_value_test_negative', plpgsql_float4_absolute_value_test(-123.45::float4) = 123.45::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_float4_absolute_value_test_positive', plpgsql_float4_absolute_value_test(678.9::float4) = 678.9::float4;
```

#### plpgsql_float4_min_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_float4_min_value(number1 FLOAT4, number2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: float4_min_value
-- description: Finds the minimum value between two float4 numbers
-- type: float4
-- input: First float4 number for comparison
-- input: Second float4 number for comparison
-- output: Returns the minimum value as float4

DECLARE
    min_value FLOAT4;
BEGIN
    RAISE NOTICE 'float4_min_value function called with number1 = %, number2 = %', number1, number2;
    min_value := number1; -- Initialize min_value as the first input number
    
    -- Compare the second input number with min_value
    IF number2 < min_value THEN
        min_value := number2; -- Assign second number to min_value if it is lesser
    END IF;
    
    RAISE NOTICE 'Result of float4_min_value: %', min_value;
    RETURN min_value; -- Return min_value as the result
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'float4_min_value_positive_first_lesser', plpgsql_float4_min_value(3.5::FLOAT4, 7.25::FLOAT4) = 3.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'float4_min_value_first_negative_second_positive', plpgsql_float4_min_value(-2.0::FLOAT4, 4.75::FLOAT4) = -2.0::FLOAT4;
```

#### plpgsql_is_float4_in_decreasing_order✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_is_float4_in_decreasing_order(number1 FLOAT4, number2 FLOAT4) RETURNS BOOLEAN AS $$
-- name: is_float4_in_decreasing_order
-- description: Determines if the provided float4 numbers are in strictly decreasing order
-- type: float4
-- input: First number of type float4
-- input: Second number of type float4
-- output: Result of type boolean, true if number1 > number2, false otherwise

BEGIN
    RAISE NOTICE 'is_float4_in_decreasing_order function called with number1 = %, number2 = %', number1, number2;
    RETURN number1 > number2;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'is_float4_in_decreasing_order_case1', plpgsql_is_float4_in_decreasing_order(6.5::FLOAT4, 3.24::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'is_float4_in_decreasing_order_case2', plpgsql_is_float4_in_decreasing_order(5.5::FLOAT4, 5.5::FLOAT4) = FALSE;
```

#### plpgsql_is_float4_in_range✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_is_float4_in_range(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS BOOLEAN AS $$
-- name: is_float4_in_range
-- description: Determines if a float4 value falls within a specified inclusive range, defined by a minimum and maximum float4 value.
-- type: float4
-- input: The float4 value to check
-- input: The inclusive minimum value of the range as float4
-- input: The inclusive maximum value of the range as float4
-- output: Returns true if the value is within the range, otherwise false

BEGIN
    RAISE NOTICE 'is_float4_in_range function called with value = %, min_value = %, max_value = %', value, min_value, max_value;
    IF value >= min_value AND value <= max_value THEN
        RAISE NOTICE 'Result of is_float4_in_range: %', TRUE;
        RETURN TRUE;
    ELSE
        RAISE NOTICE 'Result of is_float4_in_range: %', FALSE;
        RETURN FALSE;
    END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'is_float4_in_range_within_range', plpgsql_is_float4_in_range(3.5::FLOAT4, 1.0::FLOAT4, 5.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'is_float4_in_range_outside_range', plpgsql_is_float4_in_range(6.5::FLOAT4, 1.0::FLOAT4, 5.0::FLOAT4) = FALSE;
```

#### plpgsql_is_float4_zero✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_is_float4_zero(number float4) RETURNS boolean AS $$
-- name: is_float4_zero
-- description: Checks if the provided float4 number is zero
-- type: float4
-- input: the input float4 number to check
-- output: returns true if number is 0.0, false otherwise

DECLARE
  threshold CONSTANT float4 := 0.0001;
BEGIN
  RAISE NOTICE 'is_float4_zero function called with number = %', number;
  IF ABS(number) <= threshold THEN
    RAISE NOTICE 'Result of is_float4_zero: %', TRUE;
    RETURN TRUE;
  ELSE
    RAISE NOTICE 'Result of is_float4_zero: %', FALSE;
    RETURN FALSE;
  END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'is_float4_zero_TestZero', plpgsql_is_float4_zero(0.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'is_float4_zero_TestCloseToZero', plpgsql_is_float4_zero(0.00001::FLOAT4) = TRUE;
```

#### plpgsql_is_negative✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_is_negative(number float4) RETURNS boolean AS $$
-- name: is_negative
-- description: Determines if a float4 value is negative
-- type: float4
-- input: the float4 number to check
-- output: boolean indicating if the number is negative

BEGIN
    RAISE NOTICE 'is_negative function called with number = %', number;
    IF number < 0 THEN
        RAISE NOTICE 'Result of is_negative: true';
        RETURN true;
    ELSE
        RAISE NOTICE 'Result of is_negative: false';
        RETURN false;
    END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_is_negative_negative', plpgsql_is_negative(-3.14::float4) = true;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_is_negative_not_negative', plpgsql_is_negative(6.28::float4) = false;
```

#### plpgsql_normalize_float4_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_normalize_float4_value(value float4, min_value float4, max_value float4) RETURNS float4 AS $$
-- name: normalize_float4_value
-- description: Normalize a float4 number to the range of 0 to 1 based on provided minimum and maximum values
-- type: float4
-- input: the float4 number to normalize
-- input: the minimum float4 value of the range
-- input: the maximum float4 value of the range
-- output: the normalized float4 number

DECLARE
    distance_from_minimum float4;
    range_size float4;
    normalized_value float4;
BEGIN
    RAISE NOTICE 'normalize_float4_value function called with value = %, min_value = %, max_value = %', value, min_value, max_value;

    IF min_value >= max_value THEN
        RAISE EXCEPTION 'min_value must be less than max_value';
    END IF;

    distance_from_minimum := value - min_value;
    range_size := max_value - min_value;
    normalized_value := distance_from_minimum / range_size;

    RAISE NOTICE 'Result of normalize_float4_value: %', normalized_value;
    RETURN normalized_value;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_normalizeFloat4ValueWithinRange', plpgsql_normalize_float4_value(10.0::FLOAT4, 0.0::FLOAT4, 20.0::FLOAT4) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_normalizeFloat4ValueAtTopOfRange', plpgsql_normalize_float4_value(20.0::FLOAT4, 10.0::FLOAT4, 20.0::FLOAT4) = 1.0::FLOAT4;
```

#### plpgsql_subtract_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_subtract_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
-- name: subtract_float4_values
-- description: Subtracts the second float4 value from the first and returns the result as float4
-- type: float4
-- input: First float4 value to be used in subtraction
-- input: Second float4 value to subtract from the first value
-- output: Result of subtraction as float4

DECLARE
    result FLOAT4;
BEGIN
    RAISE NOTICE 'subtract_float4_values function called with value1 = %, value2 = %', value1, value2;
    result := value1 - value2;
    RAISE NOTICE 'Result of subtract_float4_values: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_subtractFloat4ValuesPositive', ROUND(plpgsql_subtract_float4_values(5.7::FLOAT4, 2.3::FLOAT4)::NUMERIC, 1) = 3.4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_subtractFloat4ValuesNegByPos', plpgsql_subtract_float4_values(-1.2::FLOAT4, 4.6::FLOAT4) = -5.8::FLOAT4;
```

#### plpgsql_test_cosine_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_test_cosine_float4(angle FLOAT4) RETURNS FLOAT4 AS $$
-- name: test_cosine_float4
-- description: Calculates the cosine of a float4 angle value in radians and returns the result as float4
-- type: float4
-- input: Angle in radians for which the cosine has to be calculated (float4)
-- output: The cosine of the provided angle (float4)

DECLARE
    result FLOAT4;
BEGIN
    RAISE NOTICE 'test_cosine_float4 function called with angle = %', angle;
    -- Ensuring angle is a float4 representing radians is implicitly guaranteed by the function signature
    result := COS(angle);
    RAISE NOTICE 'Result of test_cosine_float4: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_cosine_float40', plpgsql_test_cosine_float4(0.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_cosine_float4PIby2', ABS(plpgsql_test_cosine_float4(1.5707963::FLOAT4) - 0.0::FLOAT4) < 0.000001;
```

#### plpgsql_test_float4_power✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_test_float4_power(base FLOAT4, exponent FLOAT4) RETURNS FLOAT4 AS $$
-- name: test_float4_power
-- description: Raises a float4 base number to the power of a float4 exponent
-- type: float4
-- input: float4 base number
-- input: float4 exponent value
-- output: float4 result of raising base to the power of exponent

DECLARE
    result FLOAT4;
BEGIN
    RAISE NOTICE 'test_float4_power function called with base = %, exponent = %', base, exponent;

    IF exponent = 0 THEN
        result := 1.0::FLOAT4;
    ELSIF base = 0 THEN
        result := 0.0::FLOAT4;
    ELSE
        result := POWER(base::FLOAT8, exponent::FLOAT8)::FLOAT4;
    END IF;

    RAISE NOTICE 'Result of test_float4_power: %', result;

    RETURN result::FLOAT4;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_float4_power_non_zero_base_positive_exponent', plpgsql_test_float4_power(2.0::FLOAT4, 3.0::FLOAT4) = 8.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_float4_power_non_zero_base_non_integer_exponent', plpgsql_test_float4_power(9.0::FLOAT4, 0.5::FLOAT4) = 3.0::FLOAT4;
```

#### plpgsql_test_float4_rounding✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_test_float4_rounding(original_value FLOAT4) RETURNS FLOAT4 AS $$
-- name: test_float4_rounding
-- description: This function rounds a float4 value to the nearest whole number and returns it as float4.
-- type: float4
-- input: A float4 value to be rounded to the nearest whole number
-- output: Rounded float4 value to the nearest whole number

DECLARE
    rounded_value FLOAT4;
BEGIN
    RAISE NOTICE 'test_float4_rounding function called with original_value = %', original_value;
    rounded_value := ROUND(original_value);
    RAISE NOTICE 'Rounded value: %', rounded_value;
    RETURN rounded_value;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plpgsql-float4', 'test_float4_rounding_positive', plpgsql_test_float4_rounding(2.5::FLOAT4) = 2.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plpgsql-float4', 'test_float4_rounding_negative', plpgsql_test_float4_rounding(-3.7::FLOAT4) = -4.0::FLOAT4;
```

#### plpgsql_test_float4_truncation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_test_float4_truncation(number float4) RETURNS float4 AS $$
-- name: test_float4_truncation
-- description: Truncates a float4 number, removing its decimal part.
-- type: float4
-- input: A float4 number to be truncated
-- output: The truncated float4 number

BEGIN
    RAISE NOTICE 'test_float4_truncation function called with number = %', number;
    RETURN trunc(number);
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_float4_truncation_positive', plpgsql_test_float4_truncation(123.456::FLOAT4) = 123.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_float4_truncation_negative', plpgsql_test_float4_truncation(-123.456::FLOAT4) = -123.0::FLOAT4;
```

#### plpgsql_test_increment_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_test_increment_float4(number float4, increment float4) RETURNS float4 AS $$
-- name: test_increment_float4
-- description: This function increments a float4 value by a float4 increment and returns the result as float4.
-- type: float4
-- input: The float4 number to be incremented
-- input: The float4 value to increment the number by
-- output: The incremented float4 value

DECLARE
    result float4;
BEGIN
    RAISE NOTICE 'test_increment_float4 function called with number = %, increment = %', number, increment;
    result := number + increment;
    RAISE NOTICE 'Result of test_increment_float4: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_increment_float41', plpgsql_test_increment_float4(8.25::FLOAT4, 1.75::FLOAT4) = 10.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_increment_float42', plpgsql_test_increment_float4(-3.5::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;
```

#### plpgsql_test_maximum_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_test_maximum_value(input1 float4, input2 float4) RETURNS float4 AS $$
-- name: test_maximum_value
-- description: Function to determine the maximum of two float4 values
-- type: float4
-- input: First float4 value to compare
-- input: Second float4 value to compare
-- output: Returns the maximum of the two float4 inputs

DECLARE
    result float4;
BEGIN
    RAISE NOTICE 'test_maximum_value function called with input1 = %, input2 = %', input1, input2;
    IF input1 >= input2 THEN
        result := input1;
    ELSE
        result := input2;
    END IF;
    RAISE NOTICE 'Result of test_maximum_value: %', result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_maximum_value_first_greater', plpgsql_test_maximum_value(12.34::FLOAT4, 9.87::FLOAT4) = 12.34::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'test_maximum_value_second_greater', plpgsql_test_maximum_value(-3.21::FLOAT4, 4.56::FLOAT4) = 4.56::FLOAT4;
```

#### plpgsql_validate_even_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_validate_even_float4(value FLOAT4) RETURNS BOOLEAN AS $$
-- name: validate_even_float4
-- description: Determines whether a float4 number represents an even number
-- type: float4
-- input: The float4 number to check
-- output: Returns true if the number is even, otherwise false

DECLARE
    nearest_whole_number INT;
    result BOOLEAN;
BEGIN
    RAISE NOTICE 'validate_even_float4 function called with value = %', value;
    
    -- Convert to the nearest smaller whole number
    nearest_whole_number := FLOOR(value);
    
    -- Perform the modulo operation
    result := (nearest_whole_number % 2) = 0;
    
    RAISE NOTICE 'Result of validate_even_float4: %', result;
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'validate_even_float4_test_case1', plpgsql_validate_even_float4(4.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'validate_even_float4_test_case2', plpgsql_validate_even_float4(5.0::FLOAT4) = FALSE;
```

#### plpgsql_validate_float4_within_range✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpgsql_validate_float4_within_range(number FLOAT4, range_min FLOAT4, range_max FLOAT4) RETURNS FLOAT4 AS $$
-- name: validate_float4_within_range
-- description: validate whether the float4 number falls within the exclusive range (min, max)
-- type: float4
-- input: the float4 number to validate
-- input: the minimum float4 boundary of the range
-- input: the maximum float4 boundary of the range
-- output: boolean represented as float4 (1.0 for true, 0.0 for false)

BEGIN
    RAISE NOTICE 'validate_float4_within_range function called with number = %, range_min = %, range_max = %', number, range_min, range_max;
    IF number > range_min AND number < range_max THEN
        RETURN 1.0;
    ELSE
        RETURN 0.0;
    END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'validateFloat4WithinRange1', plpgsql_validate_float4_within_range(5.5::FLOAT4, 5.0::FLOAT4, 6.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpgsql-float4', 'validateFloat4WithinRange2', plpgsql_validate_float4_within_range(4.0::FLOAT4, 5.0::FLOAT4, 6.0::FLOAT4) = 0.0::FLOAT4;
```

### plpython3u

#### plpython3u_add_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_add_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
# name: add_float4_values
# description: Function that adds two float4 values and returns the result as float4
# type: float4
# input: float4 value to be added to value2
# input: float4 value to be added to value1
# output: Sum of value1 and value2 as float4

    plpy.info("add_float4_values function called with value1 = " + str(value1) + ", value2 = " + str(value2))
    result = value1 + value2
    plpy.info("Result of add_float4_values: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_addFloat4ValuesPositive', plpython3u_add_float4_values(1.5::FLOAT4, 2.5::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_addFloat4ValuesMixed', plpython3u_add_float4_values(-1.25::FLOAT4, 3.75::FLOAT4) = 2.5::FLOAT4;
```

#### plpython3u_average_of_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_average_of_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
# name: average_of_float4_values
# description: Calculates the average of two float4 values
# type: float4
# input: First float4 value
# input: Second float4 value
# output: The average value as float4

    plpy.info(f"DEBUG: FUNCTION plpython3u_average_of_float4_values - Running average_of_float4_values function with inputs 'value1' = {value1}, 'value2' = {value2}.")
    if value1 is None or value2 is None:
        raise ValueError("Input values cannot be None.")
    sum = value1 + value2
    average = sum / 2
    result = float(average)
    plpy.info(f"DEBUG: FUNCTION plpython3u_average_of_float4_values - Function average_of_float4_values is returning 'average' = {result}.")
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'averageOfFloat4ValuesPositives', plpython3u_average_of_float4_values(4.0::FLOAT4, 8.0::FLOAT4) = 6.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'averageOfFloat4ValuesNegatives', plpython3u_average_of_float4_values(-2.5::FLOAT4, -7.5::FLOAT4) = -5.0::FLOAT4;
```

#### plpython3u_calculate_arccosine✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_arccosine(value FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_arccosine
# description: Calculates the arccosine (inverse cosine) of a float4 value
# type: float4
# input: A float4 representing the cosine of an angle, range -1 to 1
# output: The arccosine of the input value as float4 in radians

    import math
    plpy.info("plpython3u_calculate_arccosine function called with value = " + str(value))
    
    if value < -1.0 or value > 1.0:
        raise Exception("Input value must be within the range of -1 to 1 inclusive.")
    
    result = math.acos(value)
    plpy.info("Result of plpython3u_calculate_arccosine: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateArccosineOf0', ROUND(plpython3u_calculate_arccosine(0::FLOAT4)::NUMERIC, 4) = ROUND(1.5708::NUMERIC, 4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateArccosineOf1', plpython3u_calculate_arccosine(1::FLOAT4) = 0::FLOAT4;
```

#### plpython3u_calculate_area_of_rectangle✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_area_of_rectangle(width float4, height float4) RETURNS float4 AS $$
# name: calculate_area_of_rectangle
# description: This function calculates the area of a rectangle given the width and height as float4 types and returns the area as float4
# type: float4
# input: float4 type representing the width of the rectangle
# input: float4 type representing the height of the rectangle
# output: float4 type representing the area of the rectangle

    plpy.info(f"calculate_area_of_rectangle function called with width = {width}, height = {height}")
    if width is None or height is None:
        raise ValueError("Width and Height should not be None")
    area = float(width) * float(height)
    plpy.info(f"Result of calculate_area_of_rectangle: {area}")
    return area
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_area_of_rectangle1', plpython3u_calculate_area_of_rectangle(4.0::FLOAT4, 3.0::FLOAT4) = 12.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_area_of_rectangle2', plpython3u_calculate_area_of_rectangle(0.0::FLOAT4, 5.0::FLOAT4) = 0.0::FLOAT4;
```

#### plpython3u_calculate_arithmetic_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_arithmetic_mean(value1 float4, value2 float4) RETURNS float4 AS $$
# name: calculate_arithmetic_mean
# description: Calculates arithmetic mean of two float4 values
# type: float4
# input: First float4 input value.
# input: Second float4 input value.
# output: Arithmetic mean result as float4.

    plpy.info("calculate_arithmetic_mean function called with value1 = " + str(value1) + ", value2 = " + str(value2))
    total = value1 + value2
    count = 2
    result = total / count
    plpy.info("Result of calculate_arithmetic_mean: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateArithmeticMeanPositive', plpython3u_calculate_arithmetic_mean(3.5::FLOAT4, 2.5::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateArithmeticMeanPosNeg', plpython3u_calculate_arithmetic_mean(5.0::FLOAT4, -3.0::FLOAT4) = 1.0::FLOAT4;
```

#### plpython3u_calculate_arithmetic_progression_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_arithmetic_progression_sum(a float4, d float4, n float4) RETURNS float4 AS $$
# name: calculate_arithmetic_progression_sum
# description: Calculate the sum of the first n terms of an arithmetic progression, given the first term (a), the common difference (d), and the number of terms (n), returning the sum as float4.
# type: float4
# input: the first term of the arithmetic progression (float4)
# input: the common difference between the terms (float4)
# input: the number of terms to sum (float4)
# output: the sum of the first n terms of the arithmetic progression (float4)

    plpy.info(f"calculate_arithmetic_progression_sum function called with a = {a}, d = {d}, n = {n}")
    
    # Handle None values for input parameters
    if a is None or d is None or n is None:
        raise Exception("Input parameters cannot be null")
    
    # Implementation of the arithmetic progression sum formula
    part1 = n * a
    part2 = d * (n - 1)
    sn = (part1 + (part2 * n) / 2)
    
    plpy.info(f"Result of calculate_arithmetic_progression_sum: {sn}")
    return sn
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateArithmeticProgressionSum1', plpython3u_calculate_arithmetic_progression_sum(2.0::FLOAT4, 2.0::FLOAT4, 5.0::FLOAT4) = 30.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateArithmeticProgressionSum2', plpython3u_calculate_arithmetic_progression_sum(1.5::FLOAT4, 1.5::FLOAT4, 3.0::FLOAT4) = 9.0::FLOAT4;
```

#### plpython3u_calculate_ceil✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_ceil(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_ceil
# description: This function calculates and returns the smallest integer greater than or equal to the given float4 number.
# type: float4
# input: A float4 number to calculate the ceiling value for
# output: The ceiling value of the input as float4

import math
plpy.info("calculate_ceil function called with number = " + str(number))
result = math.ceil(number)
plpy.info("Result of calculate_ceil: " + str(result))
return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateCeilPositive', plpython3u_calculate_ceil(3.45::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateCeilNegative', plpython3u_calculate_ceil(-1.78::FLOAT4) = -1.0::FLOAT4;
```

#### plpython3u_calculate_circumference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_circumference(radius float4) RETURNS float4 AS $$
# name: calculate_circumference
# description: Calculates the circumference of a circle given the radius as float4
# type: float4
# input: The radius of the circle as float4
# output: The circumference of the circle as float4

    plpy.info("calculate_circumference function called with radius = " + str(radius))
    PI = 3.1415926535
    diameter = radius * 2.0
    circumference = diameter * PI
    plpy.info("Result of calculate_circumference: " + str(circumference))
    return circumference
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculateCircumferenceSmallRadius', plpython3u_calculate_circumference(2.0::float4) = 12.566370614::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculateCircumferenceLargeRadius', plpython3u_calculate_circumference(100.0::float4) = 628.3185307179584::float4;
```

#### plpython3u_calculate_decibel_level✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_decibel_level(sound_pressure FLOAT4, reference_pressure FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_decibel_level
# description: Calculates the decibel level of a sound by comparing it to a reference sound pressure level.
# type: float4
# input: The sound pressure of the sound for which to determine the decibel level, as float4.
# input: The reference sound pressure which is typically the threshold of human hearing, as float4.
# output: The decibel level of the sound compared to the reference sound pressure, as float4.

    plpy.info(f"calculate_decibel_level function called with sound_pressure = {sound_pressure}, reference_pressure = {reference_pressure}")
    
    # Ensure the sound pressure and reference pressure are positive float4 numbers
    if sound_pressure <= 0 or reference_pressure <= 0:
        raise ValueError("Both sound_pressure and reference_pressure must be positive.")
    
    # Calculate the ratio of the sound pressure to the reference pressure
    ratio = sound_pressure / reference_pressure
    
    # Logarithmic conversion: compute the logarithm base 10 of the ratio
    log_ratio = plpy.execute(f"SELECT LOG({ratio})")[0]['log']
    
    # Multiply the result of the logarithm by 20 to get the decibel level
    decibel_level = 20 * log_ratio
    
    plpy.info(f"Result of calculate_decibel_level: {decibel_level}")
    
    # Return the decibel level as float4
    return decibel_level
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_decibel_level1', ROUND(plpython3u_calculate_decibel_level(1.0::FLOAT4, 0.00002::FLOAT4)) = 94.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_decibel_level2', plpython3u_calculate_decibel_level(0.00002::FLOAT4, 0.00002::FLOAT4) = 0.0::FLOAT4;
```

#### plpython3u_calculate_distance_between_float4_points✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_distance_between_float4_points(x1 float4, y1 float4, x2 float4, y2 float4) RETURNS float4 AS $$
# name: calculate_distance_between_float4_points
# description: Calculates the distance between two points in 2D space using float4 for coordinates
# type: float4
# input: The x-coordinate of the first point as a float4
# input: The y-coordinate of the first point as a float4
# input: The x-coordinate of the second point as a float4
# input: The y-coordinate of the second point as a float4
# output: The distance between the two points as a float4

    plpy.info("calculate_distance_between_float4_points function called with x1 = {}, y1 = {}, x2 = {}, y2 = {}".format(x1, y1, x2, y2))
    delta_x = x2 - x1
    delta_y = y2 - y1
    sum_of_squares = delta_x ** 2 + delta_y ** 2
    distance = sum_of_squares ** 0.5
    plpy.info("Result of calculate_distance_between_float4_points: {}".format(distance))
    return distance
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateDistanceBetweenFloat4Points1', plpython3u_calculate_distance_between_float4_points(0.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateDistanceBetweenFloat4Points2', plpython3u_calculate_distance_between_float4_points(3.0::FLOAT4, 4.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4) = 5.0::FLOAT4;
```

#### plpython3u_calculate_euclidean_distance❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_euclidean_distance(point1 json, point2 json) RETURNS float4 AS $$
# name: calculate_euclidean_distance
# description: Calculates the Euclidean distance between two points in 3D space.
# type: float4
# input: First point as an object with float4 x, y, z coordinates
# input: Second point as an object with float4 x, y, z coordinates
# output: The Euclidean distance between the two points as float4

    plpy.info("calculate_euclidean_distance function called with point1 = " + str(point1) + ", point2 = " + str(point2))

    x1, y1, z1 = point1['x'], point1['y'], point1['z']
    x2, y2, z2 = point2['x'], point2['y'], point2['z']
    
    difference_squares = (x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2
    distance = float4(difference_squares ** 0.5)
    
    plpy.info("Result of calculate_euclidean_distance: " + str(distance))
    return distance
$$ LANGUAGE plpython3u;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_euclidean_distance1', plpython3u_calculate_euclidean_distance('{"x": 1.0, "y": 2.0, "z": 3.0}'::json, '{"x": 4.0, "y": 5.0, "z": 6.0}'::json)::float4 = 5.1962::float4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_euclidean_distance2', plpython3u_calculate_euclidean_distance('{"x": 7.0, "y": 8.0, "z": 9.0}'::json, '{"x": 7.0, "y": 8.0, "z": 9.0}'::json)::float4 = 0.0::float4;
```

#### plpython3u_calculate_exponential_growth✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_exponential_growth(initial_value FLOAT4, growth_rate FLOAT4, time_period FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_exponential_growth
# description: This function calculates the exponential growth based on initial value, growth rate, and time period.
# type: float4
# input: Initial quantity as float4
# input: Growth rate (in percentage) as float4
# input: Time period over which to calculate as float4
# output: Returns the amount after growth as float4

    plpy.info("calculate_exponential_growth function called with initial_value = " + str(initial_value) + 
              ", growth_rate = " + str(growth_rate) + ", time_period = " + str(time_period))
    growth_rate_decimal = growth_rate / 100.0
    growth_factor = 1.0 + growth_rate_decimal
    final_amount = initial_value * (growth_factor ** time_period)
    result = round(final_amount, 4)  # Assuming float4 precision requires rounding to four decimal places
    plpy.info("Result of calculate_exponential_growth: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_exponential_growth_10_years', 
    plpython3u_calculate_exponential_growth(100.0::FLOAT4, 5.0::FLOAT4, 10.0::FLOAT4) = 162.8895::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_exponential_growth_5_years', 
    plpython3u_calculate_exponential_growth(1000.0::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 1159.274::FLOAT4;
```

#### plpython3u_calculate_float4_as_percentage_of_another✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_as_percentage_of_another(value FLOAT4, total FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_as_percentage_of_another
# description: Calculates one float4 value as a percentage of another float4 value.
# type: float4
# input: The float4 number to calculate the percentage for
# input: The float4 number representing the total or 100%
# output: The percentage of 'value' relative to 'total' as float4

    plpy.info("plpython3u_calculate_float4_as_percentage_of_another function called with value = " + str(value) + ", total = " + str(total))
    if total == 0:
        raise ValueError("Total cannot be zero.")
    percentage = (value / total) * 100.0
    plpy.info("Result of plpython3u_calculate_float4_as_percentage_of_another: " + str(percentage))
    return percentage
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_as_percentage_of_another_known_percentage', plpython3u_calculate_float4_as_percentage_of_another(25.0::FLOAT4, 50.0::FLOAT4) = 50.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_as_percentage_of_another_fractional_percentage', plpython3u_calculate_float4_as_percentage_of_another(1.0::FLOAT4, 200.0::FLOAT4) = 0.5::FLOAT4;
```

#### plpython3u_calculate_float4_ceil❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_ceil(value FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_ceil
# description: Function to calculate the smallest integer greater than or equal to the given float4 number
# type: float4
# input: float4 value to find the ceiling value for
# output: float4 representing the smallest integer greater than or equal to the input

    plpy.info("calculate_float4_ceil function called with value = " + str(value))
    ceiling_value = math.ceil(value)
    plpy.info("Result of calculate_float4_ceil: " + str(ceiling_value))
    return ceiling_value
$$ LANGUAGE plpython3u;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_ceil_PositiveDecimal', plpython3u_calculate_float4_ceil(3.45::FLOAT4) = 4.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_ceil_NegativeDecimal', plpython3u_calculate_float4_ceil(-2.8::FLOAT4) = -2.0::FLOAT4;
```

#### plpython3u_calculate_float4_complement✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_complement(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_complement
# description: Calculates the complement of a float4 number with respect to 1, that is, it calculates 1 - n for a given float4 n.
# type: float4
# input: A float4 number which is the value to find the complement of.
# output: The complement of the input float4 number with respect to 1 as float4.

    plpy.info("calculate_float4_complement function called with number = " + str(number))
    if not isinstance(number, float):
        raise TypeError("Input must be a float4 type.")
    result = 1.0 - number
    result = float(result)  # Ensuring the result is float4
    plpy.info("Result of calculate_float4_complement: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_complement_test_case_1', plpython3u_calculate_float4_complement(0.25::FLOAT4) = 0.75::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_complement_test_case_2', plpython3u_calculate_float4_complement(1.25::FLOAT4) = -0.25::FLOAT4;
```

#### plpython3u_calculate_float4_division✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_division(dividend float4, divisor float4) RETURNS float4 AS $$
# name: calculate_float4_division
# description: This function takes two float4 values and divides the first by the second, returning a float4.
# type: float4
# input: The float4 number to be divided
# input: The float4 number to divide by
# output: The result of the division as a float4

    plpy.info("calculate_float4_division function called with dividend = " + str(dividend) + ", divisor = " + str(divisor))
    if divisor == 0:
        plpy.error("Division by zero is not allowed.")
    result = dividend / divisor
    plpy.info("Result of calculate_float4_division: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_float4_division1', plpython3u_calculate_float4_division(10.5::FLOAT4, 2.5::FLOAT4) = 4.2::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_float4_division2', plpython3u_calculate_float4_division(3.3::FLOAT4, 4.4::FLOAT4) = 0.75::FLOAT4;
```

#### plpython3u_calculate_float4_dot_product✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_dot_product(vector1_x float4, vector1_y float4, vector2_x float4, vector2_y float4) RETURNS float4 AS $$
# name: calculate_float4_dot_product
# description: Calculates the dot product of two 2D vectors, each vector component is a float4 type
# type: float4
# input: x component of the first vector (float4)
# input: y component of the first vector (float4)
# input: x component of the second vector (float4)
# input: y component of the second vector (float4)
# output: dot product of the two vectors (float4)

    plpy.info("calculate_float4_dot_product function called with vector1_x = " + str(vector1_x) + ", vector1_y = " + str(vector1_y) + ", vector2_x = " + str(vector2_x) + ", vector2_y = " + str(vector2_y))
    
    product_x = vector1_x * vector2_x
    product_y = vector1_y * vector2_y
    dot_product = product_x + product_y
    
    plpy.info("Dot product is: " + str(dot_product))
    return dot_product
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_float4_dot_product_perpendicular', plpython3u_calculate_float4_dot_product(1.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 1.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_float4_dot_product_parallel', plpython3u_calculate_float4_dot_product(1.0::FLOAT4, 1.0::FLOAT4, 2.0::FLOAT4, 2.0::FLOAT4) = 4.0::FLOAT4;
```

#### plpython3u_calculate_float4_exponentiation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_exponentiation(base FLOAT4, exponent FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_exponentiation
# description: Calculates the base raised to the power of exponent, both of float4 type, and returns float4
# type: float4
# input: float4 number to be raised to the power of the exponent
# input: float4 number representing the power
# output: float4 result of the exponentiation

    plpy.info("calculate_float4_exponentiation function called with base = " + str(base) + ", exponent = " + str(exponent))
    if exponent == 0:
        return 1.0
    if base == 0:
        return 0.0
    result = base ** exponent
    return float(result)
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_exponentiation_positive_base_and_exponent', plpython3u_calculate_float4_exponentiation(2.5::FLOAT4, 3.0::FLOAT4) = 15.625::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_exponentiation_negative_base_and_positive_exponent', plpython3u_calculate_float4_exponentiation(-3.0::FLOAT4, 2.0::FLOAT4) = 9.0::FLOAT4;
```

#### plpython3u_calculate_float4_exponentiation_remainder✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_exponentiation_remainder(base FLOAT4, exponent INTEGER, divisor FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_exponentiation_remainder
# description: Calculates the remainder of the exponentiation of a float4 base raised to an integer exponent when divided by a float4 divisor.
# type: float4
# input: the base value as float4
# input: the exponent value as integer
# input: the divisor value as float4
# output: the remainder as float4

    plpy.info("calculate_float4_exponentiation_remainder function called with base = {}, exponent = {}, divisor = {}".format(base, exponent, divisor))
    if base is None or divisor is None or exponent is None:
        raise Exception('Input parameters should not be null')
    
    exponent_as_float = float(exponent)
    exponentiation_result = base ** exponent_as_float
    
    if divisor == 0:
        raise ValueError('Divisor cannot be zero')
    
    remainder = exponentiation_result % divisor
    
    plpy.info("Result of calculate_float4_exponentiation_remainder: {}".format(remainder))
    return remainder
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateFloat4ExponentiationRemainderPositive', plpython3u_calculate_float4_exponentiation_remainder(2.5::FLOAT4, 3, 3.2::FLOAT4) = 2.8249998092651367::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateFloat4ExponentiationRemainderNegativeExp', plpython3u_calculate_float4_exponentiation_remainder(5.1::FLOAT4, -2, 2.0::FLOAT4) = 1.1::FLOAT4;
```

#### plpython3u_calculate_float4_factorial✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_factorial(number float4) RETURNS float4 AS $$
# name: calculate_float4_factorial
# description: Calculates the factorial of a non-negative float4 number, rounding down to the nearest whole value before computation.
# type: float4
# input: A non-negative float4 number to calculate the factorial of
# output: The factorial of the input number as float4, or 'undefined' if input is negative

    plpy.info("calculate_float4_factorial function called with number = " + str(number))
    rounded_number = int(number)
    
    if rounded_number < 0:
        plpy.info("Result of calculate_float4_factorial: undefined (input is negative)")
        return 'undefined'

    if rounded_number in (0, 1):
        plpy.info("Result of calculate_float4_factorial: 1.0 (input is 0 or 1)")
        return 1.0

    result = 1.0
    for i in range(2, rounded_number + 1):
        result *= i
        
    plpy.info("Result of calculate_float4_factorial: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_float4_factorial_positive_less_than_one', plpython3u_calculate_float4_factorial(0.85::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_float4_factorial_typical', plpython3u_calculate_float4_factorial(5.75::FLOAT4) = 120.0::FLOAT4;
```

#### plpython3u_calculate_float4_geometric_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_geometric_mean(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_geometric_mean
# description: Calculates the geometric mean of two float4 numbers and returns the result as float4
# type: float4
# input: The first positive float4 value
# input: The second positive float4 value
# output: The geometric mean of input float4 values as float4

import math

plpy.info("calculate_float4_geometric_mean function called with value1 = {}, value2 = {}".format(value1, value2))
if value1 <= 0 or value2 <= 0:
    raise ValueError("Both input values must be greater than zero")

product = value1 * value2
geometric_mean = math.sqrt(product)
plpy.info("Result of calculate_float4_geometric_mean: {}".format(geometric_mean))

return geometric_mean
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_geometric_mean_small_values', plpython3u_calculate_float4_geometric_mean(1.0::FLOAT4, 4.0::FLOAT4) = 2.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_geometric_mean_large_values', plpython3u_calculate_float4_geometric_mean(1.0::FLOAT4, 10000.0::FLOAT4) = 100.0::FLOAT4;
```

#### plpython3u_calculate_float4_inverse✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_inverse(numeric_value FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_inverse
# description: Calculates the multiplicative inverse (or reciprocal) of a non-zero float4 number
# type: float4
# input: The float4 number to invert
# output: The multiplicative inverse of the input as float4, or 'undefined' if the input is zero

    plpy.info("calculate_float4_inverse function called with numeric_value = " + str(numeric_value))
    if numeric_value == 0.0:
        plpy.info("Result of calculate_float4_inverse: undefined because the input is zero.")
        return 'undefined'
    else:
        result = 1.0 / numeric_value
        plpy.info("Result of calculate_float4_inverse: " + str(result))
        return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_inverse_non_zero', plpython3u_calculate_float4_inverse(2.0::FLOAT4) = 0.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_inverse_zero', plpython3u_calculate_float4_inverse(0.0::FLOAT4) = 'undefined';
```

#### plpython3u_calculate_float4_inverse_ratio✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_inverse_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_inverse_ratio
# description: Calculates the inverse ratio of two float4 numbers, returns the result as float4.
# type: float4
# input: First float4 value, acting as the numerator
# input: Second float4 value, acting as the denominator, expected not to be zero
# output: The inverse ratio of the two float4 input values

    plpy.info(f"calculate_float4_inverse_ratio function called with numerator = {numerator}, denominator = {denominator}")
    if denominator == 0:
        raise Exception("Denominator should not be zero.")
    reciprocal = 1.0 / denominator
    result = reciprocal * numerator
    plpy.info(f"Result of calculate_float4_inverse_ratio: {result}")
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateFloat4InverseRatioPositive', plpython3u_calculate_float4_inverse_ratio(2.0::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateFloat4InverseRatioZeroNumerator', plpython3u_calculate_float4_inverse_ratio(0.0::FLOAT4, 3.0::FLOAT4) = 0.0::FLOAT4;
```

#### plpython3u_calculate_float4_inverse_square_root✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_inverse_square_root(number float4) RETURNS float4 AS $$
# name: calculate_float4_inverse_square_root
# description: Calculate the inverse square root of a float4 number
# type: float4
# input: The float4 number for which to find the inverse square root
# output: The inverse square root of the input number as float4

    plpy.info("calculate_float4_inverse_square_root function called with number = " + str(number))
    if number is None or number <= 0:
        plpy.info("Input is not greater than 0, result is undefined")
        return 'undefined'
    else:
        result = 1.0 / (number ** 0.5)
        plpy.info("Result of calculate_float4_inverse_square_root: " + str(result))
        return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_float4_inverse_square_root1', plpython3u_calculate_float4_inverse_square_root(4.0::FLOAT4) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_float4_inverse_square_root2', plpython3u_calculate_float4_inverse_square_root(0.25::FLOAT4) = 2.0::FLOAT4;
```

#### plpython3u_calculate_float4_linear_intercept✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_linear_intercept(x1 float4, y1 float4, x2 float4, y2 float4) RETURNS float4 AS $$
# name: calculate_float4_linear_intercept
# description: Calculates the y-intercept of a line (b) given two points with float4 coordinates (x1, y1) and (x2, y2). The formula used is b = y1 - (slope * x1), where slope is the (y2 - y1) / (x2 - x1).
# type: float4
# input: The x-coordinate of the first point as float4
# input: The y-coordinate of the first point as float4
# input: The x-coordinate of the second point as float4
# input: The y-coordinate of the second point as float4
# output: The y-intercept (b) of the line as float4

    if x2 == x1:
        plpy.error('Division by zero: x2 cannot be equal to x1')
    
    plpy.info("calculate_float4_linear_intercept function called with x1 = " + str(x1) + ", y1 = " + str(y1) + ", x2 = " + str(x2) + ", y2 = " + str(y2))
    
    slope = (y2 - y1) / (x2 - x1)
    y_intercept = y1 - (slope * x1)
    
    plpy.info("Result of calculate_float4_linear_intercept: " + str(y_intercept))
    
    return y_intercept
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_linear_intercept_positiveslope', plpython3u_calculate_float4_linear_intercept(2.0::FLOAT4, 3.0::FLOAT4, 4.0::FLOAT4, 7.0::FLOAT4) = -1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_linear_intercept_negativeslope', plpython3u_calculate_float4_linear_intercept(5.0::FLOAT4, 8.0::FLOAT4, 3.0::FLOAT4, 4.0::FLOAT4) = -2.0::FLOAT4;
```

#### plpython3u_calculate_float4_logarithm_base2✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_logarithm_base2(value FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_logarithm_base2
# description: Calculates the base-2 logarithm of a given float4 number and returns the result as float4.
# type: float4
# input: The float4 number for which to calculate the base-2 logarithm
# output: The base-2 logarithm of the input float4 number

    from math import log2
    
    plpy.info("calculate_float4_logarithm_base2 function called with value = " + str(value))
    
    if value <= 0:
        raise ValueError("Input value must be positive.")
    
    result = log2(value)
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_logarithm_base2_PositiveValue1', plpython3u_calculate_float4_logarithm_base2(8.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_logarithm_base2_PositiveValue2', plpython3u_calculate_float4_logarithm_base2(2.0::FLOAT4) = 1.0::FLOAT4;
```

#### plpython3u_calculate_float4_max_absolute_difference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_max_absolute_difference(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_max_absolute_difference
# description: This function calculates the maximum absolute difference between two float4 values
# type: float4
# input: The first float4 input value
# input: The second float4 input value
# output: The maximum absolute difference as float4

    plpy.info("calculate_float4_max_absolute_difference function called with input1 = " + str(input1) + ", input2 = " + str(input2))
    abs_diff1 = abs(input1 - input2)
    abs_diff2 = abs(input2 - input1)
    max_abs_diff = max(abs_diff1, abs_diff2)
    plpy.info("Result of calculate_float4_max_absolute_difference: " + str(max_abs_diff))
    return max_abs_diff
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_max_absolute_difference1', plpython3u_calculate_float4_max_absolute_difference(5.5::FLOAT4, 3.0::FLOAT4) = 2.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_max_absolute_difference2', plpython3u_calculate_float4_max_absolute_difference(2.2::FLOAT4, 4.8::FLOAT4) = 2.6000001430511475::FLOAT4;
```

#### plpython3u_calculate_float4_modulo✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_modulo(dividend FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_modulo
# description: Calculates the modulo (the remainder of division) of two float4 values and returns the result as float4
# type: float4
# input: The number that is to be divided (dividend) as float4
# input: The number by which the dividend is to be divided (divisor) as float4
# output: The remainder of the division of the two float4 inputs

    plpy.info("calculate_float4_modulo function called with dividend = " + str(dividend) + ", divisor = " + str(divisor))

    if divisor == 0.0:
        plpy.error("Divisor cannot be zero")
    
    quotient = float(dividend) / float(divisor)
    multiplied = quotient * float(divisor)
    remainder = float(dividend) - multiplied

    plpy.info("Result of calculate_float4_modulo: " + str(remainder))
    return remainder
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_float4_modulo_1', plpython3u_calculate_float4_modulo(8.75::FLOAT4, 3.5::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_float4_modulo_2', plpython3u_calculate_float4_modulo(-5.25::FLOAT4, 2.0::FLOAT4) = 0.0::FLOAT4;
```

#### plpython3u_calculate_float4_percentage_change❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_percentage_change(old_value float4, new_value float4) RETURNS float4 AS $$
# name: calculate_float4_percentage_change
# description: Calculates the percentage change from float4 old_value to float4 new_value.
# type: float4
# input: The original float4 value
# input: The new float4 value to compare against the old value
# output: The percentage change as float4

    plpy.info("calculate_float4_percentage_change function called with old_value = " + str(old_value) + ", new_value = " + str(new_value))
    
    if old_value is None or new_value is None:
        plpy.error("Input values cannot be NULL")
    
    if old_value == 0:
        plpy.error("old_value cannot be zero to avoid division by zero")
    
    difference = new_value - old_value
    percentage_change = (difference / old_value) * 100
    result = float4(percentage_change)
    
    plpy.info("Result of calculate_float4_percentage_change: " + str(result))
    return result
$$ LANGUAGE plpython3u;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_percentage_change_greater', plpython3u_calculate_float4_percentage_change(50.0::FLOAT4, 75.0::FLOAT4) = 50.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_percentage_change_lesser', plpython3u_calculate_float4_percentage_change(75.0::FLOAT4, 50.0::FLOAT4) = -33.3333::FLOAT4;
```

#### plpython3u_calculate_float4_precision✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_precision(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_precision
# description: Calculates the precision (number of decimal places) of a float4 number
# type: float4
# input: A float4 number to calculate the precision of
# output: The precision (number of decimal places) of the number as float4

    plpy.info("calculate_float4_precision function called with number = " + str(number))
    number_str = str(number)
    decimal_point_index = number_str.find('.')
    
    if decimal_point_index == -1:
        precision = 0.0
    else:
        precision = float(len(number_str[decimal_point_index+1:]))
    
    plpy.info("Result of calculate_float4_precision: " + str(precision))
    return precision
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_float4_precision1', plpython3u_calculate_float4_precision(123.44999694824219::FLOAT4) = 14.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_float4_precision2', plpython3u_calculate_float4_precision(456.0::FLOAT4) = 1.0::FLOAT4;
```

#### plpython3u_calculate_float4_quadratic_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_quadratic_sum(num1 float4, num2 float4, num3 float4) RETURNS float4 AS $$
# name: calculate_float4_quadratic_sum
# description: Calculates the sum of squares of three float4 numbers and returns the result as float4.
# type: float4
# input: First float4 number
# input: Second float4 number
# input: Third float4 number
# output: Sum of squares of num1, num2, and num3 as float4

    # Debugging log with input values
    plpy.info("calculate_float4_quadratic_sum function called with num1 = " + str(num1) + ", num2 = " + str(num2) + ", num3 = " + str(num3))
    
    # Calculating square of each input
    result1 = num1 * num1
    result2 = num2 * num2
    result3 = num3 * num3

    # Summing the squares
    sum_of_squares = result1 + result2 + result3

    # Debugging log with output value
    plpy.info("Result of calculate_float4_quadratic_sum: " + str(sum_of_squares))
    
    return sum_of_squares
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_float4_quadratic_sum_positive', plpython3u_calculate_float4_quadratic_sum(3.0::FLOAT4, 4.0::FLOAT4, 5.0::FLOAT4) = 50.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_float4_quadratic_sum_mixed', plpython3u_calculate_float4_quadratic_sum(-3.0::FLOAT4, 4.0::FLOAT4, -5.0::FLOAT4) = 50.0::FLOAT4;
```

#### plpython3u_calculate_float4_quotient_and_product✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_quotient_and_product(value1 float4, value2 float4) RETURNS float4[] AS $$
# name: calculate_float4_quotient_and_product
# description: This function calculates both the quotient and the product of two float4 values and returns them as a float4 array.
# type: float4
# input: First float4 input value
# input: Second float4 input value, not equal to zero
# output: Array of float4 with the first element being the quotient and the second being the product of the inputs

    plpy.info("calculate_float4_quotient_and_product function called with value1 = " + str(value1) + ", value2 = " + str(value2))
    if value2 == 0:
        raise Exception("The divisor (value2) cannot be zero.")
    results = [None, None]
    results[0] = value1 / value2
    results[1] = value1 * value2
    plpy.info("Result of calculate_float4_quotient_and_product: quotient = " + str(results[0]) + ", product = " + str(results[1]))
    return results
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plpython3u-float4', 'test_calculate_float4_quotient_and_product_positive_values',
ARRAY[1.75::float4, 7.0::float4] = plpython3u_calculate_float4_quotient_and_product(3.5::float4, 2.0::float4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plpython3u-float4', 'test_calculate_float4_quotient_and_product_neg_by_pos_values',
ARRAY[-2.0::float4, -8.0::float4] = plpython3u_calculate_float4_quotient_and_product(-4.0::float4, 2.0::float4);
```

#### plpython3u_calculate_float4_ratio✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_ratio
# description: Calculates the ratio of two float4 numbers and returns the result as float4. Ratio is the result of dividing the first float4 value by the second, provided the second is not zero.
# type: float4
# input: The numerator for the ratio calculation. Type: float4
# input: The denominator for the ratio calculation. Type: float4. Must not be zero.
# output: The calculated ratio as float4. If the denominator is zero, the function will return NULL.

    plpy.info("plpython3u_calculate_float4_ratio function called with numerator = " + str(numerator) + ", denominator = " + str(denominator))
    if denominator == 0.0:
        plpy.info("Denominator is zero, returning NULL")
        return None
    else:
        result = numerator / denominator
        plpy.info("Result of calculate_float4_ratio: " + str(result))
        return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_ratio_positive', plpython3u_calculate_float4_ratio(25.0::FLOAT4, 5.0::FLOAT4) = 5.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_ratio_zero_denominator', plpython3u_calculate_float4_ratio(10.0::FLOAT4, 0.0::FLOAT4) IS NULL;
```

#### plpython3u_calculate_float4_ratio_and_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_ratio_and_sum(number1 FLOAT4, number2 FLOAT4) RETURNS json AS $$
# name: calculate_float4_ratio_and_sum
# description: Calculates the ratio of two float4 numbers and their sum
# type: float4
# input: First float4 number
# input: Second float4 number, cannot be zero as it will be used as divisor
# output: An object with the ratio and sum of the two float4 numbers

    # Debugging information
    plpy.info("calculate_float4_ratio_and_sum function called with number1 = " + str(number1) + ", number2 = " + str(number2))

    # Check if number2 is not zero to avoid division by zero
    if number2 == 0:
        plpy.error("Division by zero is not allowed")
    
    # Divide number1 by number2 to find the ratio and store it as float4
    ratio = float(number1) / float(number2)
    
    # Add number1 and number2 to calculate the sum and store it as float4
    sum_value = float(number1) + float(number2)
    
    # Create an object with keys 'ratio' and 'sum' and assign the calculated values respectively
    result = {"ratio": ratio, "sum": sum_value}
    
    # Debugging information about the result
    plpy.info("Result of calculate_float4_ratio_and_sum: " + str(result))
    
    # Return the result as a JSON object
    import json
    return json.dumps(result)
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_ratio_and_sum1', (plpython3u_calculate_float4_ratio_and_sum(6.0::FLOAT4, 3.0::FLOAT4)::json->>'ratio')::FLOAT4 = 2.0::FLOAT4 AND (plpython3u_calculate_float4_ratio_and_sum(6.0::FLOAT4, 3.0::FLOAT4)::json->>'sum')::FLOAT4 = 9.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_ratio_and_sum2', (plpython3u_calculate_float4_ratio_and_sum(-8.0::FLOAT4, 4.0::FLOAT4)::json->>'ratio')::FLOAT4 = -2.0::FLOAT4 AND (plpython3u_calculate_float4_ratio_and_sum(-8.0::FLOAT4, 4.0::FLOAT4)::json->>'sum')::FLOAT4 = -4.0::FLOAT4;
```

#### plpython3u_calculate_float4_remainder✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_remainder(dividend FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_remainder
# description: Calculates the remainder of division between two float4 numbers
# type: float4
# input: float4 value representing the dividend
# input: float4 value representing the divisor
# output: float4 value representing the remainder of the division

    plpy.info("calculate_float4_remainder function called with dividend = " + str(dividend) + ", divisor = " + str(divisor))
    if divisor == 0.0:
        plpy.info("Division by zero is not possible, returning null.")
        return None
    remainder = dividend % divisor
    plpy.info("Remainder: " + str(remainder))
    return remainder
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_remainder_positive', plpython3u_calculate_float4_remainder(5.0::FLOAT4, 2.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_remainder_division_by_zero', plpython3u_calculate_float4_remainder(5.0::FLOAT4, 0.0::FLOAT4) IS NULL;
```

#### plpython3u_calculate_float4_rounded_average❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_rounded_average(value1 float4, value2 float4) RETURNS float4 AS $$
# name: calculate_float4_rounded_average
# description: Calculate the average of two float4 values and round it to the nearest whole number, returning the result as a float4
# type: float4
# input: The first float4 value for the average calculation
# input: The second float4 value for the average calculation
# output: The rounded average of value1 and value2 as a float4

    plpy.info("calculate_float4_rounded_average function called with value1 = " + str(value1) + ", value2 = " + str(value2))
    if value1 is None or value2 is None:
        raise Exception("Input values cannot be null")
    average = (value1 + value2) / 2.0
    rounded_average = round(average)
    plpy.info("Result of calculate_float4_rounded_average: " + str(rounded_average))
    return float4(rounded_average)
$$ LANGUAGE plpython3u;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateFloat4RoundedAveragePositives', plpython3u_calculate_float4_rounded_average(25.4::FLOAT4, 34.6::FLOAT4) = 30.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateFloat4RoundedAveragePosNeg', plpython3u_calculate_float4_rounded_average(-14.8::FLOAT4, 20.2::FLOAT4) = 3.0::FLOAT4;
```

#### plpython3u_calculate_float4_to_power_of_integer✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_to_power_of_integer(float4_base FLOAT4, integer_exponent INTEGER) RETURNS FLOAT4 AS $$
# name: calculate_float4_to_power_of_integer
# description: This function takes a float4 base number and an integer exponent, then raises the base to the power of the exponent returning a float4 result
# type: float4
# input: float4 number serving as the base for the power operation
# input: Integer serving as the exponent for the power operation
# output: float4 result of the base raised to the power of the exponent

    plpy.info("calculate_float4_to_power_of_integer function called with float4_base = " + str(float4_base) + ", integer_exponent = " + str(integer_exponent))
    if float4_base is None or integer_exponent is None:
        raise plpy.Error("Input values cannot be null")
    result = float4_base ** integer_exponent
    plpy.info("Result of calculate_float4_to_power_of_integer: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_to_power_of_integer1', plpython3u_calculate_float4_to_power_of_integer(2.5::FLOAT4, 3::INTEGER) = 15.625::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_to_power_of_integer2', plpython3u_calculate_float4_to_power_of_integer(7.0::FLOAT4, 0::INTEGER) = 1.0::FLOAT4;
```

#### plpython3u_calculate_float4_with_exponential_notation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_float4_with_exponential_notation(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_with_exponential_notation
# description: Converts a float4 number in exponential notation to a float4 number in standard decimal notation
# type: float4
# input: float4 number in exponential notation
# output: float4 number in standard decimal notation

    plpy.info("calculate_float4_with_exponential_notation function called with number = " + str(number))
    try:
        result = float(number)
        plpy.info("Result of calculate_float4_with_exponential_notation: " + str(result))
        return result
    except Exception as e:
        plpy.error("Conversion error: " + str(e))
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_with_exponential_notation_small', plpython3u_calculate_float4_with_exponential_notation('2.5e-4'::FLOAT4) = '0.00025'::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_float4_with_exponential_notation_large', plpython3u_calculate_float4_with_exponential_notation('3.57e+2'::FLOAT4) = '357.0'::FLOAT4;
```

#### plpython3u_calculate_harmonic_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_harmonic_mean(number1 FLOAT4, number2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_harmonic_mean
# description: Calculates the harmonic mean of two float4 numbers
# type: float4
# input: First float4 number
# input: Second float4 number
# output: Harmonic mean of the two float4 numbers as float4

    plpy.info("calculate_harmonic_mean function called with number1 = " + str(number1) + ", number2 = " + str(number2))
    
    # Check if any number is 0, return 'undefined'
    if number1 == 0.0 or number2 == 0.0:
        plpy.info("One of the numbers is zero, returning NULL instead of 'undefined'")
        return None
    
    # Calculate the reciprocal of each number
    reciprocal1 = 1.0 / number1
    reciprocal2 = 1.0 / number2
    
    # Sum the reciprocals and divide 2 by the sum
    harmonic_mean = 2.0 / (reciprocal1 + reciprocal2)
    
    plpy.info("Calculated harmonic mean: " + str(harmonic_mean))
    return harmonic_mean
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plpython3u-float4', 'test_calculate_harmonic_mean_positive', 
       plpython3u_calculate_harmonic_mean(4.0::FLOAT4, 8.0::FLOAT4) = 5.3333334::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plpython3u-float4', 'test_calculate_harmonic_mean_zero', 
       plpython3u_calculate_harmonic_mean(0.0::FLOAT4, 5.0::FLOAT4) IS NULL;
```

#### plpython3u_calculate_hypotenuse✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_hypotenuse(a FLOAT4, b FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_hypotenuse
# description: Calculates the length of the hypotenuse of a right-angled triangle using the Pythagorean theorem
# type: float4
# input: length of side a as float4
# input: length of side b as float4
# output: length of the hypotenuse as float4

    import math
    plpy.info("calculate_hypotenuse function called with a = " + str(a) + ", b = " + str(b))
    squared_a = a ** 2
    squared_b = b ** 2
    sum_of_squares = squared_a + squared_b
    result = math.sqrt(sum_of_squares)
    plpy.info("Result of calculate_hypotenuse: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_hypotenuse1', plpython3u_calculate_hypotenuse(3.0::FLOAT4, 4.0::FLOAT4) = 5.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_hypotenuse2', plpython3u_calculate_hypotenuse(5.0::FLOAT4, 12.0::FLOAT4) = 13.0::FLOAT4;
```

#### plpython3u_calculate_inscribed_circle_area✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_inscribed_circle_area(side_length FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_inscribed_circle_area
# description: Calculates the area of an inscribed circle within a square where each side is of float4 type length.
# type: float4
# input: The length of the side of the square of type float4
# output: The area of the inscribed circle as float4

    import math
    plpy.info("calculate_inscribed_circle_area function called with side_length = " + str(side_length))
    
    if side_length is None or side_length <= 0:
        plpy.error("Invalid side length. Must be a positive float4 value.")
    
    radius = side_length / 2
    area = math.pi * radius * radius

    plpy.info("Result of calculate_inscribed_circle_area: " + str(area))
    return area
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_inscribed_circle_area2', ROUND(CAST(plpython3u_calculate_inscribed_circle_area(5.4::FLOAT4) AS NUMERIC), 2) = 22.90;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_inscribed_circle_area1', plpython3u_calculate_inscribed_circle_area(2.0::FLOAT4) = 3.14159::FLOAT4;
```

#### plpython3u_calculate_linear_intercept✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_linear_intercept(x1 float4, y1 float4, m float4) RETURNS float4 AS $$
# name: calculate_linear_intercept
# description: Calculates the y-intercept (b) of a linear equation in the form y = mx + b using a point (x1, y1) and the slope (m)
# type: float4
# input: float4 - the x-coordinate of the point
# input: float4 - the y-coordinate of the point
# input: float4 - the slope of the line
# output: float4 - the y-intercept of the line

    plpy.info("calculate_linear_intercept function called with x1 = {}, y1 = {}, m = {}".format(x1, y1, m))
    # Multiply the slope (m) by the x-coordinate (x1)
    mx1 = m * x1
    # Subtract the result from the y-coordinate (y1) to find the y-intercept (b)
    b = y1 - mx1
    plpy.info("Result of calculate_linear_intercept: {}".format(b))
    return b
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_linear_intercept1', plpython3u_calculate_linear_intercept(3.0::float4, 4.0::float4, 2.0::float4) = -2.0::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_linear_intercept2', plpython3u_calculate_linear_intercept(-1.0::float4, -3.0::float4, -2.0::float4) = -5.0::float4;
```

#### plpython3u_calculate_linear_interpolation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_linear_interpolation(value1 FLOAT4, value2 FLOAT4, fraction FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_linear_interpolation
# description: Interpolates between two float4 values at a specific increment
# type: float4
# input: starting float4 value for interpolation
# input: ending float4 value for interpolation
# input: the float4 fraction representing the interpolation point between value1 and value2
# output: interpolated float4 value

    plpy.info("DEBUG: FUNCTION plpython3u_calculate_linear_interpolation - Running with inputs value1 = {}, value2 = {}, fraction = {}".format(value1, value2, fraction))
    if not 0 <= fraction <= 1:
        raise ValueError("Fraction must be between 0.0 and 1.0 inclusive.")
    result = value1 + (value2 - value1) * fraction
    plpy.info("DEBUG: FUNCTION plpython3u_calculate_linear_interpolation - Result = {}".format(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_linear_interpolation_mid_range', plpython3u_calculate_linear_interpolation(10.75::FLOAT4, 20.5::FLOAT4, 0.5::FLOAT4) = 15.625::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_linear_interpolation_near_start', plpython3u_calculate_linear_interpolation(-5.0::FLOAT4, 5.0::FLOAT4, 0.1::FLOAT4) = -4.0::FLOAT4;
```

#### plpython3u_calculate_log_base_n✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_log_base_n(number FLOAT4, base FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_log_base_n
# description: Calculates the logarithm of a float4 number with a float4 custom base and returns the result as float4. Rejects a base that is less than or equal to 0, or equal to 1, and a number that is less than or equal to 0.
# type: float4
# input: Value to find the logarithm of. Must be greater than 0.
# input: Base of the logarithm. Must be greater than 0 and not equal to 1.
# output: Logarithm of the number to the base provided. If the base or number is invalid, the output is 'undefined'.

    plpy.info("calculate_log_base_n function called with number = " + str(number) + ", base = " + str(base))
    # Validate input: base must be > 0 and != 1, number must be > 0
    if base is None or base <= 0 or base == 1 or number is None or number <= 0:
        plpy.info("Invalid base or number. Returning 'undefined'.")
        return 'undefined'

    # Calculate the logarithm if inputs are valid
    import math
    result = math.log(number, base)
    plpy.info("Result of calculate_log_base_n: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_log_base_n1', plpython3u_calculate_log_base_n(32.0::FLOAT4, 2.0::FLOAT4) = 5.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_log_base_n2', plpython3u_calculate_log_base_n(100.0::FLOAT4, 1.0::FLOAT4) = 'undefined';
```

#### plpython3u_calculate_logarithm✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_logarithm(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_logarithm
# description: Calculates the natural logarithm (base e) of a given float4 number and returns the result as float4. If the input is less than or equal to zero, the function will return 'undefined' since the logarithm for non-positive numbers is not defined in real numbers.
# type: float4
# input: The float4 number for which to find the natural logarithm
# output: The natural logarithm of the given float4 number as float4, or 'undefined' if the input is not a positive float4

    import math

    plpy.info("calculate_logarithm function called with number = " + str(number))
    if number is None or number <= 0.0:
        plpy.info("Input is less than or equal to zero, the logarithm is undefined.")
        return 'undefined'
    else:
        result = math.log(number)
        plpy.info("Result of calculate_logarithm: " + str(result))
        return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_logarithm_positive', round(plpython3u_calculate_logarithm(2.7183::FLOAT4)::NUMERIC, 0) = 1.0::NUMERIC;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_logarithm_non_positive', plpython3u_calculate_logarithm(-1.0::FLOAT4) = 'undefined';
```

#### plpython3u_calculate_logarithm_base_ten❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_logarithm_base_ten(number float4) RETURNS float4 AS $$
# name: calculate_logarithm_base_ten
# description: Calculates the logarithm base 10 of a float4 number and returns the result as float4. It assumes positive non-zero input.
# type: float4
# input: The float4 number to calculate the logarithm base 10 of
# output: The float4 result of the logarithm base 10 calculation

import math
plpy.info("calculate_logarithm_base_ten function called with number = " + str(number))
if number <= 0:
    raise Exception("Input must be greater than zero")
result = float4(math.log10(number))
plpy.info("Result of calculate_logarithm_base_ten: " + str(result))
return result
$$ LANGUAGE plpython3u;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateLogarithmBaseTen1', plpython3u_calculate_logarithm_base_ten(100.0::FLOAT4) = 2.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateLogarithmBaseTen2', plpython3u_calculate_logarithm_base_ten(1000.0::FLOAT4) = 3.0::FLOAT4;
```

#### plpython3u_calculate_median_of_two_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_median_of_two_float4(input1 float4, input2 float4) RETURNS float4 AS $$
# name: calculate_median_of_two_float4
# description: Calculates the median of two float4 numbers and returns the result as float4
# type: float4
# input: First float4 input value
# input: Second float4 input value
# output: Median of input1 and input2 as float4

    plpy.info("calculate_median_of_two_float4 function called with input1 = " + str(input1) + ", input2 = " + str(input2))
    median = 0.0
    if input1 == input2:
        median = input1
    else:
        median = (input1 + input2) / 2.0
    plpy.info("Result of calculate_median_of_two_float4: " + str(median))
    return median
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_median_of_two_float41', plpython3u_calculate_median_of_two_float4(10.0::FLOAT4, 10.0::FLOAT4) = 10.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_median_of_two_float42', plpython3u_calculate_median_of_two_float4(10.0::FLOAT4, 20.0::FLOAT4) = 15.0::FLOAT4;
```

#### plpython3u_calculate_percentage_difference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_percentage_difference(value1 float4, value2 float4) RETURNS float4 AS $$
# name: calculate_percentage_difference
# description: Calculates the percentage difference between two float4 values
# type: float4
# input: First float4 value
# input: Second float4 value
# output: Percentage difference as float4

    plpy.info("calculate_percentage_difference function called with value1 = " + str(value1) + ", value2 = " + str(value2))
    if value1 is None or value2 is None:
        raise Exception('Input values cannot be null')
    
    absolute_difference = abs(value1 - value2)
    average_value = (value1 + value2) / 2.0
    percentage_difference = (absolute_difference / average_value) * 100
    plpy.info("Result of calculate_percentage_difference: " + str(percentage_difference))
    return percentage_difference
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_percentage_difference_value1_greater', plpython3u_calculate_percentage_difference(150.0::FLOAT4, 100.0::FLOAT4) = 40.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_percentage_difference_value2_greater', plpython3u_calculate_percentage_difference(75.0::FLOAT4, 125.0::FLOAT4) = 50.0::FLOAT4;
```

#### plpython3u_calculate_product_of_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_product_of_float4(number1 float4, number2 float4) RETURNS float4 AS $$
# name: calculate_product_of_float4
# description: Calculates the product of two float4 numbers and returns the result as a float4
# type: float4
# input: The first float4 number to be multiplied
# input: The second float4 number to be multiplied
# output: The product of the two float4 inputs as a float4

    plpy.info("calculate_product_of_float4 function called with number1 = " + str(number1) + ", number2 = " + str(number2))
    num1 = float(number1)
    num2 = float(number2)
    product = num1 * num2
    plpy.info("Result of calculate_product_of_float4: " + str(product))
    return product
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_product_of_float41', ROUND(CAST(plpython3u_calculate_product_of_float4(3.14::FLOAT4, 1.59::FLOAT4) AS NUMERIC), 4) = 4.9926::NUMERIC;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_product_of_float42', plpython3u_calculate_product_of_float4(-5.0::FLOAT4, 2.5::FLOAT4) = -12.5::FLOAT4;
```

#### plpython3u_calculate_quadratic_roots✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_quadratic_roots(a FLOAT4, b FLOAT4, c FLOAT4) RETURNS FLOAT4[] AS $$
# name: calculate_quadratic_roots
# description: Calculates the roots of a quadratic equation ax^2 + bx + c = 0 using the quadratic formula and returns them as an array of float4
# type: float4
# input: float4 coefficient for x^2
# input: float4 coefficient for x
# input: float4 constant term
# output: array of float4 containing the two roots

    import math
    plpy.info(f"calculate_quadratic_roots function called with a = {a}, b = {b}, c = {c}")
    d = b**2 - 4*a*c  # Calculating the discriminant
    if d < 0:
        plpy.info("Discriminant is negative, no real roots.")
        return []
    elif d == 0:
        root = -b / (2*a)
        return [root]
    else:
        sqrt_d = math.sqrt(d)
        root1 = (-b + sqrt_d) / (2*a)
        root2 = (-b - sqrt_d) / (2*a)
        return [root1, root2]
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_quadratic_roots_test_case_1', ARRAY[3.0::FLOAT4,2.0::FLOAT4] = plpython3u_calculate_quadratic_roots(1::FLOAT4, -5::FLOAT4, 6::FLOAT4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_quadratic_roots_test_case_2', ARRAY[2.0::FLOAT4] = plpython3u_calculate_quadratic_roots(1::FLOAT4, -4::FLOAT4, 4::FLOAT4);
```

#### plpython3u_calculate_scaled_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_scaled_value(value FLOAT4, factor FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_scaled_value
# description: This function takes an input float4 value and scales it by a given float4 factor.
# type: float4
# input: The original float4 value to be scaled
# input: The float4 factor by which to scale the value
# output: The scaled float4 value

    plpy.info("plpython3u_calculate_scaled_value function called with value = " + str(value) + ", factor = " + str(factor))
    result = value * factor
    plpy.info("Result of plpython3u_calculate_scaled_value: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_scaled_value1', plpython3u_calculate_scaled_value(1.5::FLOAT4, 2.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_scaled_value2', plpython3u_calculate_scaled_value(3.0::FLOAT4, 0.5::FLOAT4) = 1.5::FLOAT4;
```

#### plpython3u_calculate_sin✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_sin(angle FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_sin
# description: Calculates the sine of a float4 angle value (in radians) and returns the result as float4
# type: float4
# input: float4 angle in radians for which the sine will be calculated
# output: float4 representing the sine of the input angle

    import math
    plpy.info("calculate_sin function called with angle = " + str(angle))
    # Convert the input angle from degrees to radians if it is not already
    # angle_in_radians = angle * math.pi / 180.0 # Uncomment if input is in degrees

    # Ensuring the input is already in radians, as specified in the pseudocode
    angle_in_radians = angle

    # Use the sine function to calculate the sine of the angle
    result = math.sin(angle_in_radians)

    # Ensure the output is a float4 value
    result = float(result)

    plpy.info("Result of calculate_sin: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_sin0', plpython3u_calculate_sin(0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_sinPI2', plpython3u_calculate_sin(1.5708::FLOAT4) = 1.0::FLOAT4;
```

#### plpython3u_calculate_slope✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_slope(point1 FLOAT4[], point2 FLOAT4[]) RETURNS FLOAT4 AS $$
# name: calculate_slope
# description: Calculates the slope of a line passing through two points in the Cartesian coordinate system
# type: float4
# input: Coordinates (x1, y1) of the first point, type float4 array
# input: Coordinates (x2, y2) of the second point, type float4 array
# output: The slope of the line as float4

    plpy.info("calculate_slope function called with point1 = " + str(point1) + ", point2 = " + str(point2))
    
    # Ensure both input arrays contain exactly two float4 elements (x and y coordinates respectively)
    if len(point1) != 2 or len(point2) != 2:
        raise Exception("Input arrays must exactly contain two elements (x and y coordinates).")

    # Subtract y2 from y1 and store the result as deltaY
    deltaY = point2[1] - point1[1]

    # Subtract x2 from x1 and store the result as deltaX
    deltaX = point2[0] - point1[0]

    # If deltaX equals zero, return None since the slope is infinite (vertical line)
    if deltaX == 0:
        return None

    # Divide deltaY by deltaX to find the slope
    slope = deltaY / deltaX

    # Return the calculated slope as float4
    plpy.info("Result of calculate_slope: " + str(slope))
    return slope
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_slope1', plpython3u_calculate_slope(ARRAY[1.0, 2.0]::FLOAT4[], ARRAY[3.0, 3.0]::FLOAT4[]) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculate_slope2', plpython3u_calculate_slope(ARRAY[4.0, 1.0]::FLOAT4[], ARRAY[4.0, 3.0]::FLOAT4[]) IS NULL;
```

#### plpython3u_calculate_thermal_expansion✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_thermal_expansion(original_length float4, temperature_change float4, coefficient_of_expansion float4) RETURNS float4 AS $$
# name: calculate_thermal_expansion
# description: Calculates the linear thermal expansion of a material given its original length, temperature change, and the material's coefficient of linear expansion
# type: float4
# input: the original length of the material before thermal expansion (float4)
# input: the change in temperature that the material undergoes (float4)
# input: the coefficient of linear expansion of the material (float4)
# output: the new length of the material after thermal expansion (float4)

    plpy.info("calculate_thermal_expansion function called with original_length = " + str(original_length) 
              + ", temperature_change = " + str(temperature_change)
              + ", coefficient_of_expansion = " + str(coefficient_of_expansion))
    if original_length is None or temperature_change is None or coefficient_of_expansion is None:
        raise ValueError("Input values cannot be None.")

    expansion = original_length * temperature_change * coefficient_of_expansion
    new_length = original_length + expansion

    plpy.info("Result of calculate_thermal_expansion: " + str(new_length))
    return new_length
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateThermalExpansion1', plpython3u_calculate_thermal_expansion(10.0::FLOAT4, 0.0005::FLOAT4, 0.000012::FLOAT4) = 10.00000006::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_calculateThermalExpansion2', plpython3u_calculate_thermal_expansion(5.0::FLOAT4, 0.05::FLOAT4, 0.000015::FLOAT4) = 5.00000375::FLOAT4;
```

#### plpython3u_calculate_weight_force✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_calculate_weight_force(mass FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_weight_force
# description: Calculates the force due to weight of an object using the formula F = m * g, where m is mass in kilograms, and g is acceleration due to gravity at 9.81 m/s^2 (represented as float4)
# type: float4
# input: mass of the object as float4
# output: the weight force as float4

    acceleration_due_to_gravity = 9.81  # Define constant acceleration_due_to_gravity as float4
    plpy.info("calculate_weight_force function called with mass = " + str(mass))  # Debugging line
    weight_force = mass * acceleration_due_to_gravity  # Multiply mass by acceleration_due_to_gravity
    plpy.info("Result of calculate_weight_force: " + str(weight_force))  # Debugging line
    return weight_force  # Return the product as the weight force
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_weight_force1', plpython3u_calculate_weight_force(2.0::FLOAT4) = 19.62::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'calculate_weight_force2', plpython3u_calculate_weight_force(5.5::FLOAT4) = 53.955::FLOAT4;
```

#### plpython3u_check_float4_equality✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_check_float4_equality(input1 float4, input2 float4) RETURNS boolean AS $$
# name: check_float4_equality
# description: Checks whether two float4 values are equal
# type: float4
# input: First float4 value to be compared
# input: Second float4 value to be compared
# output: Boolean result determining if the two float4 values are equal

    plpy.info("check_float4_equality function called with input1 = " + str(input1) + ", input2 = " + str(input2))
    result = input1 == input2
    plpy.info("Result of check_float4_equality: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'checkFloat4EqualityEqualValues', plpython3u_check_float4_equality(4.0000::FLOAT4, 4.0000::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'checkFloat4EqualityDifferentValues', plpython3u_check_float4_equality(4.0000::FLOAT4, -3.9999::FLOAT4) = FALSE;
```

#### plpython3u_check_float4_is_positive✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_check_float4_is_positive(number FLOAT4) RETURNS FLOAT4 AS $$
# name: check_float4_is_positive
# description: Determines if a float4 input is positive
# type: float4
# input: The float4 number to check
# output: A float4 representing a boolean true or false, 1.0 for true and 0.0 for false

    plpy.info("check_float4_is_positive function called with number = " + str(number))
    result = 1.0 if number > 0.0 else 0.0
    plpy.info("Result of check_float4_is_positive: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'checkFloat4IsPositivePositive', plpython3u_check_float4_is_positive(0.1::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'checkFloat4IsPositiveNotPositive', plpython3u_check_float4_is_positive(-0.1::FLOAT4) = 0.0::FLOAT4;
```

#### plpython3u_check_float4_within_bounds✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_check_float4_within_bounds(value FLOAT4, lower_bound FLOAT4, upper_bound FLOAT4) RETURNS FLOAT4 AS $$
# name: check_float4_within_bounds
# description: Determines whether a float4 value is between two boundary float4 values (exclusive)
# type: float4
# input: the float4 value to check
# input: the lower float4 boundary
# input: the upper float4 boundary
# output: boolean represented as float4 (1.0 for true, 0.0 for false)

    plpy.info(f"check_float4_within_bounds function called with value = {value}, lower_bound = {lower_bound}, upper_bound = {upper_bound}")
    if value > lower_bound and value < upper_bound:
        plpy.info("check_float4_within_bounds: Value is within bounds.")
        return 1.0
    else:
        plpy.info("check_float4_within_bounds: Value is outside bounds.")
        return 0.0
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'check_float4_within_bounds_within', plpython3u_check_float4_within_bounds(5.75::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'check_float4_within_bounds_outside', plpython3u_check_float4_within_bounds(-3.14::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 0.0::FLOAT4;
```

#### plpython3u_check_float4_within_tolerance✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_check_float4_within_tolerance(float4_num1 float4, float4_num2 float4, tolerance float4) RETURNS boolean AS $$
# name: check_float4_within_tolerance
# description: Checks if two float4 numbers are within a specified tolerance
# type: float4
# input: First float4 number to compare
# input: Second float4 number to compare
# input: The float4 tolerance within which the two numbers are considered equal
# output: Boolean float4 indicating if the numbers are within the tolerance

    plpy.info("check_float4_within_tolerance function called with float4_num1 = " + str(float4_num1) + ", float4_num2 = " + str(float4_num2) + ", tolerance = " + str(tolerance))
    within_tolerance = False
    absolute_difference = abs(float4_num1 - float4_num2)
    if absolute_difference <= tolerance:
        within_tolerance = True
    plpy.info("Result of check_float4_within_tolerance: " + str(within_tolerance))
    return within_tolerance
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'checkFloat4WithinToleranceWithin', plpython3u_check_float4_within_tolerance(100.0::FLOAT4, 100.05::FLOAT4, 0.1::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'checkFloat4WithinToleranceNotWithin', plpython3u_check_float4_within_tolerance(200.0::FLOAT4, 200.2::FLOAT4, 0.1::FLOAT4) = FALSE;
```

#### plpython3u_clamp_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_clamp_value(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS FLOAT4 AS $$
# name: clamp_value
# description: Clamps a given float4 value between a minimum and maximum float4 range
# type: float4
# input: The float4 value to be clamped
# input: The minimum float4 value in the range
# input: The maximum float4 value in the range
# output: The clamped float4 value

    plpy.info("clamp_value function called with value = " + str(value) + ", min_value = " + str(min_value) + ", max_value = " + str(max_value))
    if value < min_value:
        result = min_value
    elif value > max_value:
        result = max_value
    else:
        result = value
    plpy.info("Result of clamp_value: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'clampValueLessThanMinimum', plpython3u_clamp_value(2.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'clampValueWithinRange', plpython3u_clamp_value(4.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 4.5::FLOAT4;
```

#### plpython3u_combine_second_third_power✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_combine_second_third_power(input1 float4, input2 float4) RETURNS float4 AS $$
# name: combine_second_third_power
# description: Combines the second power of the first float4 input with the third power of the second float4 input by adding them together.
# type: float4
# input: The first float4 input for which the second power is calculated
# input: The second float4 input for which the third power is calculated
# output: The result of adding the second power of input1 and the third power of input2, returned as float4

    plpy.info("plpython3u_combine_second_third_power function called with input1 = " + str(input1) + ", input2 = " + str(input2))
    # Calculate the second power (square) of input1 and third power (cube) of input2
    result = input1**2 + input2**3
    plpy.info("Result of plpython3u_combine_second_third_power: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'combine_second_third_power_test1', plpython3u_combine_second_third_power(4.0::FLOAT4, 2.0::FLOAT4) = 24.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'combine_second_third_power_test2', plpython3u_combine_second_third_power(-1.5::FLOAT4, 3.0::FLOAT4) = 29.25::FLOAT4;
```

#### plpython3u_compare_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_compare_float4_values(value1 float4, value2 float4) RETURNS float4 AS $$
# name: compare_float4_values
# description: Compares two float4 values and determines if the first is greater than the second.
# type: float4
# input: First float4 value for comparison
# input: Second float4 value for comparison
# output: Boolean represented as float4 (1.0 for true, 0.0 for false)

    plpy.info("compare_float4_values function called with value1 = " + str(value1) + ", value2 = " + str(value2))
    result = 0.0
    if value1 > value2:
        result = 1.0
    plpy.info("Result of compare_float4_values: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'compareFloat4ValuesCase1', plpython3u_compare_float4_values(3.5::FLOAT4, 2.7::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'compareFloat4ValuesCase2', plpython3u_compare_float4_values(1.4::FLOAT4, 1.8::FLOAT4) = 0.0::FLOAT4;
```

#### plpython3u_compute_circle_area❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_compute_circle_area(radius FLOAT4) RETURNS FLOAT4 AS $$
# name: compute_circle_area
# description: This function calculates the area of a circle given the radius as a float4 type.
# type: float4
# input: The radius of the circle as a float4
# output: The area of the circle as a float4

    plpy.info("compute_circle_area function called with radius = " + str(radius))
    pi = 3.14159
    if radius is None:
        radius = 0.0
    area = pi * (radius ** 2)
    plpy.info("Result of compute_circle_area: " + str(area))
    return area
$$ LANGUAGE plpython3u;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'compute_circle_area_small', ROUND(plpython3u_compute_circle_area(2.5), 5) = ROUND(19.63495::FLOAT4, 5);
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'compute_circle_area_large', ROUND(plpython3u_compute_circle_area(100.0), 1) = ROUND(31415.9::FLOAT4, 1);
```

#### plpython3u_compute_float4_quotient_and_remainder❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_compute_float4_quotient_and_remainder(dividend FLOAT4, divisor FLOAT4) RETURNS JSONB AS $$
# name: compute_float4_quotient_and_remainder
# description: Compute the quotient and remainder of the division of two float4 numbers
# type: float4
# input: The float4 number being divided
# input: The float4 number by which the dividend is divided
# output: A JSON object with float4 quotient and remainder

    if divisor == 0:
        plpy.error("Division by zero error.")

    plpy.info("compute_float4_quotient_and_remainder function called with dividend = " + str(dividend) + ", divisor = " + str(divisor))

    quotient = dividend / divisor
    remainder = dividend % divisor

    result = {
        "quotient": float(quotient),
        "remainder": float(remainder)
    }

    plpy.info("Result of compute_float4_quotient_and_remainder: " + str(result))
    return result
$$ LANGUAGE plpython3u;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_computeFloat4QuotientAndRemainder1', (plpython3u_compute_float4_quotient_and_remainder(8.75::FLOAT4, 2.50::FLOAT4)::JSONB) = '{"quotient": 3.5, "remainder": 1.25}'::JSONB;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_computeFloat4QuotientAndRemainder2', (plpython3u_compute_float4_quotient_and_remainder(-5.5::FLOAT4, 2.2::FLOAT4)::JSONB) = '{"quotient": -2.5, "remainder": -0.9}'::JSONB;
```

#### plpython3u_compute_square_root✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_compute_square_root(input_number FLOAT4) RETURNS FLOAT4 AS $$
# name: compute_square_root
# description: Computes the square root of a given float4 input and returns the result as float4
# type: float4
# input: The float4 number to compute the square root of
# output: The float4 square root of the input number

    # Debug message
    plpy.info("compute_square_root function called with input_number = " + str(input_number))
    
    # Input validation
    if input_number is None:
        raise Exception("input_number cannot be None")
    if input_number < 0.0:
        raise Exception("Square root of negative number is not real")
    
    # Special case for zero
    if input_number == 0.0:
        return 0.0
    
    # Compute the square root using math module
    result = math.sqrt(input_number)
    
    # Debug output
    plpy.info("Result of compute_square_root: " + str(result))
    
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'compute_square_root2', plpython3u_compute_square_root(0.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'compute_square_root1', plpython3u_compute_square_root(16.0::FLOAT4) = 4.0::FLOAT4;
```

#### plpython3u_compute_tangent✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_compute_tangent(angle_in_radians float4) RETURNS float4 AS $$
# name: compute_tangent
# description: Computes the tangent of a float4 angle value in radians and returns the result as float4
# type: float4
# input: The angle in radians for which to compute the tangent, as a float4
# output: The tangent of the angle as float4

    import math
    plpy.info(f"compute_tangent function called with angle_in_radians = {angle_in_radians}")
    
    # Ensure the input angle is not PI/2 or 3*PI/2 where the tangent is not defined
    if angle_in_radians in (math.pi / 2, 3 * math.pi / 2):
        raise ValueError("Input angle_in_radians cannot be PI/2 or 3*PI/2 as tangent is not defined.")
    
    # Calculate the tangent of the input angle
    result = math.tan(angle_in_radians)
    
    # Return the result as a float4
    plpy.info(f"Result of compute_tangent: {result}")
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_computeTangentOfZero', plpython3u_compute_tangent(0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_computeTangentOfPiOverFour', plpython3u_compute_tangent(0.785398163::FLOAT4) = 1.0::FLOAT4;
```

#### plpython3u_convert_float4_to_negative✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_convert_float4_to_negative(number FLOAT4) RETURNS FLOAT4 AS $$
# name: convert_float4_to_negative
# description: This function converts a float4 number to its negative equivalent.
# type: float4
# input: float4 number to be negated
# output: The negative equivalent of the input as float4

    plpy.info("convert_float4_to_negative function called with number = " + str(number))
    if number is None:
        raise Exception("Input number cannot be null")
    elif number < 0:
        result = number
    else:
        result = number * -1
    plpy.info("Result of convert_float4_to_negative: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_convertFloat4ToNegativePositiveValue', plpython3u_convert_float4_to_negative(3.5::FLOAT4) = -3.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_convertFloat4ToNegativeNegativeValue', plpython3u_convert_float4_to_negative(-2.0::FLOAT4) = -2.0::FLOAT4;
```

#### plpython3u_convert_to_radians✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_convert_to_radians(degrees FLOAT4) RETURNS FLOAT4 AS $$
# name: convert_to_radians
# description: Converts an angle in degrees to radians
# type: float4
# input: The angle in degrees to be converted to radians as float4
# output: The angle in radians as float4

    PI = 3.1415927
    plpy.info("convert_to_radians function called with degrees = " + str(degrees))
    result = degrees * PI / 180.0
    plpy.info("Result of convert_to_radians: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'convert_to_radians_test_case_0_degrees', plpython3u_convert_to_radians(0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'convert_to_radians_test_case_180_degrees', plpython3u_convert_to_radians(180.0::FLOAT4) = 3.1415927::FLOAT4;
```

#### plpython3u_find_nearest_multiple_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_find_nearest_multiple_float4(number float4, divisor float4) RETURNS float4 AS $$
# name: find_nearest_multiple_float4
# description: Finds the nearest multiple of a divisor close to the given float4 number
# type: float4
# input: The original float4 value for which the nearest multiple is to be found
# input: The divisor float4 value whose multiple is to be found nearest to the number
# output: The nearest multiple of the divisor float4 value to the original number as float4

    plpy.info("find_nearest_multiple_float4 function called with number = " + str(number) + ", divisor = " + str(divisor))
    if divisor == 0:
        raise Exception('divisor cannot be zero')
    quotient = number / divisor
    rounded_quotient = round(quotient)
    nearest_multiple = rounded_quotient * divisor
    plpy.info("Result of find_nearest_multiple_float4: " + str(nearest_multiple))
    return nearest_multiple
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'find_nearest_multiple_float41', plpython3u_find_nearest_multiple_float4(14.2::FLOAT4, 5.0::FLOAT4) = 15.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'find_nearest_multiple_float42', plpython3u_find_nearest_multiple_float4(7.7::FLOAT4, 3.5::FLOAT4) = 7.0::FLOAT4;
```

#### plpython3u_float4_absolute_value_test✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_float4_absolute_value_test(number float4) RETURNS float4 AS $$
# name: float4_absolute_value_test
# description: Function to compute the absolute value of a float4 number
# type: float4
# input: A float4 value representing the number to find the absolute value for
# output: float4 absolute value of the input number

  plpy.info("float4_absolute_value_test function called with number = " + str(number))
  abs_value = number
  if number < 0:
    abs_value = -1 * number
  plpy.info("Result of float4_absolute_value_test: " + str(abs_value))
  return abs_value
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'float4_absolute_value_test1', plpython3u_float4_absolute_value_test(-123.45::float4) = 123.45::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'float4_absolute_value_test2', plpython3u_float4_absolute_value_test(678.9::float4) = 678.9::float4;
```

#### plpython3u_float4_min_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_float4_min_value(number1 FLOAT4, number2 FLOAT4) RETURNS FLOAT4 AS $$
# name: float4_min_value
# description: Finds the minimum value between two float4 numbers
# type: float4
# input: First float4 number for comparison
# input: Second float4 number for comparison
# output: Returns the minimum value as float4

    plpy.info("float4_min_value function called with number1 = " + str(number1) + ", number2 = " + str(number2))
    
    min_value = number1
    if number2 < min_value:
        min_value = number2
    
    plpy.info("Result of float4_min_value: " + str(min_value))
    return min_value
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'float4_min_value_positive_less', plpython3u_float4_min_value(3.5::FLOAT4, 7.25::FLOAT4) = 3.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'float4_min_value_negative_positive', plpython3u_float4_min_value(-2.0::FLOAT4, 4.75::FLOAT4) = -2.0::FLOAT4;
```

#### plpython3u_is_float4_in_decreasing_order✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_is_float4_in_decreasing_order(number1 FLOAT4, number2 FLOAT4) RETURNS BOOLEAN AS $$
# name: is_float4_in_decreasing_order
# description: Determines if the provided float4 numbers are in strictly decreasing order
# type: float4
# input: First number of type float4
# input: Second number of type float4
# output: Result of type boolean, true if number1 > number2, false otherwise

    plpy.info("plpython3u_is_float4_in_decreasing_order function called with number1 = " + str(number1) + ", number2 = " + str(number2))
    result = number1 > number2
    plpy.info("Result of plpython3u_is_float4_in_decreasing_order: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'is_float4_in_decreasing_order1', plpython3u_is_float4_in_decreasing_order(6.5::FLOAT4, 3.24::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'is_float4_in_decreasing_order2', plpython3u_is_float4_in_decreasing_order(5.5::FLOAT4, 5.5::FLOAT4) = FALSE;
```

#### plpython3u_is_float4_in_range✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_is_float4_in_range(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS BOOLEAN AS $$
# name: is_float4_in_range
# description: Determines if a float4 value falls within a specified inclusive range, defined by a minimum and maximum float4 value.
# type: float4
# input: The float4 value to check
# input: The inclusive minimum value of the range as float4
# input: The inclusive maximum value of the range as float4
# output: Returns true if the value is within the range, otherwise false

    plpy.info("plpython3u_is_float4_in_range function called with value = " + str(value) + ", min_value = " + str(min_value) + ", max_value = " + str(max_value))
    result = min_value <= value <= max_value
    plpy.info("Result of is_float4_in_range: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'is_float4_in_range1', plpython3u_is_float4_in_range(3.5::FLOAT4, 1.0::FLOAT4, 5.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'is_float4_in_range2', plpython3u_is_float4_in_range(6.5::FLOAT4, 1.0::FLOAT4, 5.0::FLOAT4) = FALSE;
```

#### plpython3u_is_float4_zero✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_is_float4_zero(number FLOAT4) RETURNS BOOLEAN AS $$
# name: is_float4_zero
# description: Checks if the provided float4 number is zero
# type: float4
# input: the input float4 number to check
# output: returns true if number is 0.0, false otherwise

    threshold = 0.0001  # Floating-point comparison threshold
    plpy.info("is_float4_zero function called with number = " + str(number))
    is_zero = abs(number) <= threshold
    plpy.info("Result of is_float4_zero: " + str(is_zero))
    return is_zero
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'is_float4_zero_case_exact_zero', plpython3u_is_float4_zero(0.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'is_float4_zero_case_close_to_zero', plpython3u_is_float4_zero(0.00001::FLOAT4) = TRUE;
```

#### plpython3u_is_negative✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_is_negative(number float4) RETURNS boolean AS $$
# name: is_negative
# description: Determines if a float4 value is negative
# type: float4
# input: the float4 number to check
# output: boolean indicating if the number is negative

    plpy.info("plpython3u_is_negative function called with number = " + str(number))
    return number < 0
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'is_negative1', plpython3u_is_negative(-3.14::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'is_negative2', plpython3u_is_negative(6.28::FLOAT4) = FALSE;
```

#### plpython3u_normalize_float4_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_normalize_float4_value(value float4, min_value float4, max_value float4) RETURNS float4 AS $$
# name: normalize_float4_value
# description: Normalize a float4 number to the range of 0 to 1 based on provided minimum and maximum values
# type: float4
# input: the float4 number to normalize
# input: the minimum float4 value of the range
# input: the maximum float4 value of the range
# output: the normalized float4 number

    plpy.info(f"Normalize float4 value function called with value = {value}, min_value = {min_value}, max_value = {max_value}")
    if min_value >= max_value:
        raise ValueError("min_value must be less than max_value")

    distance_from_min = value - min_value
    range_size = max_value - min_value
    normalized_value = distance_from_min / range_size
    plpy.info(f"Normalized float4 value is: {normalized_value}")
    
    return normalized_value
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'normalize_float4_value_within_range', plpython3u_normalize_float4_value(10.0::FLOAT4, 0.0::FLOAT4, 20.0::FLOAT4) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'normalize_float4_value_top_of_range', plpython3u_normalize_float4_value(20.0::FLOAT4, 10.0::FLOAT4, 20.0::FLOAT4) = 1.0::FLOAT4;
```

#### plpython3u_subtract_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_subtract_float4_values(value1 float4, value2 float4) RETURNS float4 AS $$
# name: subtract_float4_values
# description: Subtracts the second float4 value from the first and returns the result as float4
# type: float4
# input: First float4 value to be used in subtraction
# input: Second float4 value to subtract from the first value
# output: Result of subtraction as float4

    plpy.info("subtract_float4_values function called with value1 = " + str(value1) + ", value2 = " + str(value2))
    result = value1 - value2
    plpy.info("Result of subtract_float4_values: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'subtract_float4_values_positives', 
CASE WHEN ROUND(plpython3u_subtract_float4_values(5.7::FLOAT4, 2.3::FLOAT4)::NUMERIC, 1) = 3.4 THEN TRUE ELSE FALSE END;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'subtract_float4_values_negative_from_positive', plpython3u_subtract_float4_values(-1.2::FLOAT4, 4.6::FLOAT4) = -5.799999952316284::FLOAT4;
```

#### plpython3u_test_cosine_float4❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_test_cosine_float4(angle float4) RETURNS float4 AS $$
# name: test_cosine_float4
# description: Calculates the cosine of a float4 angle value in radians and returns the result as float4
# type: float4
# input: Angle in radians for which the cosine has to be calculated (float4)
# output: The cosine of the provided angle (float4)

  import math
  plpy.info("test_cosine_float4 function called with angle = " + str(angle))
  if angle is None:
    raise Exception("Angle cannot be NULL")
  if not isinstance(angle, (float, int)):
    raise Exception("Angle must be a float or integer")
  angle = float(angle)  # Ensure angle is float4 for cosine calculation
  result = math.cos(angle)
  plpy.info("Result of test_cosine_float4: " + str(result))
  return result
$$ LANGUAGE plpython3u;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_cosine_float41', plpython3u_test_cosine_float4(0.0::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_cosine_float42', plpython3u_test_cosine_float4(1.5707963::FLOAT4) = 0.0::FLOAT4;
```

#### plpython3u_test_float4_power✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_test_float4_power(base FLOAT4, exponent FLOAT4) RETURNS FLOAT4 AS $$
# name: test_float4_power
# description: Raises a float4 base number to the power of a float4 exponent
# type: float4
# input: float4 base number
# input: float4 exponent value
# output: float4 result of raising base to the power of exponent

    plpy.info("test_float4_power function called with base = " + str(base) + ", exponent = " + str(exponent))
    # Initialize a float4 variable to store the result
    result = 0.0

    # Check if the exponent is 0, if so return 1.0 as the result
    if exponent == 0:
        return 1.0
    # Check if the base is 0, if so return 0.0 as the result
    elif base == 0:
        return 0.0
    
    # Raise the base to the power of exponent using a power function and store in result    
    result = base ** exponent
    
    # Return the result as float4
    plpy.info("Result of test_float4_power: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_float4_power_non_zero_base_positive_exponent', plpython3u_test_float4_power(2.0::FLOAT4, 3.0::FLOAT4) = 8.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_float4_power_non_zero_base_non_integer_exponent', plpython3u_test_float4_power(9.0::FLOAT4, 0.5::FLOAT4) = 3.0::FLOAT4;
```

#### plpython3u_test_float4_rounding✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_test_float4_rounding(original_value FLOAT4) RETURNS FLOAT4 AS $$
# name: test_float4_rounding
# description: This function rounds a float4 value to the nearest whole number and returns it as float4.
# type: float4
# input: A float4 value to be rounded to the nearest whole number
# output: Rounded float4 value to the nearest whole number

    plpy.info("test_float4_rounding function called with original_value = " + str(original_value))
    rounded_value = round(original_value)
    plpy.info("Result of test_float4_rounding: " + str(rounded_value))
    return rounded_value
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_float4_rounding_positive', plpython3u_test_float4_rounding(2.5::FLOAT4) = 2.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_float4_rounding_negative', plpython3u_test_float4_rounding(-3.7::FLOAT4) = -4.0::FLOAT4;
```

#### plpython3u_test_float4_truncation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_test_float4_truncation(number float4) RETURNS float4 AS $$
# name: test_float4_truncation
# description: Truncates a float4 number, removing its decimal part.
# type: float4
# input: A float4 number to be truncated
# output: The truncated float4 number

    plpy.info("test_float4_truncation function called with number = " + str(number))
    result = float(int(number))
    plpy.info("Result of test_float4_truncation: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_float4_truncation_pos', plpython3u_test_float4_truncation(123.456::FLOAT4) = 123.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_float4_truncation_neg', plpython3u_test_float4_truncation(-123.456::FLOAT4) = -123.0::FLOAT4;
```

#### plpython3u_test_increment_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_test_increment_float4(number float4, increment float4) RETURNS float4 AS $$
# name: test_increment_float4
# description: This function increments a float4 value by a float4 increment and returns the result as float4.
# type: float4
# input: The float4 number to be incremented
# input: The float4 value to increment the number by
# output: The incremented float4 value

    plpy.info("test_increment_float4 function called with number = " + str(number) + ", increment = " + str(increment))
    result = number + increment
    plpy.info("Result of test_increment_float4: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_increment_float41', plpython3u_test_increment_float4(8.25::FLOAT4, 1.75::FLOAT4) = 10.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_increment_float42', plpython3u_test_increment_float4(-3.5::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;
```

#### plpython3u_test_maximum_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_test_maximum_value(input1 float4, input2 float4) RETURNS float4 AS $$
# name: test_maximum_value
# description: Function to determine the maximum of two float4 values
# type: float4
# input: First float4 value to compare
# input: Second float4 value to compare
# output: Returns the maximum of the two float4 inputs

    plpy.info("test_maximum_value function called with input1 = " + str(input1) + ", input2 = " + str(input2))
    result = input1 if input1 >= input2 else input2
    plpy.info("Result of test_maximum_value: " + str(result))
    return result
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_maximum_value_case1', plpython3u_test_maximum_value(12.34::FLOAT4, 9.87::FLOAT4) = 12.34::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'test_maximum_value_case2', plpython3u_test_maximum_value(-3.21::FLOAT4, 4.56::FLOAT4) = 4.56::FLOAT4;
```

#### plpython3u_validate_even_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_validate_even_float4(value FLOAT4) RETURNS BOOLEAN AS $$
# name: validate_even_float4
# description: Determines whether a float4 number represents an even number
# type: float4
# input: The float4 number to check
# output: Returns true if the number is even, otherwise false

    plpy.info("validate_even_float4 function called with value = " + str(value))
    whole_number = int(value)  # Convert input to the nearest smaller whole number if not whole
    is_even = (whole_number % 2) == 0  # Perform modulo operation to check if it's even
    plpy.info("Is " + str(value) + " an even number? " + str(is_even))
    return is_even
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'validate_even_float4_1', plpython3u_validate_even_float4(4.0::FLOAT4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'validate_even_float4_2', plpython3u_validate_even_float4(5.0::FLOAT4) = false;
```

#### plpython3u_validate_float4_within_range✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plpython3u_validate_float4_within_range(number float4, range_min float4, range_max float4) RETURNS float4 AS $$
# name: validate_float4_within_range
# description: validate whether the float4 number falls within the exclusive range (min, max)
# type: float4
# input: the float4 number to validate
# input: the minimum float4 boundary of the range
# input: the maximum float4 boundary of the range
# output: boolean represented as float4 (1.0 for true, 0.0 for false)

    plpy.info("validate_float4_within_range function called with number = " + str(number) + ", range_min = " + str(range_min) + ", range_max = " + str(range_max))
    valid = 1.0 if (number > range_min) and (number < range_max) else 0.0
    plpy.info("Result of validate_float4_within_range: " + str(valid))
    return valid
$$ LANGUAGE plpython3u;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'validate_float4_within_range_case1', plpython3u_validate_float4_within_range(5.5::FLOAT4, 5.0::FLOAT4, 6.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plpython3u-float4', 'validate_float4_within_range_case2', plpython3u_validate_float4_within_range(4.0::FLOAT4, 5.0::FLOAT4, 6.0::FLOAT4) = 0.0::FLOAT4;
```

### plr

#### plr_add_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_add_float4_values(value1 float4, value2 float4) RETURNS float4 AS $$
# name: add_float4_values
# description: Function that adds two float4 values and returns the result as float4
# type: float4
# input: float4 value to be added to value2
# input: float4 value to be added to value1
# output: Sum of value1 and value2 as float4

    message(paste("add_float4_values function called with value1 =", value1, ", value2 =", value2))
    if (is.null(value1)) {
        value1 = 0
    }
    if (is.null(value2)) {
        value2 = 0
    }
    result = as.numeric(value1) + as.numeric(value2)
    message(paste("Result of add_float4_values:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'addFloat4ValuesPositive', plr_add_float4_values(1.5::FLOAT4, 2.5::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'addFloat4ValuesPosNeg', plr_add_float4_values(-1.25::FLOAT4, 3.75::FLOAT4) = 2.5::FLOAT4;

-- calculate_float4_complement
```

#### plr_average_of_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_average_of_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
# name: average_of_float4_values
# description: Calculates the average of two float4 values
# type: float4
# input: First float4 value
# input: Second float4 value
# output: The average value as float4

    message("DEBUG: FUNCTION plr_average_of_float4_values - Running average_of_float4_values function with inputs 'value1' =", value1, ", 'value2' = ", value2)
    if (is.null(value1)) {
        value1 = 0.0
    }
    if (is.null(value2)) {
        value2 = 0.0
    }
    sum <- value1 + value2
    average <- sum / 2
    message("DEBUG: FUNCTION plr_average_of_float4_values - Function is returning 'average' = ", average)
    return(average)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'averageOfFloat4ValuesPositive', plr_average_of_float4_values(4.0::FLOAT4, 8.0::FLOAT4) = 6.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'averageOfFloat4ValuesNegative', plr_average_of_float4_values(-2.5::FLOAT4, -7.5::FLOAT4) = -5.0::FLOAT4;
```

#### plr_calculate_arccosine✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_arccosine(value FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_arccosine
# description: Calculates the arccosine (inverse cosine) of a float4 value
# type: float4
# input: A float4 representing the cosine of an angle, range -1 to 1
# output: The arccosine of the input value as float4 in radians

    message(paste("calculate_arccosine function called with value =", value))
    
    # Validate input value
    if (value < -1 || value > 1) {
        stop("Input value is not in the range of -1 to 1 inclusive")
    }
    
    # Calculate the arccosine
    result = as.numeric(acos(value))
    
    message(paste("Result of calculate_arccosine:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateArccosine1', round(cast(plr_calculate_arccosine(0::FLOAT4) as NUMERIC), 4) = round(cast(1.5708 as NUMERIC), 4);
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateArccosine2', round(plr_calculate_arccosine(1::FLOAT4), 4) = round(cast(0 as float4), 4);
```

#### plr_calculate_area_of_rectangle✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_area_of_rectangle(width float4, height float4) RETURNS float4 AS $$
# name: calculate_area_of_rectangle
# description: This function calculates the area of a rectangle given the width and height as float4 types and returns the area as float4
# type: float4
# input: float4 type representing the width of the rectangle
# input: float4 type representing the height of the rectangle
# output: float4 type representing the area of the rectangle

  message(paste("calculate_area_of_rectangle function called with width =", width, ", height =", height))
  if (is.na(width) || is.na(height)) {
    stop("Input parameters width and height must not be NA")
  }
  area <- width * height
  message(paste("Area calculated:", area))
  return(area)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_area_of_rectangle1', plr_calculate_area_of_rectangle(4.0::float4, 3.0::float4) = 12.0::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_area_of_rectangle2', plr_calculate_area_of_rectangle(0.0::float4, 5.0::float4) = 0.0::float4;
```

#### plr_calculate_arithmetic_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_arithmetic_mean(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_arithmetic_mean
# description: Calculates arithmetic mean of two float4 values
# type: float4
# input: First float4 input value.
# input: Second float4 input value.
# output: Arithmetic mean result as float4.

    message(paste("calculate_arithmetic_mean function called with value1 =", value1, ", value2 =", value2))
    if (is.null(value1)) {
        value1 <- 0
    }
    if (is.null(value2)) {
        value2 <- 0
    }
    total <- value1 + value2
    count <- 2
    result <- total / count
    message(paste("Result of calculate_arithmetic_mean:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateArithmeticMeanPositive', plr_calculate_arithmetic_mean(3.5::FLOAT4, 2.5::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateArithmeticMeanPosNeg', plr_calculate_arithmetic_mean(5.0::FLOAT4, -3.0::FLOAT4) = 1.0::FLOAT4;
```

#### plr_calculate_arithmetic_progression_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_arithmetic_progression_sum(a FLOAT4, d FLOAT4, n FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_arithmetic_progression_sum
# description: Calculate the sum of the first n terms of an arithmetic progression, given the first term (a), the common difference (d), and the number of terms (n), returning the sum as float4.
# type: float4
# input: the first term of the arithmetic progression (float4)
# input: the common difference between the terms (float4)
# input: the number of terms to sum (float4)
# output: the sum of the first n terms of the arithmetic progression (float4)

    message(paste("calculate_arithmetic_progression_sum function called with a =", a, ", d =", d, ", n =", n))
    
    # Ensuring that input is not NULL, providing defaults if necessary
    nonNullableA = ifelse(is.null(a), 0.0, a)
    nonNullableD = ifelse(is.null(d), 0.0, d)
    nonNullableN = ifelse(is.null(n), 0.0, n)
    
    # Implementing the formula to calculate the sum of an arithmetic progression
    product_ad = nonNullableN * nonNullableA
    product_d_n_minus_1 = nonNullableD * (nonNullableN - 1)
    product_final = product_ad + (product_d_n_minus_1 * nonNullableN) / 2
    
    message(paste("Result of calculate_arithmetic_progression_sum:", product_final))
    
    return(product_final)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateArithmeticProgressionSum1', plr_calculate_arithmetic_progression_sum(2.0::FLOAT4, 2.0::FLOAT4, 5.0::FLOAT4) = 30.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateArithmeticProgressionSum2', plr_calculate_arithmetic_progression_sum(1.5::FLOAT4, 0.0::FLOAT4, 3.0::FLOAT4)::FLOAT4 = 4.5::FLOAT4;
```

#### plr_calculate_ceil✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_ceil(number float4) RETURNS float4 AS $$
# name: calculate_ceil
# description: This function calculates and returns the smallest integer greater than or equal to the given float4 number.
# type: float4
# input: A float4 number to calculate the ceiling value for
# output: The ceiling value of the input as float4

    message(paste("calculate_ceil function called with number =", number))
    result = ceiling(number)
    message(paste("Ceiling value of input:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculateCeilPositive', plr_calculate_ceil(3.45::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculateCeilNegative', plr_calculate_ceil(-1.78::FLOAT4) = -1.0::FLOAT4;
```

#### plr_calculate_circumference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_circumference(radius float4) RETURNS float4 AS $$
# name: calculate_circumference
# description: Calculates the circumference of a circle given the radius as float4
# type: float4
# input: The radius of the circle as float4
# output: The circumference of the circle as float4

message(paste("calculate_circumference function called with radius =", radius))
PI <- 3.1415926535
diameter <- radius * 2
circumference <- diameter * PI
message(paste("Result of calculate_circumference:", circumference))
return(circumference)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_circumference_small_radius', plr_calculate_circumference(2.0::float4) = 12.566370614::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_circumference_large_radius', plr_calculate_circumference(100.0::float4) = 628.3185307179584::float4;
```

#### plr_calculate_decibel_level✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_decibel_level(sound_pressure FLOAT4, reference_pressure FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_decibel_level
# description: Calculates the decibel level of a sound by comparing it to a reference sound pressure level.
# type: float4
# input: The sound pressure of the sound for which to determine the decibel level, as float4.
# input: The reference sound pressure which is typically the threshold of human hearing, as float4.
# output: The decibel level of the sound compared to the reference sound pressure, as float4.

    message(paste("calculate_decibel_level function called with sound_pressure =", sound_pressure, ", reference_pressure =", reference_pressure))
    if(sound_pressure <= 0 || reference_pressure <= 0) {
        stop("Both sound_pressure and reference_pressure must be positive.")
    }
    ratio <- sound_pressure / reference_pressure
    log_ratio <- log10(ratio)
    decibel <- 20 * log_ratio
    message(paste("Result of calculate_decibel_level:", decibel))
    return(as.numeric(decibel))
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_decibel_level_normal', ROUND(plr_calculate_decibel_level(1.0::FLOAT4, 0.00002::FLOAT4)) = 94.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_decibel_level_threshold', plr_calculate_decibel_level(0.00002::FLOAT4, 0.00002::FLOAT4) = 0.0::FLOAT4;
```

#### plr_calculate_distance_between_float4_points❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_distance_between_float4_points(x1 FLOAT4, y1 FLOAT4, x2 FLOAT4, y2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_distance_between_float4_points
# description: Calculates the distance between two points in 2D space using float4 for coordinates
# type: float4
# input: The x-coordinate of the first point as a float4
# input: The y-coordinate of the first point as a float4
# input: The x-coordinate of the second point as a float4
# input: The y-coordinate of the second point as a float4
# output: The distance between the two points as a float4

    message("DEBUG: FUNCTION plr_calculate_distance_between_float4_points - Running calculation with inputs x1 =", x1, ", y1 =", y1, ", x2 =", x2, ", y2 =", y2)
    delta_x <- x1 - x2
    delta_y <- y1 - y2
    sum_of_squares <- delta_x^2 + delta_y^2
    distance <- sqrt(sum_of_squares)
    message("DEBUG: FUNCTION plr_calculate_distance_between_float4_points - Calculation complete, distance =", distance)
    return(as.float4(distance))
$$ LANGUAGE plr;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_distance_between_points_same', plr_calculate_distance_between_float4_points(0.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_distance_between_points_different', plr_calculate_distance_between_float4_points(3.0::FLOAT4, 4.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4) = 5.0::FLOAT4;
```

#### plr_calculate_euclidean_distance✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_euclidean_distance(point1 float4[], point2 float4[]) RETURNS float4 AS $$
# name: calculate_euclidean_distance
# description: Calculates the Euclidean distance between two points in 3D space.
# type: float4
# input: First point as an object with float4 x, y, z coordinates
# input: Second point as an object with float4 x, y, z coordinates
# output: The Euclidean distance between the two points as float4

    message('calculate_euclidean_distance function called with point1 =', paste(point1, collapse=", "), ' and point2 =', paste(point2, collapse=", "))

    x1 <- point1[1]
    y1 <- point1[2]
    z1 <- point1[3]
    x2 <- point2[1]
    y2 <- point2[2]
    z2 <- point2[3]
  
    squared_diffs_sum <- (x1 - x2)^2 + (y1 - y2)^2 + (z1 - z2)^2
    distance <- sqrt(squared_diffs_sum)
    
    message('Result of calculate_euclidean_distance:', distance)
    return(as.numeric(distance))
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_euclidean_distance2', plr_calculate_euclidean_distance(ARRAY[7.0, 8.0, 9.0]::float4[], ARRAY[7.0, 8.0, 9.0]::float4[]) = 0.0::float4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_euclidean_distance1', plr_calculate_euclidean_distance(ARRAY[1.0, 2.0, 3.0]::float4[], ARRAY[4.0, 5.0, 6.0]::float4[]) = 5.1962::float4;

-- convert_to_radians
```

#### plr_calculate_exponential_growth✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_exponential_growth(initial_value FLOAT4, growth_rate FLOAT4, time_period FLOAT4) RETURNS FLOAT4 AS $$
-- name: calculate_exponential_growth
-- description: This function calculates the exponential growth based on initial value, growth rate, and time.
-- type: float4
-- input: Initial quantity as float4
-- input: Growth rate (in percentage) as float4
-- input: Time period over which to calculate as float4
-- output: Returns the amount after growth as float4

DECLARE
    growth_rate_decimal FLOAT4;
    growth_factor FLOAT4;
    amount_after_growth FLOAT4;
    rounded_result FLOAT4;
BEGIN
    RAISE NOTICE 'calculate_exponential_growth called with initial_value = %, growth_rate = %, time = %', initial_value, growth_rate, time_period;
    growth_rate_decimal := growth_rate / 100;
    growth_factor := 1 + growth_rate_decimal;
    amount_after_growth := initial_value * POWER(growth_factor, time_period);
    rounded_result := round(amount_after_growth::numeric, 4);
    RAISE NOTICE 'Result of calculate_exponential_growth: %', rounded_result;
    RETURN rounded_result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateExponentialGrowth10Years', plr_calculate_exponential_growth(100.0::FLOAT4, 5.0::FLOAT4, 10.0::FLOAT4) = 162.889::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateExponentialGrowth5Years', plr_calculate_exponential_growth(1000.0::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 1159.27::FLOAT4;

-- calculate_log_base_n
```

#### plr_calculate_float4_as_percentage_of_another✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_as_percentage_of_another(value FLOAT4, total FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_as_percentage_of_another
# description: Calculates one float4 value as a percentage of another float4 value.
# type: float4
# input: The float4 number to calculate the percentage for
# input: The float4 number representing the total or 100%
# output: The percentage of 'value' relative to 'total' as float4

    message(paste("calculate_float4_as_percentage_of_another function called with value =", value, ", total =", total))
    if (total == 0) {
        stop("Total cannot be zero.")
    }
    result = (value / total) * 100
    message(paste("Result of calculate_float4_as_percentage_of_another:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4AsPercentageOfAnother1', plr_calculate_float4_as_percentage_of_another(25.0::FLOAT4, 50.0::FLOAT4) = 50.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4AsPercentageOfAnother2', plr_calculate_float4_as_percentage_of_another(1.0::FLOAT4, 200.0::FLOAT4) = 0.5::FLOAT4;
```

#### plr_calculate_float4_ceil✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_ceil(value FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_ceil
# description: Function to calculate the smallest integer greater than or equal to the given float4 number
# type: float4
# input: float4 value to find the ceiling value for
# output: float4 representing the smallest integer greater than or equal to the input

    message(paste("calculate_float4_ceil function called with value =", value))
    ceiling_value = ceiling(value)
    message(paste("Result of calculate_float4_ceil:", ceiling_value))
    return(ceiling_value)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_float4_ceil_positive_decimal', plr_calculate_float4_ceil(3.45::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_float4_ceil_negative_decimal', plr_calculate_float4_ceil(-2.8::FLOAT4) = -2.0::FLOAT4;
```

#### plr_calculate_float4_complement✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_complement(number float4) RETURNS float4 AS $$
# name: calculate_float4_complement
# description: Calculates the complement of a float4 number with respect to 1, that is, it calculates 1 - n for a given float4 n.
# type: float4
# input: A float4 number which is the value to find the complement of.
# output: The complement of the input float4 number with respect to 1 as float4.

    message(paste("calculate_float4_complement function called with number =", number))

    if (is.null(number) || !is(number, "numeric")) {
        stop("Input must be a non-null float4 numeric type")
    }
  
    result = 1.0 - number
    message(paste("Complement with respect to 1:", result))
    
    return(as.numeric(result))
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculateFloat4Complement1', plr_calculate_float4_complement(0.25::FLOAT4) = 0.75::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculateFloat4Complement2', plr_calculate_float4_complement(1.25::FLOAT4) = -0.25::FLOAT4;
```

#### plr_calculate_float4_division✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_division(dividend float4, divisor float4) RETURNS float4 AS $$
# name: calculate_float4_division
# description: This function takes two float4 values and divides the first by the second, returning a float4.
# type: float4
# input: The float4 number to be divided
# input: The float4 number to divide by
# output: The result of the division as a float4

    message(paste("calculate_float4_division function called with dividend =", dividend, ", divisor =", divisor))
    if (divisor == 0) {
        stop("Division by zero error")
    }
    result <- as.numeric(dividend) / as.numeric(divisor)
    message(paste("Result of calculate_float4_division:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_float4_division_large_by_small', plr_calculate_float4_division(10.5::FLOAT4, 2.5::FLOAT4) = 4.2::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_float4_division_small_by_large', plr_calculate_float4_division(3.3::FLOAT4, 4.4::FLOAT4) = 0.75::FLOAT4;
```

#### plr_calculate_float4_dot_product✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_dot_product(vector1_x FLOAT4, vector1_y FLOAT4, vector2_x FLOAT4, vector2_y FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_dot_product
# description: Calculates the dot product of two 2D vectors, each vector component is a float4 type
# type: float4
# input: x component of the first vector (float4)
# input: y component of the first vector (float4)
# input: x component of the second vector (float4)
# input: y component of the second vector (float4)
# output: dot product of the two vectors (float4)

    message(paste("calculate_float4_dot_product function called with vector1_x =", vector1_x, ", vector1_y =", vector1_y, ", vector2_x =", vector2_x, ", vector2_y =", vector2_y))
    
    product_x = as.numeric(vector1_x) * as.numeric(vector2_x)
    product_y = as.numeric(vector1_y) * as.numeric(vector2_y)
    dot_product = product_x + product_y
    
    message(paste("Result of calculate_float4_dot_product:", dot_product))
    return(as.numeric(dot_product))
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4DotProduct1', plr_calculate_float4_dot_product(1.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 1.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4DotProduct2', plr_calculate_float4_dot_product(1.0::FLOAT4, 1.0::FLOAT4, 2.0::FLOAT4, 2.0::FLOAT4) = 4.0::FLOAT4;
```

#### plr_calculate_float4_exponential_decay✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_exponential_decay(initial_value real, decay_rate real, "time" real) RETURNS real AS $$
-- name: calculate_float4_exponential_decay
-- description: Calculates the exponential decay based on initial value, decay rate, and time.
-- type: float4
-- input: Initial value of the quantity at time t0, as float4
-- input: Decay rate, must be non-negative, as float4
-- input: Time that has passed, as float4
-- output: The quantity remaining after decay over the given time, as float4

DECLARE
    remaining_quantity real;
BEGIN
    -- Print debugging information
    RAISE NOTICE 'FUNCTION plr_calculate_float4_exponential_decay - Called with initial_value = %, decay_rate = %, time = %', initial_value, decay_rate, "time";
    
    -- Ensure decay rate is non-negative
    IF (decay_rate < 0) THEN
        RAISE EXCEPTION 'Decay rate must be non-negative';
    END IF;
    
    -- Calculate the exponential decay
    remaining_quantity := initial_value * exp(-decay_rate * "time");
    RAISE NOTICE 'FUNCTION plr_calculate_float4_exponential_decay - Returning remaining_quantity = %', remaining_quantity;
    
    -- Return the calculated result
    RETURN remaining_quantity;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculateFloat4ExponentialDecayTimePeriod', (plr_calculate_float4_exponential_decay(100.0::FLOAT4, 0.5::FLOAT4, 10.0::FLOAT4) = 0.6737947::FLOAT4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculateFloat4ExponentialDecayRateZero', plr_calculate_float4_exponential_decay(50.0::FLOAT4, 0.0::FLOAT4, 5.0::FLOAT4) = 50.0::FLOAT4;

-- test_float4_rounding
```

#### plr_calculate_float4_exponentiation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_exponentiation(base FLOAT4, exponent FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_exponentiation
# description: Calculates the base raised to the power of exponent, both of float4 type, and returns float4
# type: float4
# input: float4 number to be raised to the power of the exponent
# input: float4 number representing the power
# output: float4 result of the exponentiation

    message(paste("calculate_float4_exponentiation function called with base =", base, ", exponent =", exponent))
    if (exponent == 0) {
        result <- 1
    } else if (base == 0) {
        result <- 0
    } else {
        result <- base ^ exponent
    }
    result <- as.numeric(format(result, scientific = FALSE))
    message(paste("Result of calculate_float4_exponentiation:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4ExponentiationPositive', plr_calculate_float4_exponentiation(2.5::FLOAT4, 3.0::FLOAT4) = 15.625::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4ExponentiationNegativeBase', plr_calculate_float4_exponentiation(-3.0::FLOAT4, 2.0::FLOAT4) = 9.0::FLOAT4;

-- calculate_float4_exponentiation_remainder
REATE OR REPLACE FUNCTION pltcl_calculate_float4_exponentiation_remainder(base FLOAT4, exponent INTEGER, divisor FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_exponentiation_remainder
# description: Calculates the remainder of the exponentiation of a float4 base raised to an integer exponent when divided by a float4 divisor.
# type: float4
# input: the base value as float4
# input: the exponent value as integer
# input: the divisor value as float4
# output: the remainder as float4

    if { ![info exists base] || $base eq "" } {
        return -1
    }
    if { ![info exists exponent] || $exponent eq "" } {
        return -1
    }
    if { ![info exists divisor] || $divisor eq "" || $divisor == 0 } {
        return -1
    }
    
    # Convert integer exponent to float4 for exponentiation
    set exponent_as_float [expr {double($exponent)}]

    # Perform the exponentiation
    set exp_result [expr {pow($base, $exponent_as_float)}]

    # Perform division to get the remainder
    set remainder_result [expr {$exp_result % $divisor}]

    # Debugging
    elog NOTICE "calculate_float4_exponentiation_remainder function called with base = $base, exponent = $exponent, divisor = $divisor"
    elog NOTICE "Result of calculate_float4_exponentiation_remainder: $remainder_result"

    return $remainder_result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_exponentiation_remainder1', pltcl_calculate_float4_exponentiation_remainder(2.5::FLOAT4, 3, 3.2::FLOAT4) = 0.9::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_exponentiation_remainder2', pltcl_calculate_float4_exponentiation_remainder(5.1::FLOAT4, -2, 2.0::FLOAT4) = 1.1::FLOAT4;
```

#### plr_calculate_float4_exponentiation_remainder✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_exponentiation_remainder(base FLOAT4, exponent INTEGER, divisor FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_exponentiation_remainder
# description: Calculates the remainder of the exponentiation of a float4 base raised to an integer exponent when divided by a float4 divisor.
# type: float4
# input: the base value as float4
# input: the exponent value as integer
# input: the divisor value as float4
# output: the remainder as float4

    message(paste("calculate_float4_exponentiation_remainder function called with base =", base, ", exponent =", exponent, ", divisor =", divisor))
    if (exponent < 0) {
        exponent = 0
    }
    float_exponent = as.numeric(exponent)
    result = (base ^ float_exponent) %% divisor
    message(paste("Result of calculate_float4_exponentiation_remainder:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculateFloat4ExponentiationRemainderZeroExponent', plr_calculate_float4_exponentiation_remainder(5.1::FLOAT4, -2::INTEGER, 2.0::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculateFloat4ExponentiationRemainderPositive', plr_calculate_float4_exponentiation_remainder(2.5::FLOAT4, 3::INTEGER, 3.2::FLOAT4) = 0.9::FLOAT4;
```

#### plr_calculate_float4_factorial✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_factorial(number float4) RETURNS float4 AS $$
# name: calculate_float4_factorial
# description: Calculates the factorial of a non-negative float4 number, rounding down to the nearest whole value before computation.
# type: float4
# input: A non-negative float4 number to calculate the factorial of
# output: The factorial of the input number as float4, or 'undefined' if input is negative

    message(paste("calculate_float4_factorial function called with number =", number))
    rounded_number <- floor(number)
    
    if (rounded_number < 0) {
        message("Input is negative; returning 'undefined'")
        return('undefined')
    }
    if (rounded_number == 0 || rounded_number == 1) {
        result <- 1
    } else {
        result <- 1
        for (i in 2:rounded_number) {
            result <- result * i
        }
    }
    
    message(paste("Result of calculate_float4_factorial:", result))
    return(as.numeric(result))
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_float4_factorial1', plr_calculate_float4_factorial(0.85::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_float4_factorial2', plr_calculate_float4_factorial(5.75::FLOAT4) = 120.0::FLOAT4;
```

#### plr_calculate_float4_geometric_mean❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_geometric_mean(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_geometric_mean
# description: Calculates the geometric mean of two float4 numbers and returns the result as float4
# type: float4
# input: The first positive float4 value
# input: The second positive float4 value
# output: The geometric mean of input float4 values as float4

    message(sprintf("calculate_float4_geometric_mean function called with value1 = %f, value2 = %f", value1, value2))
    if (value1 <= 0 || value2 <= 0) {
        stop("Input values must be greater than zero.")
    }
    product <- value1 * value2
    result <- sqrt(product)
    message(sprintf("Geometric mean result: %f", result))
    return(as.float(result))
$$ LANGUAGE plr;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_float4_geometric_mean1', plr_calculate_float4_geometric_mean(1.0::FLOAT4, 4.0::FLOAT4) = 2.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_float4_geometric_mean2', plr_calculate_float4_geometric_mean(1.0::FLOAT4, 10000.0::FLOAT4) = 100.0::FLOAT4;
```

#### plr_calculate_float4_inverse✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_inverse(numeric_value FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_inverse
# description: Calculates the multiplicative inverse (or reciprocal) of a non-zero float4 number
# type: float4
# input: The float4 number to invert
# output: The multiplicative inverse of the input as float4, or 'undefined' if the input is zero

    message(paste("calculate_float4_inverse function called with numeric_value =", numeric_value))
    if (numeric_value == 0.0) {
        message("Input is zero; the reciprocal is undefined.")
        return(NA)
    } else {
        result = 1.0 / numeric_value
        message(paste("Result of calculate_float4_inverse:", result))
        return(result)
    }
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4InverseNonZero', plr_calculate_float4_inverse(2.0::FLOAT4) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4InverseZero', plr_calculate_float4_inverse(0.0::FLOAT4) IS NULL;
```

#### plr_calculate_float4_inverse_ratio✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_inverse_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_inverse_ratio
# description: Calculates the inverse ratio of two float4 numbers, returns the result as float4.
# type: float4
# input: First float4 value, acting as the numerator
# input: Second float4 value, acting as the denominator, expected not to be zero
# output: The inverse ratio of the two float4 input values

    message(paste("calculate_float4_inverse_ratio function called with numerator =", numerator, ", denominator =", denominator))
    if (denominator == 0) {
        stop("Denominator cannot be zero.")
    }
    reciprocal <- 1 / denominator
    inverse_ratio <- reciprocal * numerator
    message(paste("Result of calculate_float4_inverse_ratio:", inverse_ratio))
    return(as.numeric(inverse_ratio))
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_float4_inverse_ratio_positive_values', plr_calculate_float4_inverse_ratio(2.0::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_float4_inverse_ratio_numerator_is_zero', plr_calculate_float4_inverse_ratio(0.0::FLOAT4, 3.0::FLOAT4) = 0.0::FLOAT4;

-- average_of_float4_values
```

#### plr_calculate_float4_inverse_square_root❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_inverse_square_root(number float4) RETURNS float4 AS $$
# name: calculate_float4_inverse_square_root
# description: Calculate the inverse square root of a float4 number
# type: float4
# input: The float4 number for which to find the inverse square root
# output: The inverse square root of the input number as float4

    if (is.null(number) || number <= 0) {
        return(as.float4(NA))  # Returning NA for 'undefined' as per PL/R standards
    }
    result <- 1 / sqrt(as.numeric(number))
    return(as.float4(result))
$$ LANGUAGE plr;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4InverseSquareRootPositive', plr_calculate_float4_inverse_square_root(4.0::FLOAT4) = 0.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4InverseSquareRootSmallPositive', plr_calculate_float4_inverse_square_root(0.25::FLOAT4) = 2.0::FLOAT4;
```

#### plr_calculate_float4_linear_intercept✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_linear_intercept(x1 float4, y1 float4, x2 float4, y2 float4) RETURNS float4 AS $$
# name: calculate_float4_linear_intercept
# description: Calculates the y-intercept of a line (b) given two points with float4 coordinates (x1, y1) and (x2, y2). The formula used is b = y1 - (slope * x1), where slope is the (y2 - y1) / (x2 - x1).
# type: float4
# input: The x-coordinate of the first point as float4
# input: The y-coordinate of the first point as float4
# input: The x-coordinate of the second point as float4
# input: The y-coordinate of the second point as float4
# output: The y-intercept (b) of the line as float4

    message(sprintf("DEBUG: FUNCTION plr_calculate_float4_linear_intercept-1 - Running with inputs 'x1' = %f, 'y1' = %f, 'x2' = %f, 'y2' = %f.", x1, y1, x2, y2))
    
    # Ensure x2 is not equal to x1 to avoid division by zero
    if (x2 == x1) {
        stop("Division by zero: x1 and x2 must be distinct values.")
    }
    
    # Calculate the slope (m) using (y2 - y1) / (x2 - x1)
    slope <- (y2 - y1) / (x2 - x1)
    
    # Calculate the y-intercept (b) using y1 - (slope * x1)
    intercept <- y1 - (slope * x1)
    
    message(sprintf("DEBUG: FUNCTION plr_calculate_float4_linear_intercept-2 - Function is returning 'intercept' = %f.", intercept))
    
    # Return the result as float4
    return(as.numeric(intercept))
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculateFloat4LinearInterceptPositiveSlope', plr_calculate_float4_linear_intercept(2.0::float4, 3.0::float4, 4.0::float4, 7.0::float4) = -1.0::float4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculateFloat4LinearInterceptNegativeSlope', plr_calculate_float4_linear_intercept(5.0::float4, 8.0::float4, 3.0::float4, 4.0::float4) = 12.0::float4;

-- validate_even_float4
```

#### plr_calculate_float4_logarithm_base2✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_logarithm_base2(value FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_logarithm_base2
# description: Calculates the base-2 logarithm of a given float4 number and returns the result as float4.
# type: float4
# input: The float4 number for which to calculate the base-2 logarithm
# output: The base-2 logarithm of the input float4 number

  if (value <= 0) {
    stop("Input value must be positive for logarithm calculation.")
  }
  result <- log(value, base = 2)
  return(as.numeric(result))
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4LogarithmBase2_PositiveValue1', plr_calculate_float4_logarithm_base2(8.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4LogarithmBase2_PositiveValue2', plr_calculate_float4_logarithm_base2(2.0::FLOAT4) = 1.0::FLOAT4;
```

#### plr_calculate_float4_max_absolute_difference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_max_absolute_difference(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_max_absolute_difference
# description: This function calculates the maximum absolute difference between two float4 values
# type: float4
# input: The first float4 input value
# input: The second float4 input value
# output: The maximum absolute difference as float4

message(paste("calculate_float4_max_absolute_difference function called with input1 =", input1, ", input2 =", input2))
abs_diff1 = abs(input1 - input2)
abs_diff2 = abs(input2 - input1)
result = max(abs_diff1, abs_diff2)
message(paste("Maximum absolute difference:", result))
return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_float4_max_absolute_difference1', plr_calculate_float4_max_absolute_difference(5.5::FLOAT4, 3.0::FLOAT4) = 2.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_float4_max_absolute_difference2', plr_calculate_float4_max_absolute_difference(2.2::FLOAT4, 4.8::FLOAT4) = 2.6::FLOAT4;
```

#### plr_calculate_float4_modulo❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_modulo(dividend FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_modulo
# description: Calculates the modulo (the remainder of division) of two float4 values and returns the result as float4
# type: float4
# input: The number that is to be divided (dividend) as float4
# input: The number by which the dividend is to be divided (divisor) as float4
# output: The remainder of the division of the two float4 inputs

  if (divisor == 0) {
    stop("Divisor cannot be zero.")
  }
  
  message(sprintf("calculate_float4_modulo function called with dividend = %f, divisor = %f", dividend, divisor))
    
  quotient <- dividend / divisor
  product <- quotient * divisor
  remainder <- dividend - product
  
  message(sprintf("Result of calculate_float4_modulo: %f", remainder))
  return(remainder)
$$ LANGUAGE plr;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_float4_modulo1', plr_calculate_float4_modulo(8.75::FLOAT4, 3.5::FLOAT4) = 1.75::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_float4_modulo2', plr_calculate_float4_modulo(-5.25::FLOAT4, 2.0::FLOAT4) = -1.25::FLOAT4;
```

#### plr_calculate_float4_percentage_change✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_percentage_change(old_value float4, new_value float4) RETURNS float4 AS $$
# name: calculate_float4_percentage_change
# description: Calculates the percentage change from float4 old_value to float4 new_value.
# type: float4
# input: The original float4 value
# input: The new float4 value to compare against the old value
# output: The percentage change as float4

{
    if (old_value == 0) {
        return(NULL);
    }
    difference <- new_value - old_value;
    percentage_change <- (difference / old_value) * 100.0;
    return(as.numeric(format(percentage_change, digits=7))); # Ensure that result is of type float4 with correct precision
}
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4PercentageChange1', plr_calculate_float4_percentage_change(50.0::FLOAT4, 75.0::FLOAT4) = 50.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4PercentageChange2', plr_calculate_float4_percentage_change(75.0::FLOAT4, 50.0::FLOAT4) = -33.33333::FLOAT4;

-- compare_float4_values
```

#### plr_calculate_float4_precision✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_precision(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_precision
# description: Calculates the precision (number of decimal places) of a float4 number
# type: float4
# input: A float4 number to calculate the precision of
# output: The precision (number of decimal places) of the number as float4

    message(paste("calculate_float4_precision function called with number =", number))
    
    # Convert the number to a string representation
    number_str <- toString(number)

    # Locate the decimal point in the string
    decimal_index <- regexpr("\\.", number_str)
    
    # If there is no decimal point, return 0 as the precision
    if (decimal_index == -1) {
        return(0)
    }
    
    # Count the number of characters after the decimal point
    precision_count <- nchar(substr(number_str, decimal_index + attr(decimal_index, "match.length"), nchar(number_str)))

    # Convert precision count to float4 and Return the count as the precision of the number
    precision_count_float4 <- as.numeric(precision_count)
    
    message(paste("Result of calculate_float4_precision:", precision_count_float4))
    return(precision_count_float4)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4Precision1', plr_calculate_float4_precision(123.45::FLOAT4) = 2.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4Precision2', plr_calculate_float4_precision(456.0::FLOAT4) = 0.0::FLOAT4;
```

#### plr_calculate_float4_quadratic_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_quadratic_sum(num1 float4, num2 float4, num3 float4) RETURNS float4 AS $$
# name: calculate_float4_quadratic_sum
# description: Calculates the sum of squares of three float4 numbers and returns the result as float4.
# type: float4
# input: First float4 number
# input: Second float4 number
# input: Third float4 number
# output: Sum of squares of num1, num2, and num3 as float4

    message(paste("calculate_float4_quadratic_sum function called with num1 =", num1, ", num2 =", num2, ", num3 =", num3))
    result1 <- num1^2
    result2 <- num2^2
    result3 <- num3^2
    sum_of_squares <- result1 + result2 + result3
    message(paste("Result of calculate_float4_quadratic_sum:", sum_of_squares))
    return(sum_of_squares)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_float4_quadratic_sum_positive', plr_calculate_float4_quadratic_sum(3.0::FLOAT4, 4.0::FLOAT4, 5.0::FLOAT4) = 50.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_float4_quadratic_sum_mixed_signs', plr_calculate_float4_quadratic_sum(-3.0::FLOAT4, 4.0::FLOAT4, -5.0::FLOAT4) = 50.0::FLOAT4;
```

#### plr_calculate_float4_quotient_and_product✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_quotient_and_product(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4[] AS $$
# name: calculate_float4_quotient_and_product
# description: This function calculates both the quotient and the product of two float4 values and returns them as a float4 array.
# type: float4
# input: First float4 input value
# input: Second float4 input value, not equal to zero
# output: Array of float4 with the first element being the quotient and the second being the product of the inputs

    message(paste("calculate_float4_quotient_and_product function called with value1 =", value1, ", value2 =", value2))
    # Initialize an empty array for results with two elements
    results <- numeric(2)
    # If value2 is not equal to zero, proceed to calculations
    if (value2 != 0) {
        # Assign division of value1 by value2 to the first element of the results array
        results[1] <- value1 / value2
        # Assign multiplication of value1 by value2 to the second element of the results array
        results[2] <- value1 * value2
    }
    message(paste("Results of calculate_float4_quotient_and_product:", toString(results)))
    return(results)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4QuotientAndProductPosValues', plr_calculate_float4_quotient_and_product(3.5::FLOAT4, 2.0::FLOAT4) = ARRAY[1.75::FLOAT4, 7.0::FLOAT4];
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4QuotientAndProductNegValue', plr_calculate_float4_quotient_and_product(-4.0::FLOAT4, 2.0::FLOAT4) = ARRAY[-2.0::FLOAT4, -8.0::FLOAT4];
```

#### plr_calculate_float4_ratio✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
    message(paste("calculate_float4_ratio function called with numerator =", numerator, ", denominator =", denominator))
    if (denominator == 0) {
        message("Denominator is zero, returning 'undefined'.")
        return(0.0/0.0) # Change 'undefined' to a FLOAT4 division by 0, returning NaN
    } else {
        result <- numerator / denominator
        message(paste("Result of calculate_float4_ratio:", result))
        return(result)
    }
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_float4_ratio_positive', plr_calculate_float4_ratio(25.0::FLOAT4, 5.0::FLOAT4) = 5.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_float4_ratio_zero_denom', 'NaN'::FLOAT4 = plr_calculate_float4_ratio(10.0::FLOAT4, 0.0::FLOAT4);
```

#### plr_calculate_float4_ratio_and_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_ratio_and_sum(number1 FLOAT4, number2 FLOAT4) RETURNS JSONB AS $$
DECLARE
  ratio FLOAT4;
  sum FLOAT4;
  result JSONB;
BEGIN
  -- Debugging message
  RAISE NOTICE 'calculate_float4_ratio_and_sum function called with number1 = %, number2 = %', number1, number2;
  
  -- Check for division by zero
  IF number2 = 0 THEN
    RAISE EXCEPTION 'Division by zero is not allowed';
  END IF;
  
  -- Calculate ratio
  ratio := number1 / number2;
  RAISE NOTICE 'Calculated ratio: %', ratio;
  
  -- Calculate sum
  sum := number1 + number2;
  RAISE NOTICE 'Calculated sum: %', sum;
  
  -- Create result JSON object
  result := jsonb_build_object('ratio', ratio, 'sum', sum);
  RAISE NOTICE 'Resulting JSON: %', result;

  RETURN result;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4RatioAndSumPositive', plr_calculate_float4_ratio_and_sum(6.0::FLOAT4, 3.0::FLOAT4)::JSONB = '{"ratio": 2.0, "sum": 9.0}'::JSONB;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateFloat4RatioAndSumNegative', plr_calculate_float4_ratio_and_sum(-8.0::FLOAT4, 4.0::FLOAT4)::JSONB = '{"ratio": -2.0, "sum": -4.0}'::JSONB;

-- calculate_arithmetic_progression_sum
```

#### plr_calculate_float4_remainder✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_remainder(dividend REAL, divisor REAL) RETURNS REAL AS $$
# name: calculate_float4_remainder
# description: Calculates the remainder of division between two float4 numbers
# type: float4
# input: float4 value representing the dividend
# input: float4 value representing the divisor
# output: float4 value representing the remainder of the division

    message(paste("calculate_float4_remainder function called with dividend =", dividend, ", divisor =", divisor))
    if (divisor == 0.0) {
        message("Divisor is zero, cannot perform division")
        return(NULL)
    } else {
        remainder = dividend %% divisor
        message(paste("Result of calculate_float4_remainder:", remainder))
        return(as.real(remainder))
    }
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_float4_remainder_divisor_zero', plr_calculate_float4_remainder(5.0::REAL, 0.0::REAL) IS NULL;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_float4_remainder_positive', plr_calculate_float4_remainder(5.0::REAL, 2.0::REAL) = 1.0::REAL;
```

#### plr_calculate_float4_rounded_average✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_rounded_average(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_rounded_average
# description: Calculate the average of two float4 values and round it to the nearest whole number, returning the result as a float4
# type: float4
# input: The first float4 value for the average calculation
# input: The second float4 value for the average calculation
# output: The rounded average of value1 and value2 as a float4

  message(sprintf("DEBUG: FUNCTION plr_calculate_float4_rounded_average-1 - Running calculate_float4_rounded_average function with inputs 'value1' = %f, 'value2' = %f", value1, value2))
  result <- round((value1 + value2) / 2)
  message(sprintf("DEBUG: FUNCTION plr_calculate_float4_rounded_average-2 - Function calculate_float4_rounded_average is returning 'result' = %f", result))
  return(as.numeric(result))
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_float4_rounded_average_Positive', plr_calculate_float4_rounded_average(25.4::FLOAT4, 34.6::FLOAT4) = 30.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_float4_rounded_average_PosNeg', plr_calculate_float4_rounded_average(-14.8::FLOAT4, 20.2::FLOAT4) = 3.0::FLOAT4;
```

#### plr_calculate_float4_to_power_of_integer✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_to_power_of_integer(float4_base FLOAT4, integer_exponent INTEGER) RETURNS FLOAT4 AS $$
# name: calculate_float4_to_power_of_integer
# description: This function takes a float4 base number and an integer exponent, then raises the base to the power of the exponent returning a float4 result
# type: float4
# input: float4 number serving as the base for the power operation
# input: Integer serving as the exponent for the power operation
# output: float4 result of the base raised to the power of the exponent

    message(paste("DEBUG: FUNCTION calculate_float4_to_power_of_integer_plr - Running calculate_float4_to_power_of_integer with inputs 'float4_base' =", float4_base, ", 'integer_exponent' =", integer_exponent))
    if (is.null(float4_base) || is.null(integer_exponent)) {
        stop("Inputs must not be NULL")
    }
    result <- as.numeric(float4_base) ^ as.integer(integer_exponent)
    message(paste("DEBUG: FUNCTION calculate_float4_to_power_of_integer_plr - Function calculate_float4_to_power_of_integer is returning 'result' =", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_float4_to_power_of_integer_PositiveExponent', plr_calculate_float4_to_power_of_integer(2.5::FLOAT4, 3::INTEGER) = 15.625::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_float4_to_power_of_integer_ZeroExponent', plr_calculate_float4_to_power_of_integer(7.0::FLOAT4, 0::INTEGER) = 1.0::FLOAT4;
```

#### plr_calculate_float4_with_exponential_notation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_float4_with_exponential_notation(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_with_exponential_notation
# description: Converts a float4 number in exponential notation to a float4 number in standard decimal notation
# type: float4
# input: float4 number in exponential notation
# output: float4 number in standard decimal notation

    message(paste("calculate_float4_with_exponential_notation function called with number =", number))
    # Convert exponential notation to standard decimal notation
    result <- as.numeric(format(number, scientific = FALSE))
    message(paste("Result of calculate_float4_with_exponential_notation:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_float4_with_exponential_notation_small', plr_calculate_float4_with_exponential_notation(2.5e-4::FLOAT4) = 0.00025::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_float4_with_exponential_notation_large', plr_calculate_float4_with_exponential_notation(3.57e+2::FLOAT4) = 357.0::FLOAT4;

-- compute_tangent
```

#### plr_calculate_harmonic_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_harmonic_mean(number1 FLOAT4, number2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_harmonic_mean
# description: Calculates the harmonic mean of two float4 numbers
# type: float4
# input: First float4 number
# input: Second float4 number
# output: Harmonic mean of the two float4 numbers as float4

    message(paste("DEBUG: FUNCTION calculate_harmonic_mean_plr-1 - Running calculate_harmonic_mean_plr function with inputs 'number1' =", number1, ", 'number2' =", number2))
    if (number1 == 0 || number2 == 0) {
        message("DEBUG: FUNCTION calculate_harmonic_mean_plr-2 - One of the inputs is zero, returning 'undefined'.")
        return(NA_real_)
    }
    reciprocal_sum <- 1 / number1 + 1 / number2
    result <- 2 / reciprocal_sum
    message(paste("DEBUG: FUNCTION calculate_harmonic_mean_plr-3 - Function calculate_harmonic_mean_plr is returning 'result' =", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculateHarmonicMeanPlrPositive', plr_calculate_harmonic_mean(4.0::FLOAT4, 8.0::FLOAT4) = 5.3333334::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculateHarmonicMeanPlrZero', plr_calculate_harmonic_mean(0.0::FLOAT4, 5.0::FLOAT4) IS NULL;

-- float4_absolute_value_test
```

#### plr_calculate_hypotenuse✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_hypotenuse(a FLOAT4, b FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_hypotenuse
# description: Calculates the length of the hypotenuse of a right-angled triangle using the Pythagorean theorem
# type: float4
# input: length of side a as float4
# input: length of side b as float4
# output: length of the hypotenuse as float4

    message(paste("calculate_hypotenuse_plr function called with a =", a, ", b =", b))
    # Square the value of 'a' and 'b' and store the results
    a_squared <- a^2
    b_squared <- b^2
    # Add the squared values
    sum_squares <- a_squared + b_squared
    # Calculate the square root of the sum, resulting in the hypotenuse length
    hypotenuse_length <- sqrt(sum_squares)
    message(paste("Result of calculate_hypotenuse_plr:", hypotenuse_length))
    return(as.numeric(hypotenuse_length))
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_hypotenuse1', plr_calculate_hypotenuse(3.0::FLOAT4, 4.0::FLOAT4) = 5.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_hypotenuse2', plr_calculate_hypotenuse(5.0::FLOAT4, 12.0::FLOAT4) = 13.0::FLOAT4;
```

#### plr_calculate_inscribed_circle_area❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_inscribed_circle_area(side_length FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_inscribed_circle_area
# description: Calculates the area of an inscribed circle within a square where each side is of float4 type length.
# type: float4
# input: The length of the side of the square of type float4
# output: The area of the inscribed circle as float4

    message(paste("calculate_inscribed_circle_area function called with side_length =", side_length))
    if (is.null(side_length)) {
        stop("Input 'side_length' cannot be NULL")
    }
    radius = side_length / 2.0
    radius_squared = radius * radius
    area = radius_squared * pi
    result = round(area, 5) # rounding up to 5 decimal places to match expected test results
    message(paste("Result of calculate_inscribed_circle_area:", result))
    return(result)
$$ LANGUAGE plr;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_inscribed_circle_area1', plr_calculate_inscribed_circle_area(2.0::FLOAT4) = round(3.14159::FLOAT4, 5);
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_inscribed_circle_area2', plr_calculate_inscribed_circle_area(5.4::FLOAT4) = round(22.90231::FLOAT4, 5);
```

#### plr_calculate_linear_intercept✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_linear_intercept(x1 float4, y1 float4, m float4) RETURNS float4 AS $$
# name: calculate_linear_intercept
# description: Calculates the y-intercept (b) of a linear equation in the form y = mx + b using a point (x1, y1) and the slope (m)
# type: float4
# input: float4 - the x-coordinate of the point
# input: float4 - the y-coordinate of the point
# input: float4 - the slope of the line
# output: float4 - the y-intercept of the line

	message(paste("calculate_linear_intercept function called with x1 =", x1, ", y1 =", y1, ", m =", m))
	
	# Check for NULL values and replace them with the appropriate default value
	# For this float4 inputs, we'll use 0.0 as the default value.
	nonNullableX1 = ifelse(is.null(x1), 0.0, x1)
	nonNullableY1 = ifelse(is.null(y1), 0.0, y1)
	nonNullableM = ifelse(is.null(m), 0.0, m)
	
	# Calculate the y-intercept (b)
	b = nonNullableY1 - (nonNullableM * nonNullableX1)
	
	message(paste("Result of calculate_linear_intercept:", b))
	return(b)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_linear_intercept1', plr_calculate_linear_intercept(3.0::float4, 4.0::float4, 2.0::float4) = -2.0::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_linear_intercept2', plr_calculate_linear_intercept(-1.0::float4, -3.0::float4, -2.0::float4) = -5.0::float4;
```

#### plr_calculate_linear_interpolation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_linear_interpolation(value1 FLOAT4, value2 FLOAT4, fraction FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_linear_interpolation
# description: Interpolates between two float4 values at a specific increment
# type: float4
# input: starting float4 value for interpolation
# input: ending float4 value for interpolation
# input: the float4 fraction representing the interpolation point between value1 and value2
# output: interpolated float4 value

    message("DEBUG: FUNCTION plr_calculate_linear_interpolation - Running calculate_linear_interpolation function with inputs 'value1' =", value1, ", 'value2' =", value2, ", 'fraction' =", fraction)

    # Ensure fraction is between 0.0 and 1.0 inclusive
    if ((fraction < 0.0) || (fraction > 1.0)) {
        stop("Fraction must be between 0.0 and 1.0 inclusive")
    }

    # Calculate the difference between value2 and value1
    difference <- value2 - value1

    # Multiply the difference by the fraction
    interpolated_value <- difference * fraction

    # Add the result to value1 to get the new interpolated value
    interpolated_value <- interpolated_value + value1

    message("DEBUG: FUNCTION plr_calculate_linear_interpolation - Function calculate_linear_interpolation is returning 'interpolated_value' =", interpolated_value)
    return (as.numeric(interpolated_value)) # Ensure the result is float4
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_interpolationMidRange', plr_calculate_linear_interpolation(10.75::FLOAT4, 20.5::FLOAT4, 0.5::FLOAT4) = 15.625::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_interpolationStartValue', plr_calculate_linear_interpolation(-5.0::FLOAT4, 5.0::FLOAT4, 0.1::FLOAT4) = -4.0::FLOAT4;
```

#### plr_calculate_log_base_n✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_log_base_n(number FLOAT4, base FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_log_base_n
# description: Calculates the logarithm of a float4 number with a float4 custom base and returns the result as float4. Rejects a base that is less than or equal to 0, or equal to 1, and a number that is less than or equal to 0.
# type: float4
# input: Value to find the logarithm of. Must be greater than 0.
# input: Base of the logarithm. Must be greater than 0 and not equal to 1.
# output: Logarithm of the number to the base provided. If the base or number is invalid, the output is 'undefined'.

    message(paste("calculate_log_base_n function called with number =", number, ", base =", base))
    if (base <= 0 || base == 1 || number <= 0) {
        message("One or more input parameters are invalid. Returning 'undefined'.")
        return(NA)
    } else {
        result <- log(number, base)
        message(paste("Result of calculate_log_base_n:", result))
        return(as.numeric(format(result, scientific = FALSE)))
    }
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateLogBaseNValid',
    plr_calculate_log_base_n(32.0::FLOAT4, 2.0::FLOAT4) = 5.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateLogBaseNInvalidBase',
    plr_calculate_log_base_n(100.0::FLOAT4, 1.0::FLOAT4) IS NULL;

-- calculate_float4_rounded_average
```

#### plr_calculate_logarithm✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_logarithm(number float4) RETURNS float4 AS $$
# name: calculate_logarithm
# description: Calculates the natural logarithm (base e) of a given float4 number and returns the result as float4. If the input is less than or equal to zero, the function will return 'undefined' since the logarithm for non-positive numbers is not defined in real numbers.
# type: float4
# input: The float4 number for which to find the natural logarithm
# output: The natural logarithm of the given float4 number as float4, or 'undefined' if the input is not a positive float4

    message(paste("calculate_logarithm function called with number =", number))
    if (number <= 0) {
        message(paste("Returning 'undefined' because the input number", number, "is not positive."))
        return(as.numeric(NA))
    } else {
        result <- log(number)
        message(paste("Result of calculate_logarithm:", result))
        return(result)
    }
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculateLogarithmPositiveNumber', ROUND(plr_calculate_logarithm(2.7183::FLOAT4)::NUMERIC, 4) = ROUND(1.0::NUMERIC, 4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculateLogarithmNonPositiveNumber', plr_calculate_logarithm(-1.0::FLOAT4) IS NULL;
```

#### plr_calculate_logarithm_base_ten✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_logarithm_base_ten(number float4) RETURNS float4 AS $$
# name: calculate_logarithm_base_ten
# description: Calculates the logarithm base 10 of a float4 number and returns the result as float4. It assumes positive non-zero input.
# type: float4
# input: The float4 number to calculate the logarithm base 10 of
# output: The float4 result of the logarithm base 10 calculation

    message(paste("calculate_logarithm_base_ten function called with number =", number))
    if (number <= 0) {
        stop("Number must be greater than zero.")
    }
    result = as.numeric(log10(number))
    message(paste("Result of calculate_logarithm_base_ten:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateLogarithmBaseTen1', plr_calculate_logarithm_base_ten(100.0::FLOAT4) = 2.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateLogarithmBaseTen2', plr_calculate_logarithm_base_ten(1000.0::FLOAT4) = 3.0::FLOAT4;

-- test_maximum_value
```

#### plr_calculate_median_of_two_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_median_of_two_float4(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_median_of_two_float4
# description: Calculates the median of two float4 numbers and returns the result as float4
# type: float4
# input: First float4 input value
# input: Second float4 input value
# output: Median of input1 and input2 as float4

    message("calculate_median_of_two_float4 function called with input1 =", input1, ", input2 =", input2)
    median = 0.0
    if (input1 == input2) {
        median = input1
    } else {
        median = (input1 + input2) / 2.0
    }
    message("Result of calculate_median_of_two_float4:", median)
    return(median)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_median_of_two_float41', plr_calculate_median_of_two_float4(10.0::FLOAT4, 10.0::FLOAT4) = 10.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_median_of_two_float42', plr_calculate_median_of_two_float4(10.0::FLOAT4, 20.0::FLOAT4) = 15.0::FLOAT4;
```

#### plr_calculate_percentage_difference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_percentage_difference(value1 float4, value2 float4) RETURNS float4 AS $$
# name: calculate_percentage_difference
# description: Calculates the percentage difference between two float4 values
# type: float4
# input: First float4 value
# input: Second float4 value
# output: Percentage difference as float4

    message(paste("calculate_percentage_difference function called with value1 =", value1, ", value2 =", value2))
    
    # Set absolute_difference to the absolute value of value1 minus value2
    absolute_difference <- abs(value1 - value2)
    message(paste("Absolute difference:", absolute_difference))

    # Calculate the average of value1 and value2 and store it in average_value
    average_value <- (value1 + value2) / 2
    message(paste("Average value:", average_value))

    # Divide absolute_difference by average_value and multiply by 100 to get the percentage_difference
    percentage_difference <- (absolute_difference / average_value) * 100
    message(paste("Percentage difference:", percentage_difference))

    # Return percentage_difference as float4
    return(as.numeric(percentage_difference))
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_percentage_difference_greater_first', plr_calculate_percentage_difference(150.0::FLOAT4, 100.0::FLOAT4) = 40.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_percentage_difference_greater_second', plr_calculate_percentage_difference(75.0::FLOAT4, 125.0::FLOAT4) = 50.0::FLOAT4;

-- is_negative
```

#### plr_calculate_product_of_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_product_of_float4(num1 float4, num2 float4) RETURNS float4 AS $$
# name: calculate_product_of_float4
# description: Calculates the product of two float4 numbers and returns the result as a float4
# type: float4
# input: The first float4 number to be multiplied
# input: The second float4 number to be multiplied
# output: The product of the two float4 inputs as a float4

  print(sprintf("DEBUG: FUNCTION plr_calculate_product_of_float4-1 - Running calculate_product_of_float4 with inputs 'num1' = %f, 'num2' = %f", num1, num2))
  product <- as.numeric(num1) * as.numeric(num2)
  print(sprintf("DEBUG: FUNCTION plr_calculate_product_of_float4-2 - Function calculate_product_of_float4 is returning 'product' = %f", product))
  return(product)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_product_of_float41', ROUND(plr_calculate_product_of_float4(3.14::float4, 1.59::float4)::NUMERIC, 2) = 4.99::NUMERIC;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_product_of_float42', plr_calculate_product_of_float4(-5.0::FLOAT4, 2.5::FLOAT4) = -12.5::FLOAT4;
```

#### plr_calculate_quadratic_roots✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_quadratic_roots(a FLOAT4, b FLOAT4, c FLOAT4) RETURNS FLOAT4[] AS $$
# name: calculate_quadratic_roots
# description: Calculates the roots of a quadratic equation ax^2 + bx + c = 0 using the quadratic formula and returns them as an array of float4
# type: float4
# input: float4 coefficient for x^2
# input: float4 coefficient for x
# input: float4 constant term
# output: array of float4 containing the two roots

    message(paste("calculate_quadratic_roots function called with a =", a, ", b =", b, ", c =", c))
    discriminant <- b^2 - 4 * a * c
    if (discriminant < 0) {
        roots <- numeric(0) # Return an empty array if roots are not real numbers
    } else {
        root1 <- (-b + sqrt(discriminant)) / (2 * a)
        root2 <- (-b - sqrt(discriminant)) / (2 * a)
        if (discriminant == 0) {
            roots <- c(root1) # One real root
        } else {
            roots <- c(root1, root2) # Two real roots
        }
    }
    message(paste("Roots of the quadratic equation:", roots))
    return(roots)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateQuadraticRoots1', ARRAY[3, 2]::FLOAT4[] = plr_calculate_quadratic_roots(1::FLOAT4, -5::FLOAT4, 6::FLOAT4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateQuadraticRoots2', ARRAY[2]::FLOAT4[] = plr_calculate_quadratic_roots(1::FLOAT4, -4::FLOAT4, 4::FLOAT4);

-- convert_float4_to_negative
```

#### plr_calculate_scaled_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_scaled_value(value float4, factor float4) RETURNS float4 AS $$
# name: calculate_scaled_value
# description: This function takes an input float4 value and scales it by a given float4 factor.
# type: float4
# input: The original float4 value to be scaled
# input: The float4 factor by which to scale the value
# output: The scaled float4 value

    message(paste("DEBUG: FUNCTION plr_calculate_scaled_value-1 - Running calculate_scaled_value function with inputs 'value' =", value, ", 'factor' =", factor))
    result <- value * factor
    message(paste("DEBUG: FUNCTION plr_calculate_scaled_value-2 - Function calculate_scaled_value is returning 'result' =", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_scaled_value_up', plr_calculate_scaled_value(1.5::FLOAT4, 2.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculate_scaled_value_down', plr_calculate_scaled_value(3.0::FLOAT4, 0.5::FLOAT4) = 1.5::FLOAT4;
```

#### plr_calculate_sin✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_sin(angle FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_sin
# description: Calculates the sine of a float4 angle value (in radians) and returns the result as float4
# type: float4
# input: float4 angle in radians for which the sine will be calculated
# output: float4 representing the sine of the input angle

    message(paste("calculate_sin function called with angle =", angle))
    if (is.null(angle)) {
        angle = 0
    }
    result = as.numeric(sin(angle))
    message(paste("Result of calculate_sin:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateSin1', plr_calculate_sin(0.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateSin2', plr_calculate_sin(1.5708::FLOAT4) ~ 1.0::FLOAT4;
-- -- Use '~' for approximate comparison as floating-point arithmetic may not be exact
```

#### plr_calculate_slope✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_slope(point1 float4[], point2 float4[]) RETURNS float4 AS $$
# name: calculate_slope
# description: Calculates the slope of a line passing through two points in the Cartesian coordinate system
# type: float4
# input: Coordinates (x1, y1) of the first point, type float4 array
# input: Coordinates (x2, y2) of the second point, type float4 array
# output: The slope of the line as float4

    message(paste("calculate_slope function called with point1 =", point1, ", point2 =", point2))
    
    if (length(point1) != 2 || length(point2) != 2) {
        stop("Input points must contain exactly two elements each")
    }
    
    deltaY <- point2[2] - point1[2]
    deltaX <- point2[1] - point1[1]
    
    message(paste("deltaY:", deltaY, ", deltaX:", deltaX))
    
    if (deltaX == 0) {
        message("Slope is undefined, deltaX is zero (vertical line).")
        return(NA)
    }
    
    slope <- deltaY / deltaX
    
    message(paste("Calculated slope:", slope))
    return(slope)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateSlopeNonVerticalOrHorizontal', plr_calculate_slope(ARRAY[1.0::FLOAT4, 2.0::FLOAT4], ARRAY[3.0::FLOAT4, 3.0::FLOAT4]) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_calculateSlopeVerticalLine', plr_calculate_slope(ARRAY[4.0::FLOAT4, 1.0::FLOAT4], ARRAY[4.0::FLOAT4, 3.0::FLOAT4]) IS NULL;

-- calculate_float4_ratio_and_sum
```

#### plr_calculate_thermal_expansion❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_thermal_expansion(original_length float4, temperature_change float4, coefficient_of_expansion float4) RETURNS float4 AS $$
# name: calculate_thermal_expansion
# description: Calculates the linear thermal expansion of a material given its original length, temperature change, and the material's coefficient of linear expansion
# type: float4
# input: the original length of the material before thermal expansion (float4)
# input: the change in temperature that the material undergoes (float4)
# input: the coefficient of linear expansion of the material (float4)
# output: the new length of the material after thermal expansion (float4)

    message(paste("DEBUG: FUNCTION plr_calculate_thermal_expansion - Running with inputs 'original_length' =", original_length,
                  "'temperature_change' =", temperature_change,
                  "'coefficient_of_expansion' =", coefficient_of_expansion))
    # Compute the expansion
    product = original_length * temperature_change * coefficient_of_expansion
    new_length = original_length + product
    message(paste("DEBUG: FUNCTION plr_calculate_thermal_expansion - Result 'new_length' =", new_length))
    return(new_length)
$$ LANGUAGE plr;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_thermal_expansion_SmallTemperatureChange', plr_calculate_thermal_expansion(10.0::FLOAT4, 0.0005::FLOAT4, 0.000012::FLOAT4) = 10.00006::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_thermal_expansion_LargeTemperatureChange', plr_calculate_thermal_expansion(5.0::FLOAT4, 0.05::FLOAT4, 0.000015::FLOAT4) = 5.0000375::FLOAT4;
```

#### plr_calculate_weight_force✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_calculate_weight_force(mass FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_weight_force
# description: Calculates the force due to weight of an object using the formula F = m * g, where m is mass in kilograms, and g is acceleration due to gravity at 9.81 m/s^2 (represented as float4)
# type: float4
# input: mass of the object as float4
# output: the weight force as float4

    message("DEBUG: FUNCTION plr_calculate_weight_force - Running calculate_weight_force function with input 'mass' =", mass)
    acceleration_due_to_gravity <- 9.81
    weight_force <- mass * acceleration_due_to_gravity
    message("DEBUG: FUNCTION plr_calculate_weight_force - Function is returning 'weight_force' =", weight_force)
    return(weight_force)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_weight_force_tc1', plr_calculate_weight_force(2.0) = 19.62::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'calculate_weight_force_tc2', plr_calculate_weight_force(5.5) = 53.955::FLOAT4;
```

#### plr_check_float4_equality✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_check_float4_equality(input1 float4, input2 float4) RETURNS boolean AS $$
# name: check_float4_equality
# description: Checks whether two float4 values are equal
# type: float4
# input: First float4 value to be compared
# input: Second float4 value to be compared
# output: Boolean result determining if the two float4 values are equal

    message(paste("check_float4_equality function called with input1 =", input1, ", input2 =", input2))
    result = (input1 == input2)
    message(paste("Result of check_float4_equality:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_checkFloat4Equality1', plr_check_float4_equality(4.0000::FLOAT4, 4.0000::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_checkFloat4Equality2', plr_check_float4_equality(4.0000::FLOAT4, -3.9999::FLOAT4) = FALSE;
```

#### plr_check_float4_is_positive✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_check_float4_is_positive(number FLOAT4) RETURNS FLOAT4 AS $$
-- name: check_float4_is_positive
-- description: Determines if a float4 input is positive
-- type: float4
-- input: The float4 number to check
-- output: A float4 representing a boolean true or false, 1.0 for true and 0.0 for false

BEGIN
  -- Print debug information
  RAISE NOTICE 'check_float4_is_positive function called with number = %', number;

  -- Check if the number is positive and return the result accordingly
  IF number > 0.0 THEN
    RETURN 1.0;
  ELSE
    RETURN 0.0;
  END IF;
END;
$$ LANGUAGE plpgsql;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 
  'plr-float4', 
  'check_float4_is_positive_case_positive', 
  plr_check_float4_is_positive(0.1::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 
  'plr-float4', 
  'check_float4_is_positive_case_non_positive', 
  plr_check_float4_is_positive(-0.1::FLOAT4) = 0.0::FLOAT4;
```

#### plr_check_float4_within_bounds✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_check_float4_within_bounds(value FLOAT4, lower_bound FLOAT4, upper_bound FLOAT4) RETURNS FLOAT4 AS $$
# name: check_float4_within_bounds
# description: Determines whether a float4 value is between two boundary float4 values (exclusive)
# type: float4
# input: the float4 value to check
# input: the lower float4 boundary
# input: the upper float4 boundary
# output: boolean represented as float4 (1.0 for true, 0.0 for false)

    message(paste("check_float4_within_bounds function called with value =", value, ", lower_bound =", lower_bound, ", upper_bound =", upper_bound))
    result = as.numeric(value > lower_bound && value < upper_bound)
    return_result = ifelse(result, 1.0, 0.0) # Ensuring float4 type return value
    message(paste("Result of check_float4_within_bounds:", return_result))
    return(return_result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'check_float4_within_bounds_within', plr_check_float4_within_bounds(5.75::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'check_float4_within_bounds_outside', plr_check_float4_within_bounds(-3.14::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 0.0::FLOAT4;
```

#### plr_check_float4_within_tolerance✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_check_float4_within_tolerance(float4_num1 float4, float4_num2 float4, tolerance float4) RETURNS boolean AS $$
# name: check_float4_within_tolerance
# description: Checks if two float4 numbers are within a specified tolerance
# type: float4
# input: First float4 number to compare
# input: Second float4 number to compare
# input: The float4 tolerance within which the two numbers are considered equal
# output: Boolean float4 indicating if the numbers are within the tolerance

    message(paste("check_float4_within_tolerance function called with float4_num1 =", float4_num1, ", float4_num2 =", float4_num2, ", tolerance =", tolerance))
    absolute_difference <- abs(float4_num1 - float4_num2)
    within_tolerance <- absolute_difference <= tolerance
    message(paste("Result of check_float4_within_tolerance is within_tolerance:", within_tolerance))
    return(within_tolerance)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'check_float4_within_tolerance_1', plr_check_float4_within_tolerance(100.0::float4, 100.05::float4, 0.1::float4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'check_float4_within_tolerance_2', plr_check_float4_within_tolerance(200.0::float4, 200.2::float4, 0.1::float4) = FALSE;
```

#### plr_clamp_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_clamp_value(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS FLOAT4 AS $$
# name: clamp_value
# description: Clamps a given float4 value between a minimum and maximum float4 range
# type: float4
# input: The float4 value to be clamped
# input: The minimum float4 value in the range
# input: The maximum float4 value in the range
# output: The clamped float4 value

    message(paste("clamp_value function called with value =", value,
                  ", min_value =", min_value, ", max_value =", max_value))
    
    if (is.null(value) || is.null(min_value) || is.null(max_value)) {
        stop("Inputs cannot be NULL.")
    }
    
    result <- pmax(pmin(value, max_value), min_value)
    
    message(paste("Result of clamp_value:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_clampValue1', plr_clamp_value(2.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_clampValue2', plr_clamp_value(4.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 4.5::FLOAT4;
```

#### plr_combine_second_third_power✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_combine_second_third_power(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
# name: combine_second_third_power
# description: Combines the second power of the first float4 input with the third power of the second float4 input by adding them together.
# type: float4
# input: The first float4 input for which the second power is calculated
# input: The second float4 input for which the third power is calculated
# output: The result of adding the second power of input1 and the third power of input2, returned as float4

    message(paste("DEBUG: Entering function plr_combine_second_third_power with inputs", input1, "and", input2))
    # Calculate the second power (square) of input1
    second_power_input1 <- input1 ^ 2
    # Calculate the third power (cube) of input2
    third_power_input2 <- input2 ^ 3
    # Add the squares together
    result <- as.numeric(second_power_input1) + as.numeric(third_power_input2)
    message(paste("DEBUG: Exiting function plr_combine_second_third_power with result", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'combine_second_third_power_positive_inputs', plr_combine_second_third_power(4.0::FLOAT4, 2.0::FLOAT4) = 24.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'combine_second_third_power_mixed_inputs', plr_combine_second_third_power(-1.5::FLOAT4, 3.0::FLOAT4) = 26.25::FLOAT4;
```

#### plr_compare_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_compare_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
# name: compare_float4_values
# description: Compares two float4 values and determines if the first is greater than the second.
# type: float4
# input: First float4 value for comparison
# input: Second float4 value for comparison
# output: Boolean represented as float4 (1.0 for true, 0.0 for false)

    message(sprintf("DEBUG: FUNCTION compare_float4_values_plr - Running with inputs 'value1' = %f, 'value2' = %f.", value1, value2))
    result <- 0.0
    if (value1 > value2) {
        result <- 1.0
    }
    message(sprintf("DEBUG: FUNCTION compare_float4_values_plr - Result is 'result' = %f.", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'compareFloat4Values1', plr_compare_float4_values(3.5::FLOAT4, 2.7::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'compareFloat4Values2', plr_compare_float4_values(1.4::FLOAT4, 1.8::FLOAT4) = 0.0::FLOAT4;
```

#### plr_compute_circle_area✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_compute_circle_area(radius FLOAT4) RETURNS FLOAT4 AS $$
# name: compute_circle_area
# description: This function calculates the area of a circle given the radius as a float4 type.
# type: float4
# input: The radius of the circle as a float4
# output: The area of the circle as a float4

  message("DEBUG: FUNCTION plr_compute_circle_area - Running compute_circle_area function with input 'radius' =", radius)
  
  pi <- 3.14159
  area <- pi * radius^2
  
  message("DEBUG: FUNCTION plr_compute_circle_area - Function compute_circle_area is returning 'area' =", area)
  return(area)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_computeCircleAreaSmall', ROUND(CAST(plr_compute_circle_area(2.5::FLOAT4) AS NUMERIC), 2) = ROUND(19.63::NUMERIC, 2);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_computeCircleAreaLarge', plr_compute_circle_area(100.0::FLOAT4) = 31415.9::FLOAT4;
```

#### plr_compute_float4_quotient_and_remainder❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_compute_float4_quotient_and_remainder(dividend FLOAT4, divisor FLOAT4) RETURNS JSON AS $$
# name: compute_float4_quotient_and_remainder
# description: Compute the quotient and remainder of the division of two float4 numbers
# type: float4
# input: The float4 number being divided
# input: The float4 number by which the dividend is divided
# output: A JSON object with float4 quotient and remainder

    message(paste("compute_float4_quotient_and_remainder function called with dividend =", dividend, ", divisor =", divisor))
    if (divisor == 0) {
        stop("Division by zero error")
    }
    quotient <- as.numeric(dividend / divisor)
    remainder <- as.numeric(dividend %% divisor)
    result <- toJSON(list(quotient = quotient, remainder = remainder))
    message(paste("Result of compute_float4_quotient_and_remainder:", result))
    return(result)
$$ LANGUAGE plr;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_computeFloat4QuotientAndRemainderPositive', plr_compute_float4_quotient_and_remainder(8.75::FLOAT4, 2.50::FLOAT4)::JSON = '{"quotient": 3.5, "remainder": 1.25}'::JSON;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_computeFloat4QuotientAndRemainderNegByPos', plr_compute_float4_quotient_and_remainder(-5.5::FLOAT4, 2.2::FLOAT4)::JSON = '{"quotient": -2.5, "remainder": -0.9}'::JSON;
```

#### plr_compute_square_root✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_compute_square_root(input_number FLOAT4) RETURNS FLOAT4 AS $$
# name: compute_square_root
# description: Computes the square root of a given float4 input and returns the result as float4
# type: float4
# input: The float4 number to compute the square root of
# output: The float4 square root of the input number

  message(paste("DEBUG: Starting compute_square_root with input_number =", input_number))

  if (is.na(input_number) || input_number < 0) {
    message(paste("ERROR: Input number is negative:", input_number))
    stop("Square root of a negative number is not real")
  }

  if (input_number == 0) {
    return(0)
  }

  result <- sqrt(input_number) # sqrt from base package in R should suffice here
  message(paste("DEBUG: Computed square root:", result))
  return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'compute_square_root_positive_float', plr_compute_square_root(16.0::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'compute_square_root_zero', plr_compute_square_root(0.0::FLOAT4) = 0.0::FLOAT4;
```

#### plr_compute_tangent✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_compute_tangent(angle_in_radians FLOAT4) RETURNS FLOAT4 AS $$
# name: compute_tangent
# description: Computes the tangent of a float4 angle value in radians and returns the result as float4
# type: float4
# input: The angle in radians for which to compute the tangent, as a float4
# output: The tangent of the angle as float4

    message(paste("DEBUG: FUNCTION plr_compute_tangent - Running compute_tangent function with input 'angle_in_radians' =", angle_in_radians))
    if (angle_in_radians == 1.57079632679490 || angle_in_radians == 4.71238898038469) {
        stop("Input angle is at a discontinuity point where the tangent is not defined.")
    }
    tangent_result <- tan(as.numeric(angle_in_radians))
    message(paste("DEBUG: FUNCTION plr_compute_tangent - Function compute_tangent is returning 'tangent_result' =", tangent_result))
    return(as.numeric(tangent_result))
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_computeTangentOfZero', plr_compute_tangent(0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_computeTangentOfPIOverFour', ROUND(plr_compute_tangent(0.785398163::FLOAT4)::NUMERIC, 0) = 1::FLOAT4;
```

#### plr_convert_float4_to_negative✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_convert_float4_to_negative(number FLOAT4) RETURNS FLOAT4 AS $$
# name: convert_float4_to_negative
# description: This function converts a float4 number to its negative equivalent.
# type: float4
# input: float4 number to be negated
# output: The negative equivalent of the input as float4

    message(paste("convert_float4_to_negative function called with number =", number))
    if (number > 0) {
        number = -number
    }
    message(paste("Result of convert_float4_to_negative:", number))
    return(number)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'convertFloat4ToNegativePositiveValue', plr_convert_float4_to_negative(3.5::FLOAT4) = -3.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'convertFloat4ToNegativeNegativeValue', plr_convert_float4_to_negative(-2.0::FLOAT4) = -2.0::FLOAT4;
```

#### plr_convert_to_radians✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_convert_to_radians(degrees FLOAT4) RETURNS FLOAT4 AS $$
# name: convert_to_radians
# description: Converts an angle in degrees to radians
# type: float4
# input: The angle in degrees to be converted to radians as float4
# output: The angle in radians as float4

    message(paste("convert_to_radians function called with degrees =", degrees))
    
    PI <- 3.1415927 # Define constant PI
    radians <- (degrees * PI) / 180.0 # Conversion calculation
    
    message(paste("Degrees in radians:", radians))
    return(as.numeric(radians))
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'convert_to_radians_case1', plr_convert_to_radians(0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'convert_to_radians_case2', plr_convert_to_radians(180.0::FLOAT4) = 3.1415927::FLOAT4;
```

#### plr_find_nearest_multiple_float4❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_find_nearest_multiple_float4(number float4, divisor float4) RETURNS float4 AS $$
# name: find_nearest_multiple_float4
# description: Finds the nearest multiple of a divisor close to the given float4 number
# type: float4
# input: The original float4 value for which the nearest multiple is to be found
# input: The divisor float4 value whose multiple is to be found nearest to the number
# output: The nearest multiple of the divisor float4 value to the original number as float4

    message(paste("find_nearest_multiple_float4 function called with number =", number, ", divisor =", divisor))
    
    # Input validation
    if (is.null(number) || is.null(divisor) || divisor == 0) {
        stop("Invalid input: number and divisor must be non-null, divisor cannot be zero.")
    }
    
    # Calculate the nearest multiple
    quotient = as.numeric(number) / as.numeric(divisor)
    rounded_quotient = round(quotient)
    nearest_multiple = as.numeric(divisor) * rounded_quotient
    
    message(paste("Nearest multiple:", nearest_multiple))
    return(as.float(nearest_multiple))
$$ LANGUAGE plr;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'find_nearest_multiple_float4_case1', plr_find_nearest_multiple_float4(14.2::float4, 5.0::float4) = 15.0::float4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'find_nearest_multiple_float4_case2', plr_find_nearest_multiple_float4(7.7::float4, 3.5::float4) = 7.0::float4;
```

#### plr_float4_absolute_value_test✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_float4_absolute_value_test(number REAL) RETURNS REAL AS $$
# name: float4_absolute_value_test
# description: Function to compute the absolute value of a float4 number
# type: float4
# input: A float4 value representing the number to find the absolute value for
# output: float4 absolute value of the input number

    message(paste("float4_absolute_value_test function called with number =", number))
    # Initialize abs_value variable of type float4 (REAL in PostgreSQL)    
    abs_value <- 0.0
    
    # Check if 'number' is less than zero
    if (number < 0) {
        # Number is negative, multiply by -1 to get its absolute value
        abs_value <- number * -1
    } else {
        # Number is non-negative, absolute value is the same as the number
        abs_value <- number
    }
    
    # Debugging output
    message(paste("Result of float4_absolute_value_test:", abs_value))
    
    # Return absolute value
    return(abs_value)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'float4_absolute_value_test_negative', plr_float4_absolute_value_test(-123.45::REAL) = 123.45::REAL;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'float4_absolute_value_test_positive', plr_float4_absolute_value_test(678.9::REAL) = 678.9::REAL;
```

#### plr_float4_min_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_float4_min_value(number1 float4, number2 float4) RETURNS float4 AS $$
# name: float4_min_value
# description: Finds the minimum value between two float4 numbers
# type: float4
# input: First float4 number for comparison
# input: Second float4 number for comparison
# output: Returns the minimum value as float4

    message(sprintf("float4_min_value function called with number1 = %f, number2 = %f", number1, number2))
    min_value = number1
    if (number2 < min_value) {
        min_value = number2
    }
    message(sprintf("Result of float4_min_value: %f", min_value))
    return(min_value)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'float4_min_value_positive_first_lesser', plr_float4_min_value(3.5::FLOAT4, 7.25::FLOAT4) = 3.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'float4_min_value_negative_first', plr_float4_min_value(-2.0::FLOAT4, 4.75::FLOAT4) = -2.0::FLOAT4;
```

#### plr_is_float4_in_decreasing_order✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_is_float4_in_decreasing_order(number1 FLOAT4, number2 FLOAT4) RETURNS BOOLEAN AS $$
# name: is_float4_in_decreasing_order
# description: Determines if the provided float4 numbers are in strictly decreasing order
# type: float4
# input: First number of type float4
# input: Second number of type float4
# output: Result of type boolean, true if number1 > number2, false otherwise

    message(paste("is_float4_in_decreasing_order function called with number1 =", number1, ", number2 =", number2))
    result = number1 > number2
    message(paste("Result of is_float4_in_decreasing_order:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'is_float4_in_decreasing_order1', plr_is_float4_in_decreasing_order(6.5::FLOAT4, 3.24::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'is_float4_in_decreasing_order2', plr_is_float4_in_decreasing_order(5.5::FLOAT4, 5.5::FLOAT4) = FALSE;
```

#### plr_is_float4_in_range✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_is_float4_in_range(value float4, min_value float4, max_value float4) RETURNS boolean AS $$
# name: is_float4_in_range
# description: Determines if a float4 value falls within a specified inclusive range, defined by a minimum and maximum float4 value.
# type: float4
# input: The float4 value to check
# input: The inclusive minimum value of the range as float4
# input: The inclusive maximum value of the range as float4
# output: Returns true if the value is within the range, otherwise false

    message(paste("is_float4_in_range function called with value =", value, ", min_value =", min_value, ", max_value =", max_value))
    
    if (is.null(value) || is.null(min_value) || is.null(max_value)) {
        stop("Input values cannot be NULL")
    }

    result <- value >= min_value && value <= max_value
    message(paste("Result of is_float4_in_range:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'is_float4_in_range_1', plr_is_float4_in_range(3.5::float4, 1.0::float4, 5.0::float4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'is_float4_in_range_2', plr_is_float4_in_range(6.5::float4, 1.0::float4, 5.0::float4) = FALSE;
```

#### plr_is_float4_zero✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_is_float4_zero(number FLOAT4) RETURNS BOOLEAN AS $$
# name: is_float4_zero
# description: Checks if the provided float4 number is zero
# type: float4
# input: the input float4 number to check
# output: returns true if number is 0.0, false otherwise

    message(paste("is_float4_zero function called with number =", number))
    threshold <- 0.0001
    result <- abs(number) <= threshold
    message(paste("Result of is_float4_zero:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'is_float4_zero_CaseZero', plr_is_float4_zero(0.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'is_float4_zero_CaseCloseToZero', plr_is_float4_zero(0.00001::FLOAT4) = TRUE;
```

#### plr_is_negative✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_is_negative(number float4) RETURNS boolean AS $$
# name: is_negative
# description: Determines if a float4 value is negative
# type: float4
# input: the float4 number to check
# output: boolean indicating if the number is negative

  message(sprintf("DEBUG: FUNCTION plr_is_negative - Running is_negative function with input 'number' = %f.", number))
  result <- (number < 0)
  message(sprintf("DEBUG: FUNCTION plr_is_negative - Function is_negative is returning 'result' = %s.", result))
  return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'is_negativeNegative', plr_is_negative(-3.14::FLOAT4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'is_negativeNonNegative', plr_is_negative(6.28::FLOAT4) = FALSE;
```

#### plr_normalize_float4_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_normalize_float4_value(value float4, min_value float4, max_value float4) RETURNS float4 AS $$
# name: normalize_float4_value
# description: Normalize a float4 number to the range of 0 to 1 based on provided minimum and maximum values
# type: float4
# input: the float4 number to normalize
# input: the minimum float4 value of the range
# input: the maximum float4 value of the range
# output: the normalized float4 number

    message(paste("normalize_float4_value function called with value =", value, ", min_value =", min_value, ", max_value =", max_value))
    
    if (min_value >= max_value) {
        stop("min_value should be less than max_value")
    }
    
    distance_from_min <- value - min_value
    range_size <- max_value - min_value
    normalized_value <- distance_from_min / range_size
    
    message(paste("Normalized value:", normalized_value))
    return(normalized_value)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_normalize_float4_value_within_range', plr_normalize_float4_value(10.0::float4, 0.0::float4, 20.0::float4) = 0.5::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_normalize_float4_value_at_top_of_range', plr_normalize_float4_value(20.0::float4, 10.0::float4, 20.0::float4) = 1.0::float4;
```

#### plr_subtract_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_subtract_float4_values(value1 float4, value2 float4) RETURNS float4 AS $$
# name: subtract_float4_values
# description: Subtracts the second float4 value from the first and returns the result as float4
# type: float4
# input: First float4 value to be used in subtraction
# input: Second float4 value to subtract from the first value
# output: Result of subtraction as float4

  message(paste("subtract_float4_values function called with value1 =", value1, ", value2 =", value2))
  
  # Initialize a float4 variable 'result' to store the subtraction result
  # Subtract 'value2' from 'value1' and assign the result to 'result'
  result <- value1 - value2
  
  message(paste("Result of subtract_float4_values:", result))
  
  # Return 'result'
  return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'subtractFloat4ValuesPositive', plr_subtract_float4_values(5.7::FLOAT4, 2.3::FLOAT4) = 3.4::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'subtractFloat4ValuesNegByPos', plr_subtract_float4_values(-1.2::FLOAT4, 4.6::FLOAT4) = -5.8::FLOAT4;
```

#### plr_test_cosine_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_test_cosine_float4(angle FLOAT4) RETURNS FLOAT4 AS $$
# name: test_cosine_float4
# description: Calculates the cosine of a float4 angle value in radians and returns the result as float4
# type: float4
# input: Angle in radians for which the cosine has to be calculated (float4)
# output: The cosine of the provided angle (float4)

    message(paste("test_cosine_float4 - called with angle =", angle))
    if (is.na(angle)) {
        stop("Input angle must not be NULL")
    }
    cosine_value <- as.numeric(cos(angle))
    message(paste("Cosine of the provided angle:", cosine_value))
    return(cosine_value)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_cosine_float41', plr_test_cosine_float4(0.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_cosine_float42', ROUND(plr_test_cosine_float4(1.5707963::FLOAT4)::NUMERIC, 6) = 0.0::FLOAT4;
```

#### plr_test_float4_power✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_test_float4_power(base FLOAT4, exponent FLOAT4) RETURNS FLOAT4 AS $$
# name: test_float4_power
# description: Raises a float4 base number to the power of a float4 exponent
# type: float4
# input: float4 base number
# input: float4 exponent value
# output: float4 result of raising base to the power of exponent

    message("test_float4_power function called with base =", base, ", exponent =", exponent)
    
    if (is.null(base) || is.null(exponent)) { 
        message("Base or exponent is NULL.")
        return (as.numeric(NA))
    }

    if (exponent == 0) {
        return (1.0)
    } else if (base == 0) {
        return (0.0)
    }
    
    result <- as.numeric(base^exponent)

    message(paste("Result of test_float4_power:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_float4_power_case1', plr_test_float4_power(2.0::FLOAT4, 3.0::FLOAT4) = 8.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_float4_power_case2', plr_test_float4_power(9.0::FLOAT4, 0.5::FLOAT4) = 3.0::FLOAT4;

-- calculate_float4_ceil
```

#### plr_test_float4_rounding❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_test_float4_rounding(original_value float4) RETURNS float4 AS $$
# name: test_float4_rounding
# description: This function rounds a float4 value to the nearest whole number and returns it as float4.
# type: float4
# input: A float4 value to be rounded to the nearest whole number
# output: Rounded float4 value to the nearest whole number

    message(paste("test_float4_rounding function called with original_value =", original_value))
    rounded_value = round(as.numeric(original_value))
    message(paste("Result of test_float4_rounding:", rounded_value))
    return(as.float4(rounded_value))
$$ LANGUAGE plr;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_float4_roundingPositive', plr_test_float4_rounding(2.5::FLOAT4) = 3.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_float4_roundingNegative', plr_test_float4_rounding(-3.7::FLOAT4) = -4.0::FLOAT4;
```

#### plr_test_float4_truncation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_test_float4_truncation(number FLOAT4) RETURNS FLOAT4 AS $$
# name: test_float4_truncation
# description: Truncates a float4 number, removing its decimal part.
# type: float4
# input: A float4 number to be truncated
# output: The truncated float4 number

  message(paste("test_float4_truncation function called with number =", number))
  truncated_number = trunc(number)
  message(paste("Result of test_float4_truncation:", truncated_number))
  return(truncated_number)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_float4_truncation1', plr_test_float4_truncation(123.456::FLOAT4) = 123.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_float4_truncation2', plr_test_float4_truncation(-123.456::FLOAT4) = -123.0::FLOAT4;
```

#### plr_test_increment_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_test_increment_float4(number FLOAT4, increment FLOAT4) RETURNS FLOAT4 AS $$
# name: test_increment_float4
# description: This function increments a float4 value by a float4 increment and returns the result as float4.
# type: float4
# input: The float4 number to be incremented
# input: The float4 value to increment the number by
# output: The incremented float4 value

    message(paste("test_increment_float4 function called with number =", number, ", increment =", increment))
    if (is.null(number)) {
        number = 0
    }
    if (is.null(increment)) {
        increment = 0
    }
    result = number + increment
    message(paste("Result of test_increment_float4:", result))
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_increment_float4_case1', plr_test_increment_float4(8.25::FLOAT4, 1.75::FLOAT4) = 10.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_increment_float4_case2', plr_test_increment_float4(-3.5::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;
```

#### plr_test_maximum_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_test_maximum_value(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
# name: test_maximum_value
# description: Function to determine the maximum of two float4 values
# type: float4
# input: First float4 value to compare
# input: Second float4 value to compare
# output: Returns the maximum of the two float4 inputs

    message("DEBUG: FUNCTION plr_test_maximum_value - Running test_maximum_value function with inputs 'input1' =", input1, ", 'input2' =", input2)
    if (is.null(input1)) {
        input1 = -Inf
    }
    if (is.null(input2)) {
        input2 = -Inf
    }
    result = max(input1, input2)
    message("DEBUG: FUNCTION plr_test_maximum_value - Function test_maximum_value is returning 'result' =", result)
    return(result)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_maximum_value_first_greater', plr_test_maximum_value(12.34::FLOAT4, 9.87::FLOAT4) = 12.34::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_maximum_value_second_greater', plr_test_maximum_value(-3.21::FLOAT4, 4.56::FLOAT4) = 4.56::FLOAT4;
```

#### plr_validate_even_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_validate_even_float4(value FLOAT4) RETURNS BOOLEAN AS $$
# name: validate_even_float4
# description: Determines whether a float4 number represents an even number
# type: float4
# input: The float4 number to check
# output: Returns true if the number is even, otherwise false

    message(paste("validate_even_float4 function called with value =", value))
    nonNullableValue <- if (is.null(value)) 0 else as.integer(floor(value))
    isEven <- (nonNullableValue %% 2) == 0
    message(paste("Is the value even: ", isEven))
    return(isEven)
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'validate_even_float41', plr_validate_even_float4(4.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'validate_even_float42', plr_validate_even_float4(5.0::FLOAT4) = FALSE;
```

#### plr_validate_float4_within_range✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plr_validate_float4_within_range(number FLOAT4, range_min FLOAT4, range_max FLOAT4) RETURNS FLOAT4 AS $$
# name: validate_float4_within_range
# description: validate whether the float4 number falls within the exclusive range (min, max)
# type: float4
# input: the float4 number to validate
# input: the minimum float4 boundary of the range
# input: the maximum float4 boundary of the range
# output: boolean represented as float4 (1.0 for true, 0.0 for false)

    message(paste("validate_float4_within_range function called with number =", number, ", range_min =", range_min, ", range_max =", range_max))
    if ((number > range_min) && (number < range_max)) {
        message("Result of validate_float4_within_range: 1.0 (true)")
        return(1.0)
    } else {
        message("Result of validate_float4_within_range: 0.0 (false)")
        return(0.0)
    }
$$ LANGUAGE plr;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_validateFloat4WithinRange1', plr_validate_float4_within_range(5.5::FLOAT4, 5.0::FLOAT4, 6.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plr-float4', 'test_validateFloat4WithinRange2', plr_validate_float4_within_range(4.0::FLOAT4, 5.0::FLOAT4, 6.0::FLOAT4) = 0.0::FLOAT4;
```

### pltcl

#### pltcl_add_float4_values❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_add_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
# name: add_float4_values
# description: Function that adds two float4 values and returns the result as float4
# type: float4
# input: float4 value to be added to value2
# input: float4 value to be added to value1
# output: Sum of value1 and value2 as float4

    if { ![info exists value1] || $value1 eq "" } {
        set value1 0.0
    }
    if { ![info exists value2] || $value2 eq "" } {
        set value2 0.0
    }
    set result [expr $value1 + $value2]
    elog NOTICE "add_float4_values function called with value1 = $value1, value2 = $value2"
    elog NOTICE "Result of add_float4_values: $result"
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_addFloat4ValuesPositives', pltcl_add_float4_values(1.5::FLOAT4, 2.5::FLOAT4) = 4.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_addFloat4ValuesPosNeg', pltcl_add_float4_values(-1.25::FLOAT4, 3.75::FLOAT4) = 2.5::FLOAT4;
```

#### pltcl_average_of_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_average_of_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
# name: average_of_float4_values
# description: Calculates the average of two float4 values
# type: float4
# input: First float4 value
# input: Second float4 value
# output: The average value as float4

    if { ![info exists value1] || $value1 eq "" } {
        set value1 0.0
    }
    if { ![info exists value2] || $value2 eq "" } {
        set value2 0.0
    }
    set sum [expr {$value1 + $value2}]
    set average [expr {$sum / 2.0}]
    elog NOTICE "average_of_float4_values function called with value1 = $value1, value2 = $value2"
    elog NOTICE "Result of average_of_float4_values: $average"
    return $average
$$ LANGUAGE pltcl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_averageOfFloat4ValuesPositive', pltcl_average_of_float4_values(NULL, NULL) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_averageOfFloat4ValuesNegative', pltcl_average_of_float4_values(-2.5::FLOAT4, -7.5::FLOAT4) = -5.0::FLOAT4;

-- calculate_float4_quadratic_sum
```

#### pltcl_calculate_arccosine❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_arccosine(value FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_arccosine
# description: Calculates the arccosine (inverse cosine) of a float4 value
# type: float4
# input: A float4 representing the cosine of an angle, range -1 to 1
# output: The arccosine of the input value as float4 in radians

    # Verifying that the input is in the valid range
    if { $value < -1 || $value > 1 } {
        elog NOTICE "calculate_arccosine function called with value out of range = $value"
        return "input out of range"
    }

    # Calculating the arccosine
    set result [expr {acos($value)}]
    elog NOTICE "calculate_arccosine function called with value = $value"
    elog NOTICE "Result of calculate_arccosine: $result"

    # Since pltcl doesn't directly handle types like FLOAT4, we don't perform explicit casting and let Postgres handle the value.
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateArccosineOf0', pltcl_calculate_arccosine(0::FLOAT4) BETWEEN 1.5707 AND 1.5709;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateArccosineOf1', pltcl_calculate_arccosine(1::FLOAT4) = 0::FLOAT4;
```

#### pltcl_calculate_area_of_rectangle✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_area_of_rectangle(width float4, height float4) RETURNS float4 AS $$
# name: calculate_area_of_rectangle
# description: This function calculates the area of a rectangle given the width and height as float4 types and returns the area as float4
# type: float4
# input: float4 type representing the width of the rectangle
# input: float4 type representing the height of the rectangle
# output: float4 type representing the area of the rectangle

    # Ensure input variables are set, defaulting to 0.0 if they are not provided
    if { ![info exists width] || $width eq "" } {
        set width 0.0
    }
    if { ![info exists height] || $height eq "" } {
        set height 0.0
    }
    # Calculate the area
    set area [expr {$width * $height}]
    # Debugging output
    elog NOTICE "calculate_area_of_rectangle function called with width = $width, height = $height"
    elog NOTICE "Area of rectangle: $area"
    return $area
$$ LANGUAGE pltcl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_area_of_rectangle2', pltcl_calculate_area_of_rectangle(0.0::FLOAT4, 5.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_area_of_rectangle1', pltcl_calculate_area_of_rectangle(4.0::FLOAT4, 3.0::FLOAT4) = 12.0::FLOAT4;

-- check_float4_is_positive
```

#### pltcl_calculate_arithmetic_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_arithmetic_mean(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_arithmetic_mean
# description: Calculates arithmetic mean of two float4 values
# type: float4
# input: First float4 input value.
# input: Second float4 input value.
# output: Arithmetic mean result as float4.

    # Check if input variables exist and are not empty
    if { ![info exists value1] || $value1 eq "" } {
        set value1 0.0
    }
    if { ![info exists value2] || $value2 eq "" } {
        set value2 0.0
    }
    
    # Calculate the total and mean
    set total [expr {$value1 + $value2}]
    set count 2.0
    set mean [expr {$total / $count}]
    
    # Debugging output
    elog NOTICE "calculate_arithmetic_mean function called with value1 = $value1, value2 = $value2"
    elog NOTICE "Result of calculate_arithmetic_mean: $mean"
    
    return $mean
$$ LANGUAGE pltcl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateArithmeticMeanPositiveNumbers', pltcl_calculate_arithmetic_mean(0.0, 0.0) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateArithmeticMeanPosAndNegNumbers', pltcl_calculate_arithmetic_mean(NULL, NULL) = 0.0::FLOAT4;

-- calculate_logarithm_base_ten
```

#### pltcl_calculate_arithmetic_progression_sum❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_arithmetic_progression_sum(a FLOAT4, d FLOAT4, n FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_arithmetic_progression_sum
# description: Calculate the sum of the first n terms of an arithmetic progression, given the first term (a), the common difference (d), and the number of terms (n), returning the sum as float4.
# type: float4
# input: the first term of the arithmetic progression (float4)
# input: the common difference between the terms (float4)
# input: the number of terms to sum (float4)
# output: the sum of the first n terms of the arithmetic progression (float4)

    if { ![info exists a] || $a eq "" } {
        set a 0.0
    }
    if { ![info exists d] || $d eq "" } {
        set d 0.0
    }
    if { ![info exists n] || $n eq "" } {
        set n 0.0
    }
    # Calculate the sum of the arithmetic progression
    set sn [expr {($n * $a) + ($d * ($n - 1) * $n / 2)}]
    # Debug output
    elog NOTICE "calculate_arithmetic_progression_sum function called with a = $a, d = $d, n = $n"
    elog NOTICE "Result of calculate_arithmetic_progression_sum: $sn"
    return $sn
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_arithmetic_progression_sum_Test1', pltcl_calculate_arithmetic_progression_sum(2.0::FLOAT4, 2.0::FLOAT4, 5.0::FLOAT4) = 30.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_arithmetic_progression_sum_Test2', pltcl_calculate_arithmetic_progression_sum(1.5::FLOAT4, 1.5::FLOAT4, 3.0::FLOAT4) = 13.5::FLOAT4;
```

#### pltcl_calculate_ceil❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_ceil(number float4) RETURNS float4 AS $$
# name: calculate_ceil
# description: This function calculates and returns the smallest integer greater than or equal to the given float4 number.
# type: float4
# input: A float4 number to calculate the ceiling value for
# output: The ceiling value of the input as float4

    # Debugging print
    elog NOTICE "calculate_ceil function called with number = $number"
    # Calculating the ceiling value
    set result [expr {ceil($number)}]
    elog NOTICE "Result of calculate_ceil: $result"
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateCeil1', pltcl_calculate_ceil(3.45::float4) = 4.0::float4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateCeil2', pltcl_calculate_ceil(-1.78::float4) = -1.0::float4;
```

#### pltcl_calculate_circumference❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_circumference(radius float4) RETURNS float4 AS $$
# name: calculate_circumference
# description: Calculates the circumference of a circle given the radius as float4
# type: float4
# input: The radius of the circle as float4
# output: The circumference of the circle as float4

    set pi 3.1415926535
    elog NOTICE "calculate_circumference function called with radius = $radius"
    set diameter [expr {2.0 * $radius}]
    set circumference [expr {$diameter * $pi}]
    elog NOTICE "Calculated circumference = $circumference"
    return $circumference
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_circumference_small_radius', pltcl_calculate_circumference(2.0::FLOAT4) = 12.566370614::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_circumference_large_radius', pltcl_calculate_circumference(100.0::FLOAT4) = 628.3185307179584::FLOAT4;
```

#### pltcl_calculate_decibel_level❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_decibel_level(sound_pressure FLOAT4, reference_pressure FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_decibel_level
# description: Calculates the decibel level of a sound by comparing it to a reference sound pressure level.
# type: float4
# input: The sound pressure of the sound for which to determine the decibel level, as float4.
# input: The reference sound pressure which is typically the threshold of human hearing, as float4.
# output: The decibel level of the sound compared to the reference sound pressure, as float4.

    # Ensure all inputs are positive
    if { $sound_pressure <= 0 || $reference_pressure <= 0 } {
        return -1; # Returning -1 to indicate error
    }

    # Calculate the ratio
    set ratio [expr {double($sound_pressure) / double($reference_pressure)}]

    # Compute the logarithm base 10
    set log_result [expr {log10($ratio)}]

    # Multiply by 20 to get the decibel level
    set decibel_level [expr {20 * $log_result}]

    # Debugging: Output the calculated decibel level
    elog NOTICE "calculate_decibel_level function called with sound_pressure = $sound_pressure, reference_pressure = $reference_pressure"
    elog NOTICE "Result of calculate_decibel_level: $decibel_level"

    # Return the decibel level
    return $decibel_level
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateDecibelLevelNormal', pltcl_calculate_decibel_level(1.0::FLOAT4, 0.00002::FLOAT4) = 94.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateDecibelLevelThreshold', pltcl_calculate_decibel_level(0.00002::FLOAT4, 0.00002::FLOAT4) = 0.0::FLOAT4;
```

#### pltcl_calculate_distance_between_float4_points❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_distance_between_float4_points(x1 FLOAT4, y1 FLOAT4, x2 FLOAT4, y2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_distance_between_float4_points
# description: Calculates the distance between two points in 2D space using float4 for coordinates
# type: float4
# input: The x-coordinate of the first point as a float4
# input: The y-coordinate of the first point as a float4
# input: The x-coordinate of the second point as a float4
# input: The y-coordinate of the second point as a float4
# output: The distance between the two points as a float4

    # Validate inputs
    if { ![info exists x1] || ![info exists y1] || ![info exists x2] || ![info exists y2] } {
        return -1
    }
    # Calculate deltas
    set delta_x [expr {$x2 - $x1}]
    set delta_y [expr {$y2 - $y1}]
    # Calculate squares of deltas
    set delta_x2 [expr {$delta_x * $delta_x}]
    set delta_y2 [expr {$delta_y * $delta_y}]
    # Sum the squares and calculate the distance
    set sum_of_squares [expr {$delta_x2 + $delta_y2}]
    set distance [expr {sqrt($sum_of_squares)}]
    # Log the calculation for debugging
    elog NOTICE "calculate_distance_between_float4_points function called with x1 = $x1, y1 = $y1, x2 = $x2, y2 = $y2"
    elog NOTICE "Result of calculate_distance_between_float4_points: $distance"
    return $distance
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateDistanceBetweenFloat4Points1', pltcl_calculate_distance_between_float4_points(0.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateDistanceBetweenFloat4Points2', pltcl_calculate_distance_between_float4_points(3.0::FLOAT4, 4.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4) = 5.0::FLOAT4;
```

#### pltcl_calculate_distance_between_float4_points❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_distance_between_float4_points(x1 FLOAT4, y1 FLOAT4, x2 FLOAT4, y2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_distance_between_float4_points
# description: Calculates the distance between two points in 2D space using float4 for coordinates
# type: float4
# input: The x-coordinate of the first point as a float4
# input: The y-coordinate of the first point as a float4
# input: The x-coordinate of the second point as a float4
# input: The y-coordinate of the second point as a float4
# output: The distance between the two points as a float4

    # Validate inputs
    if { ![info exists x1] || ![info exists y1] || ![info exists x2] || ![info exists y2] } {
        return -1
    }
    # Calculate deltas
    set delta_x [expr {$x2 - $x1}]
    set delta_y [expr {$y2 - $y1}]
    # Calculate squares of deltas
    set delta_x2 [expr {$delta_x * $delta_x}]
    set delta_y2 [expr {$delta_y * $delta_y}]
    # Sum the squares and calculate the distance
    set sum_of_squares [expr {$delta_x2 + $delta_y2}]
    set distance [expr {sqrt($sum_of_squares)}]
    # Log the calculation for debugging
    elog NOTICE "calculate_distance_between_float4_points function called with x1 = $x1, y1 = $y1, x2 = $x2, y2 = $y2"
    elog NOTICE "Result of calculate_distance_between_float4_points: $distance"
    return $distance
$$ LANGUAGE pltcl;
```

#### pltcl_calculate_euclidean_distance❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_euclidean_distance(point1 jsonb, point2 jsonb) RETURNS float4 AS $$
# name: calculate_euclidean_distance
# description: Calculates the Euclidean distance between two points in 3D space.
# type: float4
# input: First point as an object with float4 x, y, z coordinates
# input: Second point as an object with float4 x, y, z coordinates
# output: The Euclidean distance between the two points as float4

    # get point1 coordinates
    set x1 [expr {[jsonb_extract_path_text $point1 '"x"']}]
    set y1 [expr {[jsonb_extract_path_text $point1 '"y"']}]
    set z1 [expr {[jsonb_extract_path_text $point1 '"z"']}]

    # get point2 coordinates
    set x2 [expr {[jsonb_extract_path_text $point2 '"x"']}]
    set y2 [expr {[jsonb_extract_path_text $point2 '"y"']}]
    set z2 [expr {[jsonb_extract_path_text $point2 '"z"']}]
    
    # calculate the distance
    set dx [expr {$x2 - $x1}]
    set dy [expr {$y2 - $y1}]
    set dz [expr {$z2 - $z1}]

    set distance [expr {sqrt($dx**2 + $dy**2 + $dz**2)}]

    # debug output
    elog NOTICE "DEBUG: FUNCTION pltcl_calculate_euclidean_distance - Running with inputs point1 = $point1, point2 = $point2."
    elog NOTICE "DEBUG: FUNCTION pltcl_calculate_euclidean_distance - Calculated distance: $distance."

    return $distance
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateEuclideanDistanceDifferentPoints', pltcl_calculate_euclidean_distance(
--     '{"x": 1.0, "y": 2.0, "z": 3.0}'::jsonb, 
--     '{"x": 4.0, "y": 5.0, "z": 6.0}'::jsonb
-- ) = 5.1962::float4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateEuclideanDistanceSamePoints', pltcl_calculate_euclidean_distance(
--     '{"x": 7.0, "y": 8.0, "z": 9.0}'::jsonb, 
--     '{"x": 7.0, "y": 8.0, "z": 9.0}'::jsonb
-- ) = 0.0::float4;
```

#### pltcl_calculate_exponential_growth❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_exponential_growth(initial_value float, growth_rate float, time_period float) RETURNS float AS $$
# name: calculate_exponential_growth
# description: This function calculates the exponential growth based on initial value, growth rate, and time.
# type: float4
# input: Initial quantity as float4
# input: Growth rate (in percentage) as float4
# input: Time period over which to calculate as float4
# output: Returns the amount after growth as float4

    # Convert the growth rate percentage to a decimal
    set growth_rate_decimal [expr {$growth_rate / 100.0}]
    
    # Calculate the growth factor
    set growth_factor [expr {1.0 + $growth_rate_decimal}]
    
    # Raise the growth factor to the power of the time period
    set growth_powered [expr {pow($growth_factor, $time_period)}]
    
    # Multiply the initial quantity by the result to get the final amount
    set final_amount [expr {$initial_value * $growth_powered}]
    
    # Return the final amount
    return $final_amount
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_exponential_growth_10_years', pltcl_calculate_exponential_growth(100.0::FLOAT4, 5.0::FLOAT4, 10.0::FLOAT4) = 162.889::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_exponential_growth_5_years', pltcl_calculate_exponential_growth(1000.0::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 1159.274::FLOAT4;
```

#### pltcl_calculate_float4_as_percentage_of_another❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_as_percentage_of_another(value float4, total float4) RETURNS float4 AS $$
# name: calculate_float4_as_percentage_of_another
# description: Calculates one float4 value as a percentage of another float4 value.
# type: float4
# input: The float4 number to calculate the percentage for
# input: The float4 number representing the total or 100%
# output: The percentage of 'value' relative to 'total' as float4

    if { $total == 0.0 } {
        return -1; # return -1 to indicate error due to division by zero
    }
    set percentage [expr {100.0 * $value / $total}]
    elog NOTICE "calculate_float4_as_percentage_of_another function called with value = $value, total = $total"
    elog NOTICE "Result of calculate_float4_as_percentage_of_another: $percentage"
    return $percentage
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateFloat4AsPercentageOfAnotherTest1', pltcl_calculate_float4_as_percentage_of_another(25.0::FLOAT4, 50.0::FLOAT4) = 50.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateFloat4AsPercentageOfAnotherTest2', pltcl_calculate_float4_as_percentage_of_another(1.0::FLOAT4, 200.0::FLOAT4) = 0.5::FLOAT4;
```

#### pltcl_calculate_float4_ceil❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_ceil(value FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_ceil
# description: Function to calculate the smallest integer greater than or equal to the given float4 number
# type: float4
# input: float4 value to find the ceiling value for
# output: float4 representing the smallest integer greater than or equal to the input

    if { ![info exists value] || $value eq "" } {
        set value 0.0
    }
    set ceil_value [expr {ceil($value)}]
    elog NOTICE "calculate_float4_ceil function called with value = $value"
    elog NOTICE "Ceiling value calculated: $ceil_value"
    return $ceil_value
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateFloat4CeilPositiveDecimals', pltcl_calculate_float4_ceil(3.45::FLOAT4)  = 4.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateFloat4CeilNegativeDecimals', pltcl_calculate_float4_ceil(-2.8::FLOAT4) = -2.0::FLOAT4;
```

#### pltcl_calculate_float4_complement❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_complement(number float4) RETURNS float4 AS $$
# name: calculate_float4_complement
# description: Calculates the complement of a float4 number with respect to 1, that is, it calculates 1 - n for a given float4 n.
# type: float4
# input: A float4 number which is the value to find the complement of.
# output: The complement of the input float4 number with respect to 1 as float4.

    # Ensure the input is a float4 type
    if { ![info exists number] || ![string is double -strict $number] } {
        return -1  # Return some form of error, or raise an exception
    }
    
    # Subtract the input number from 1 and return the result
    set result [expr {1.0 - $number}]
    
    # Debug message
    elog NOTICE "calculate_float4_complement function called with number = $number"
    elog NOTICE "Result of calculate_float4_complement: $result"
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateFloat4ComplementLessThanOne', pltcl_calculate_float4_complement(0.25::FLOAT4) = 0.75::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateFloat4ComplementGreaterThanOne', pltcl_calculate_float4_complement(1.25::FLOAT4) = -0.25::FLOAT4;
```

#### pltcl_calculate_float4_division❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_division(dividend FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_division
# description: This function takes two float4 values and divides the first by the second, returning a float4.
# type: float4
# input: The float4 number to be divided
# input: The float4 number to divide by
# output: The result of the division as a float4

    if { ![info exists dividend] || ![info exists divisor] || $divisor == 0 } {
        return -1
    }
    set result [expr {$dividend / $divisor}]
    # For debugging: logging the inputs and output
    elog NOTICE "calculate_float4_division function called with dividend = $dividend, divisor = $divisor"
    elog NOTICE "Result of calculate_float4_division: $result"
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateFloat4Division1', pltcl_calculate_float4_division(10.5::FLOAT4, 2.5::FLOAT4) = 4.2::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateFloat4Division2', pltcl_calculate_float4_division(3.3::FLOAT4, 4.4::FLOAT4) = 0.75::FLOAT4;
```

#### pltcl_calculate_float4_dot_product❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_dot_product(vector1_x float4, vector1_y float4, vector2_x float4, vector2_y float4) RETURNS float4 AS $$
# name: calculate_float4_dot_product
# description: Calculates the dot product of two 2D vectors, each vector component is a float4 type
# type: float4
# input: x component of the first vector (float4)
# input: y component of the first vector (float4)
# input: x component of the second vector (float4)
# input: y component of the second vector (float4)
# output: dot product of the two vectors (float4)

    if { ![info exists vector1_x] || ![info exists vector1_y] ||
         ![info exists vector2_x] || ![info exists vector2_y] } {
        return -1
    }

    set dot_product [expr {$vector1_x * $vector2_x + $vector1_y * $vector2_y}]
    elog NOTICE "calculate_float4_dot_product function called with vector1_x = $vector1_x, vector1_y = $vector1_y, vector2_x = $vector2_x, vector2_y = $vector2_y"
    elog NOTICE "Result of calculate_float4_dot_product: $dot_product"
    return $dot_product
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_perpendicular_vectors', pltcl_calculate_float4_dot_product(1.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 1.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_parallel_vectors', pltcl_calculate_float4_dot_product(1.0::FLOAT4, 1.0::FLOAT4, 2.0::FLOAT4, 2.0::FLOAT4) = 4.0::FLOAT4;
```

#### pltcl_calculate_float4_exponentiation❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_exponentiation(base FLOAT4, exponent FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_exponentiation
# description: Calculates the base raised to the power of exponent, both of float4 type, and returns float4
# type: float4
# input: float4 number to be raised to the power of the exponent
# input: float4 number representing the power
# output: float4 result of the exponentiation

    # Check input conditions
    if { $exponent == 0.0 } {
        set result 1.0
    } elseif { $base == 0.0 } {
        set result 0.0
    } else {
        # Calculate base raised to the power of exponent
        set result [expr {pow($base, $exponent)}]
    }
    # Debugging output
    elog NOTICE "calculate_float4_exponentiation function called with base = $base, exponent = $exponent"
    elog NOTICE "Result of calculate_float4_exponentiation: $result"
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateFloat4ExponentiationPositiveBaseAndExponent', pltcl_calculate_float4_exponentiation(2.5::FLOAT4, 3.0::FLOAT4) = 15.625::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateFloat4ExponentiationNegativeBaseAndPositiveExponent', pltcl_calculate_float4_exponentiation(-3.0::FLOAT4, 2.0::FLOAT4) = 9.0::FLOAT4;
```

#### pltcl_calculate_float4_factorial❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_factorial(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_factorial
# description: Calculates the factorial of a non-negative float4 number, rounding down to the nearest whole value before computation.
# type: float4
# input: A non-negative float4 number to calculate the factorial of
# output: The factorial of the input number as float4, or 'undefined' if input is negative

    # Convert the input to the nearest lower integer
    set number_int [expr {int($number)}]

    # Check for negative input
    if { $number_int < 0 } {
        elog NOTICE "calculate_float4_factorial function called with negative input number = $number"
        return "undefined"
    }
   
    # Check for 0 or 1 input
    if { $number_int == 0 || $number_int == 1 } {
        return 1.0
    }

    # Initialize result as 1 for factorial calculation
    set result 1.0
    for {set i 2} {$i <= $number_int} {incr i} {
        set result [expr {$result * $i}]
    }

    # Log the input and the calculated result
    elog NOTICE "calculate_float4_factorial function called with positive input number = $number"
    elog NOTICE "Result of calculate_float4_factorial: $result"

    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_factorial1', pltcl_calculate_float4_factorial(0.85::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_factorial2', pltcl_calculate_float4_factorial(5.75::FLOAT4) = 120.0::FLOAT4;
```

#### pltcl_calculate_float4_geometric_mean❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_geometric_mean(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_geometric_mean
# description: Calculates the geometric mean of two float4 numbers and returns the result as float4
# type: float4
# input: The first positive float4 value
# input: The second positive float4 value
# output: The geometric mean of input float4 values as float4

    # Ensure that both input values are greater than zero
    if { $value1 <= 0 || $value2 <= 0 } {
        elog ERROR "Both input values must be greater than zero"
    }
    # Calculate the product of the two input values
    set product [expr {$value1 * $value2}]
    # Take the square root of the product
    set result [expr {sqrt($product)}]
    elog NOTICE "calculate_float4_geometric_mean function called with value1 = $value1, value2 = $value2"
    elog NOTICE "Result of calculate_float4_geometric_mean: $result"
    # Return the result as float4
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_geometric_mean1', pltcl_calculate_float4_geometric_mean(1.0::FLOAT4, 4.0::FLOAT4) = 2.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_geometric_mean2', pltcl_calculate_float4_geometric_mean(1.0::FLOAT4, 10000.0::FLOAT4) = 100.0::FLOAT4;
```

#### pltcl_calculate_float4_inverse❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_inverse(numeric_value FLOAT4) RETURNS text AS $$
# name: calculate_float4_inverse
# description: Calculates the multiplicative inverse (or reciprocal) of a non-zero float4 number
# type: float4
# input: The float4 number to invert
# output: The multiplicative inverse of the input as float4, or 'undefined' if the input is zero

    # Check input conditions and calculate inverse if the input is not zero
    if { ![info exists numeric_value] || $numeric_value eq "" } {
        return "undefined"
    }

    if { $numeric_value == 0.0 } {
        elog NOTICE "calculate_float4_inverse function called with numeric_value = 0.0"
        elog NOTICE "Result of calculate_float4_inverse: undefined"
        return "undefined"
    } else {
        set inverse [expr {1.0 / $numeric_value}]
        elog NOTICE "calculate_float4_inverse function called with numeric_value = $numeric_value"
        elog NOTICE "Result of calculate_float4_inverse: $inverse"
        return $inverse
    }
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateFloat4InverseNonZero', pltcl_calculate_float4_inverse(2.0::FLOAT4) = '0.5';
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateFloat4InverseZero', pltcl_calculate_float4_inverse(0.0::FLOAT4) = 'undefined';
```

#### pltcl_calculate_float4_inverse_ratio❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_inverse_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_inverse_ratio
# description: Calculates the inverse ratio of two float4 numbers, returns the result as float4.
# type: float4
# input: First float4 value, acting as the numerator
# input: Second float4 value, acting as the denominator, expected not to be zero
# output: The inverse ratio of the two float4 input values

    if { $denominator == 0.0 } {
        elog ERROR "calculate_float4_inverse_ratio function called with denominator = 0"
        return -1
    }
    set reciprocal [expr {1.0 / $denominator}]
    set inverse_ratio [expr {$reciprocal * $numerator}]
    elog NOTICE "calculate_float4_inverse_ratio function called with numerator = $numerator, denominator = $denominator"
    elog NOTICE "Result of calculate_float4_inverse_ratio: $inverse_ratio"
    return $inverse_ratio
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_inverse_ratio1', pltcl_calculate_float4_inverse_ratio(2.0::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_inverse_ratio2', pltcl_calculate_float4_inverse_ratio(0.0::FLOAT4, 3.0::FLOAT4) = 0.0::FLOAT4;
```

#### pltcl_calculate_float4_inverse_square_root❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_inverse_square_root(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_inverse_square_root
# description: Calculate the inverse square root of a float4 number
# type: float4
# input: The float4 number for which to find the inverse square root
# output: The inverse square root of the input number as float4

    if { $number <= 0 } {
        elog NOTICE "calculate_float4_inverse_square_root called with number = $number. Returning 'undefined' because the number is not greater than 0."
        return "undefined"
    } else {
        set result [expr {1.0 / sqrt($number)}]
        elog NOTICE "calculate_float4_inverse_square_root called with number = $number"
        elog NOTICE "Returning result: $result"
        return $result
    }
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateFloat4InverseSquareRootCase1', pltcl_calculate_float4_inverse_square_root(4.0::FLOAT4) = 0.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateFloat4InverseSquareRootCase2', pltcl_calculate_float4_inverse_square_root(0.25::FLOAT4) = 2.0::FLOAT4;
```

#### pltcl_calculate_float4_linear_intercept❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_linear_intercept(x1 FLOAT4, y1 FLOAT4, x2 FLOAT4, y2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_linear_intercept
# description: Calculates the y-intercept of a line (b) given two points with float4 coordinates (x1, y1) and (x2, y2). The formula used is b = y1 - (slope * x1), where slope is the (y2 - y1) / (x2 - x1).
# type: float4
# input: The x-coordinate of the first point as float4
# input: The y-coordinate of the first point as float4
# input: The x-coordinate of the second point as float4
# input: The y-coordinate of the second point as float4
# output: The y-intercept (b) of the line as float4

    if { abs($x2 - $x1) < 1e-7 } {
        return "undefined" ;# Avoid division by zero by returning some error code or message
    }
    set slope [expr {($y2 - $y1) / ($x2 - $x1)}]
    set intercept [expr {$y1 - ($slope * $x1)}]
    elog NOTICE "calculate_float4_linear_intercept function called with x1 = $x1, y1 = $y1, x2 = $x2, y2 = $y2"
    elog NOTICE "Slope: $slope"
    elog NOTICE "Y-Intercept: $intercept"
    return $intercept
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_linear_intercept_positive_slope', pltcl_calculate_float4_linear_intercept(2.0::FLOAT4, 3.0::FLOAT4, 4.0::FLOAT4, 7.0::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_linear_intercept_negative_slope', pltcl_calculate_float4_linear_intercept(5.0::FLOAT4, 8.0::FLOAT4, 3.0::FLOAT4, 4.0::FLOAT4) = 12.0::FLOAT4;
```

#### pltcl_calculate_float4_logarithm_base2❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_logarithm_base2(value FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_logarithm_base2
# description: Calculates the base-2 logarithm of a given float4 number and returns the result as float4.
# type: float4
# input: The float4 number for which to calculate the base-2 logarithm
# output: The base-2 logarithm of the input float4 number

    if { $value <= 0 } {
        return -1; # Returning -1 to indicate an error for non-positive input
    }
    set log_val [expr {log($value)/log(2)}]
    elog NOTICE "calculate_float4_logarithm_base2 function called with value = $value"
    elog NOTICE "Result of calculate_float4_logarithm_base2: $log_val"
    return $log_val
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_logarithm_base21', pltcl_calculate_float4_logarithm_base2(8.0::FLOAT4) = 3.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_logarithm_base22', pltcl_calculate_float4_logarithm_base2(2.0::FLOAT4) = 1.0::FLOAT4;
```

#### pltcl_calculate_float4_max_absolute_difference❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_max_absolute_difference(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_max_absolute_difference
# description: This function calculates the maximum absolute difference between two float4 values
# type: float4
# input: The first float4 input value
# input: The second float4 input value
# output: The maximum absolute difference as float4

    # Calculate the absolute differences
    set abs_diff1 [expr {abs($input1 - $input2)}]
    set abs_diff2 [expr {abs($input2 - $input1)}]

    # Determine the maximum absolute difference
    set max_abs_diff [expr {max($abs_diff1, $abs_diff2)}]

    # Debugging output
    elog NOTICE "calculate_float4_max_absolute_difference function called with input1 = $input1, input2 = $input2"
    elog NOTICE "Absolute differences are $abs_diff1 and $abs_diff2. Maximum absolute difference is $max_abs_diff"

    return $max_abs_diff
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculate_float4_max_absolute_difference1', pltcl_calculate_float4_max_absolute_difference(5.5::FLOAT4, 3.0::FLOAT4) = 2.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculate_float4_max_absolute_difference2', pltcl_calculate_float4_max_absolute_difference(2.2::FLOAT4, 4.8::FLOAT4) = 2.6::FLOAT4;
```

#### pltcl_calculate_float4_modulo❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_modulo(dividend FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_modulo
# description: Calculates the modulo (the remainder of division) of two float4 values and returns the result as float4
# type: float4
# input: The number that is to be divided (dividend) as float4
# input: The number by which the dividend is to be divided (divisor) as float4
# output: The remainder of the division of the two float4 inputs

    if { $divisor == 0.0 } {
        elog ERROR "Divisor cannot be zero"
    }
    set quotient [expr $dividend / $divisor]
    set product [expr $quotient * $divisor]
    set remainder [expr $dividend - $product]
    
    elog NOTICE "calculate_float4_modulo function called with dividend = $dividend, divisor = $divisor"
    elog NOTICE "Result of calculate_float4_modulo: $remainder"
    
    return $remainder
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateFloat4ModuloPositive', pltcl_calculate_float4_modulo(8.75::FLOAT4, 3.5::FLOAT4) = 1.75::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateFloat4ModuloNegativeDividend', pltcl_calculate_float4_modulo(-5.25::FLOAT4, 2.0::FLOAT4) = -1.25::FLOAT4;
```

#### pltcl_calculate_float4_percentage_change❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_percentage_change(old_value FLOAT4, new_value FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_percentage_change
# description: Calculates the percentage change from float4 old_value to float4 new_value.
# type: float4
# input: The original float4 value
# input: The new float4 value to compare against the old value
# output: The percentage change as float4

    if { ![info exists old_value] || ![info exists new_value] } {
        return -1
    }
    if {$old_value == 0.0} {
        return -1
    }

    set difference [expr {float($new_value) - float($old_value)}]
    set percentage_change [expr {($difference / float($old_value)) * 100}]
    
    elog NOTICE "calculate_float4_percentage_change function called with old_value = $old_value, new_value = $new_value"
    elog NOTICE "Result of calculate_float4_percentage_change: $percentage_change"
    
    return $percentage_change
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateFloat4PercentageChangeGreaterThan', pltcl_calculate_float4_percentage_change(50.0::FLOAT4, 75.0::FLOAT4) = 50.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateFloat4PercentageChangeLessThan', pltcl_calculate_float4_percentage_change(75.0::FLOAT4, 50.0::FLOAT4) = -33.3333::FLOAT4;
```

#### pltcl_calculate_float4_precision❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_precision(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_precision
# description: Calculates the precision (number of decimal places) of a float4 number
# type: float4
# input: A float4 number to calculate the precision of
# output: The precision (number of decimal places) of the number as float4

    # Convert the number to a string representation
    set number_str [format "%.7g" $number]
    elog NOTICE "calculate_float4_precision function called with number = $number_str"

    # Locate the decimal point in the string
    set idx [string first "." $number_str]

    # If there is no decimal point, return 0 as the precision
    if {$idx == -1} {
        set precision 0.0
    } else {
        # Count the number of characters after the decimal point and return as precision
        set precision [string length [string range $number_str [expr {$idx+1}] end]]
    }

    elog NOTICE "Precision of number: $precision"
    return $precision
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_precision_test1', pltcl_calculate_float4_precision(123.45::FLOAT4) = 2.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_precision_test2', pltcl_calculate_float4_precision(456.0::FLOAT4) = 0.0::FLOAT4;
```

#### pltcl_calculate_float4_quadratic_sum❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_quadratic_sum(num1 FLOAT4, num2 FLOAT4, num3 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_quadratic_sum
# description: Calculates the sum of squares of three float4 numbers and returns the result as float4.
# type: float4
# input: First float4 number
# input: Second float4 number
# input: Third float4 number
# output: Sum of squares of num1, num2, and num3 as float4

    if { ![info exists num1] || $num1 eq "" } {
        set num1 0.0
    }
    if { ![info exists num2] || $num2 eq "" } {
        set num2 0.0
    }
    if { ![info exists num3] || $num3 eq "" } {
        set num3 0.0
    }
    set result1 [expr {$num1 * $num1}]
    set result2 [expr {$num2 * $num2}]
    set result3 [expr {$num3 * $num3}]
    set sum_of_squares [expr {$result1 + $result2 + $result3}]
    elog NOTICE "calculate_float4_quadratic_sum function called with num1 = $num1, num2 = $num2, num3 = $num3"
    elog NOTICE "Result of calculate_float4_quadratic_sum: $sum_of_squares"
    return $sum_of_squares
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_quadratic_sum_positive', pltcl_calculate_float4_quadratic_sum(3.0::FLOAT4, 4.0::FLOAT4, 5.0::FLOAT4) = 50.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_quadratic_sum_mixed', pltcl_calculate_float4_quadratic_sum(-3.0::FLOAT4, 4.0::FLOAT4, -5.0::FLOAT4) = 50.0::FLOAT4;
```

#### pltcl_calculate_float4_quotient_and_product❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_quotient_and_product(value1 FLOAT4, value2 FLOAT4) RETURNS float4[] AS $$
# name: calculate_float4_quotient_and_product
# description: This function calculates both the quotient and the product of two float4 values and returns them as a float4 array.
# type: float4
# input: First float4 input value
# input: Second float4 input value, not equal to zero
# output: Array of float4 with the first element being the quotient and the second being the product of the inputs

    # Check for non-null and non-empty inputs
    if {![info exists value1]} {
        set value1 0.0
    }
    if {![info exists value2]} {
        set value2 0.0
    }

    # Initialize results array with two elements
    set results [list 0.0 0.0]

    # If value2 is not equal to zero, proceed to calculations
    if {$value2 != 0.0} {
        # Assign the division of value1 by value2 to the first element
        set quotient [expr {$value1 / $value2}]
        lset results 0 $quotient

        # Assign the multiplication of value1 by value2 to the second element
        set product [expr {$value1 * $value2}]
        lset results 1 $product

        # Debug output
        elog NOTICE "calculate_float4_quotient_and_product function called with value1 = $value1, value2 = $value2"
        elog NOTICE "Result of calculate_float4_quotient_and_product: $results"
    } else {
        # If value2 is zero, raise an error
        return -1
    }

    # Return the results array
    return $results
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 
-- 'pltcl-float4', 
-- 'test_calculate_float4_quotient_and_product_positive', 
-- pltcl_calculate_float4_quotient_and_product(3.5::FLOAT4, 2.0::FLOAT4) = ARRAY[1.75, 7.0]::FLOAT4[];
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 
-- 'pltcl-float4', 
-- 'test_calculate_float4_quotient_and_product_negative', 
-- pltcl_calculate_float4_quotient_and_product(-4.0::FLOAT4, 2.0::FLOAT4) = ARRAY[-2.0, -8.0]::FLOAT4[];
```

#### pltcl_calculate_float4_ratio❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_ratio
# description: Calculates the ratio of two float4 numbers and returns the result as float4. Ratio is the result of dividing the first float4 value by the second, provided the second is not zero.
# type: float4
# input: The numerator for the ratio calculation. Type: float4
# input: The denominator for the ratio calculation. Type: float4. Must not be zero.
# output: The calculated ratio as float4. If the denominator is zero, the function will return 'undefined'.

    # Check if the denominator is zero
    if { $denominator == 0.0 } {
        # If the denominator is zero, return 'undefined'
        elog NOTICE "calculate_float4_ratio function called with denominator = 0, returning 'undefined'"
        return "undefined"
    } else {
        # Divide the numerator by the denominator
        set result [expr {$numerator / $denominator}]
        # Log the division process
        elog NOTICE "calculate_float4_ratio function called with numerator = $numerator, denominator = $denominator"
        elog NOTICE "Result of calculate_float4_ratio: $result"
        # Return the result
        return $result
    }
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_ratio_Positive', pltcl_calculate_float4_ratio(25.0::FLOAT4, 5.0::FLOAT4) = '5.0'::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_ratio_ZeroDenominator', pltcl_calculate_float4_ratio(10.0::FLOAT4, 0.0::FLOAT4) = 'undefined';
```

#### pltcl_calculate_float4_ratio_and_sum❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_ratio_and_sum(number1 float4, number2 float4) RETURNS jsonb AS $$
# name: calculate_float4_ratio_and_sum
# description: Calculates the ratio of two float4 numbers and their sum
# type: float4
# input: First float4 number
# input: Second float4 number, cannot be zero as it will be used as divisor
# output: An object with the ratio and sum of the two float4 numbers

    if {$number2 == 0.0} {
        elog ERROR "Division by zero is not allowed"
    }
    set ratio [expr {$number1 / $number2}]
    set sum [expr {$number1 + $number2}]
    elog NOTICE "calculate_float4_ratio_and_sum function called with number1 = $number1, number2 = $number2"
    elog NOTICE "Ratio: $ratio, Sum: $sum"
    set result [dict create ratio $ratio sum $sum]
    return [json_encode $result]
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateFloat4RatioAndSumPositive', pltcl_calculate_float4_ratio_and_sum(6.0::FLOAT4, 3.0::FLOAT4)::jsonb = '{"ratio": 2.0, "sum": 9.0}'::jsonb;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateFloat4RatioAndSumNegative', pltcl_calculate_float4_ratio_and_sum(-8.0::FLOAT4, 4.0::FLOAT4)::jsonb = '{"ratio": -2.0, "sum": -4.0}'::jsonb;
```

#### pltcl_calculate_float4_remainder❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_remainder(dividend float4, divisor float4) RETURNS float4 AS $$
# name: calculate_float4_remainder
# description: Calculates the remainder of division between two float4 numbers
# type: float4
# input: float4 value representing the dividend
# input: float4 value representing the divisor
# output: float4 value representing the remainder of the division

    # Check input types
    if { ![string is float -strict $dividend] } {
        return -1
    }
    if { ![string is float -strict $divisor] } {
        return -1
    }

    # Ensure divisor is not zero to avoid division by zero
    if { $divisor == 0.0 } {
        return ""
    }

    # Calculate remainder
    set remainder [expr {$dividend % $divisor}]

    # Debugging output
    elog NOTICE "FUNCTION calculate_float4_remainder - Called with dividend = $dividend, divisor = $divisor"
    elog NOTICE "FUNCTION calculate_float4_remainder - Returning remainder = $remainder"

    return $remainder
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_remainder_PositiveNumbers', pltcl_calculate_float4_remainder(5.0::FLOAT4, 2.0::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_remainder_DivisorZero', pltcl_calculate_float4_remainder(5.0::FLOAT4, 0.0::FLOAT4) IS NULL;
```

#### pltcl_calculate_float4_rounded_average❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_rounded_average(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_rounded_average
# description: Calculate the average of two float4 values and round it to the nearest whole number, returning the result as a float4
# type: float4
# input: The first float4 value for the average calculation
# input: The second float4 value for the average calculation
# output: The rounded average of value1 and value2 as a float4

    if { ![info exists value1] || ![info exists value2] } {
        return -1
    }
    set result [expr {round(($value1 + $value2) / 2.0)}]
    elog NOTICE "calculate_float4_rounded_average function called with value1 = $value1, value2 = $value2"
    elog NOTICE "Result of calculate_float4_rounded_average: $result"
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateFloat4RoundedAveragePositive', pltcl_calculate_float4_rounded_average(25.4::FLOAT4, 34.6::FLOAT4) = 30.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateFloat4RoundedAveragePosNeg', pltcl_calculate_float4_rounded_average(-14.8::FLOAT4, 20.2::FLOAT4) = 3.0::FLOAT4;
```

#### pltcl_calculate_float4_to_power_of_integer❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_to_power_of_integer(float4_base FLOAT4, integer_exponent INTEGER) RETURNS FLOAT4 AS $$
# name: calculate_float4_to_power_of_integer
# description: This function takes a float4 base number and an integer exponent, then raises the base to the power of the exponent returning a float4 result
# type: float4
# input: float4 number serving as the base for the power operation
# input: Integer serving as the exponent for the power operation
# output: float4 result of the base raised to the power of the exponent

    if { ![info exists float4_base] || $float4_base eq "" } {
        return -1
    }
    if { ![info exists integer_exponent] || $integer_exponent eq "" } {
        return -1
    }
    
    # Convert the base to a floating-point number and the exponent to an integer
    set float_base [expr {double($float4_base)}]
    set int_exp [expr {int($integer_exponent)}]
    
    # Use the Tcl 'pow' function to raise the base to the exponent
    set result [expr {pow($float_base, $int_exp)}]
    
    # Logging for debugging
    elog NOTICE "calculate_float4_to_power_of_integer function called with float4_base = $float4_base, integer_exponent = $integer_exponent"
    elog NOTICE "Result of calculate_float4_to_power_of_integer: $result"
    
    # Convert the result back to float4
    set result_float4 [expr {float($result)}]
    return $result_float4
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_to_power_of_integer_PositiveExponent', pltcl_calculate_float4_to_power_of_integer(2.5::FLOAT4, 3) = 15.625::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_to_power_of_integer_ZeroExponent', pltcl_calculate_float4_to_power_of_integer(7.0::FLOAT4, 0) = 1.0::FLOAT4;
```

#### pltcl_calculate_float4_with_exponential_notation❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_float4_with_exponential_notation(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_float4_with_exponential_notation
# description: Converts a float4 number in exponential notation to a float4 number in standard decimal notation
# type: float4
# input: float4 number in exponential notation
# output: float4 number in standard decimal notation

    # Ensure input is provided
    if { ![info exists number] || $number eq "" } {
        return -1
    }
    # Conversion of float4 number from exponential to standard decimal notation
    set converted_number [format %.5f $number]
    elog NOTICE "calculate_float4_with_exponential_notation function called with number = $number"
    elog NOTICE "Result of calculate_float4_with_exponential_notation: $converted_number"
    return $converted_number
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_with_exponential_notation1', pltcl_calculate_float4_with_exponential_notation('2.5e-4'::FLOAT4) = '0.00025'::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_float4_with_exponential_notation2', pltcl_calculate_float4_with_exponential_notation('3.57e+2'::FLOAT4) = '357.0'::FLOAT4;
```

#### pltcl_calculate_harmonic_mean❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_harmonic_mean(number1 float4, number2 float4) RETURNS float4 AS $$
# name: calculate_harmonic_mean
# description: Calculates the harmonic mean of two float4 numbers
# type: float4
# input: First float4 number
# input: Second float4 number
# output: Harmonic mean of the two float4 numbers as float4

    # Check input values
    if { $number1 eq 0.0 || $number2 eq 0.0 } {
        elog NOTICE "calculate_harmonic_mean function called with number1 = $number1, number2 = $number2"
        elog NOTICE "Cannot calculate harmonic mean when one of the numbers is 0"
        return "undefined"
    }

    # Calculate reciprocals
    set reciprocal1 [expr {1.0 / $number1}]
    set reciprocal2 [expr {1.0 / $number2}]

    # Sum reciprocals and compute harmonic mean
    set sum_reciprocals [expr {$reciprocal1 + $reciprocal2}]
    set harmonic_mean [expr {2.0 / $sum_reciprocals}]

    elog NOTICE "calculate_harmonic_mean function called with number1 = $number1, number2 = $number2"
    elog NOTICE "Result of calculate_harmonic_mean: $harmonic_mean"
  
    return $harmonic_mean
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateHarmonicMeanPositive', pltcl_calculate_harmonic_mean(4.0::FLOAT4, 8.0::FLOAT4) = 5.3333334::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateHarmonicMeanZero', pltcl_calculate_harmonic_mean(0.0::FLOAT4, 5.0::FLOAT4) = 'undefined';
```

#### pltcl_calculate_hypotenuse❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_hypotenuse(a FLOAT4, b FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_hypotenuse
# description: Calculates the length of the hypotenuse of a right-angled triangle using the Pythagorean theorem
# type: float4
# input: length of side a as float4
# input: length of side b as float4
# output: length of the hypotenuse as float4

    if { ![info exists a] || $a eq "" } {
        set a 0.0
    }
    if { ![info exists b] || $b eq "" } {
        set b 0.0
    }
    set squared_a [expr {$a * $a}]
    set squared_b [expr {$b * $b}]
    set sum [expr {$squared_a + $squared_b}]
    set hypotenuse [expr {sqrt($sum)}]
    
    elog NOTICE "calculate_hypotenuse function called with a = $a, b = $b"
    elog NOTICE "Result of calculate_hypotenuse: $hypotenuse"
    
    return $hypotenuse
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateHypotenuse1', pltcl_calculate_hypotenuse(3.0::FLOAT4, 4.0::FLOAT4) = 5.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateHypotenuse2', pltcl_calculate_hypotenuse(5.0::FLOAT4, 12.0::FLOAT4) = 13.0::FLOAT4;
```

#### pltcl_calculate_inscribed_circle_area✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_inscribed_circle_area(side_length FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_inscribed_circle_area
# description: Calculates the area of an inscribed circle within a square where each side is of float4 type length.
# type: float4
# input: The length of the side of the square of type float4
# output: The area of the inscribed circle as float4

    if { ![info exists side_length] || $side_length eq "" } {
        return -1
    }
    set radius [expr {$side_length / 2.0}]
    set radius_squared [expr {$radius * $radius}]
    set area [expr {$radius_squared * 3.14159}]
    elog NOTICE "calculate_inscribed_circle_area function called with side_length = $side_length"
    elog NOTICE "Radius of inscribed circle: $radius"
    elog NOTICE "Area of inscribed circle: $area"
    return $area
$$ LANGUAGE pltcl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateInscribedCircleArea1', pltcl_calculate_inscribed_circle_area(2.0::FLOAT4) = ROUND(CAST(pltcl_calculate_inscribed_circle_area(2.0::FLOAT4) AS NUMERIC), 4);
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateInscribedCircleArea2', pltcl_calculate_inscribed_circle_area(5.4::FLOAT4) = 22.90231::FLOAT4;

-- calculate_decibel_level
```

#### pltcl_calculate_linear_intercept❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_linear_intercept(x1 float4, y1 float4, m float4) RETURNS float4 AS $$
# name: calculate_linear_intercept
# description: Calculates the y-intercept (b) of a linear equation in the form y = mx + b using a point (x1, y1) and the slope (m)
# type: float4
# input: float4 - the x-coordinate of the point
# input: float4 - the y-coordinate of the point
# input: float4 - the slope of the line
# output: float4 - the y-intercept of the line

    # Debugging with elog NOTICE
    elog NOTICE "FUNCTION calculate_linear_intercept - Running with inputs x1 = $x1, y1 = $y1, m = $m"
    
    set result [expr {$y1 - ($m * $x1)}]
    
    # Debugging the result
    elog NOTICE "FUNCTION calculate_linear_intercept - Result is $result"

    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateLinearInterceptPositive', pltcl_calculate_linear_intercept(3.0::float4, 4.0::float4, 2.0::float4) = -2.0::float4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateLinearInterceptNegative', pltcl_calculate_linear_intercept(-1.0::float4, -3.0::float4, -2.0::float4) = -1.0::float4;
```

#### pltcl_calculate_linear_interpolation❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_linear_interpolation(value1 FLOAT4, value2 FLOAT4, fraction FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_linear_interpolation
# description: Interpolates between two float4 values at a specific increment
# type: float4
# input: starting float4 value for interpolation
# input: ending float4 value for interpolation
# input: the float4 fraction representing the interpolation point between value1 and value2
# output: interpolated float4 value

    if { $fraction < 0.0 || $fraction > 1.0 } {
        elog ERROR "Fraction must be between 0.0 and 1.0 inclusive"
    }
    set difference [expr {$value2 - $value1}]
    set result [expr {$value1 + ($difference * $fraction)}]
    elog NOTICE "calculate_linear_interpolation called with value1 = $value1, value2 = $value2, fraction = $fraction"
    elog NOTICE "Result of calculate_linear_interpolation: $result"
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculate_linear_interpolation_mid_range', pltcl_calculate_linear_interpolation(10.75::FLOAT4, 20.5::FLOAT4, 0.5::FLOAT4) = 15.625::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculate_linear_interpolation_near_start', pltcl_calculate_linear_interpolation(-5.0::FLOAT4, 5.0::FLOAT4, 0.1::FLOAT4) = -4.0::FLOAT4;
```

#### pltcl_calculate_log_base_n❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_log_base_n(number FLOAT4, base FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_log_base_n
# description: Calculates the logarithm of a float4 number with a float4 custom base and returns the result as float4. Rejects a base that is less than or equal to 0, or equal to 1, and a number that is less than or equal to 0.
# type: float4
# input: Value to find the logarithm of. Must be greater than 0.
# input: Base of the logarithm. Must be greater than 0 and not equal to 1.
# output: Logarithm of the number to the base provided. If the base or number is invalid, the output is 'undefined'.

    # Check if the base and number are valid
    if { $base <= 0 || $base == 1 } {
        elog NOTICE "Invalid base: base must be greater than 0 and not equal to 1"
        return "undefined"
    }
    if { $number <= 0 } {
        elog NOTICE "Invalid number: number must be greater than 0"
        return "undefined"
    }
    
    # Calculate the logarithm
    set result [expr {log($number) / log($base)}]
    elog NOTICE "calculate_log_base_n function called with number = $number, base = $base"
    elog NOTICE "Result of calculate_log_base_n: $result"
    
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculate_log_base_n_valid_base', pltcl_calculate_log_base_n(32.0::FLOAT4, 2.0::FLOAT4)::FLOAT4 = 5.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculate_log_base_n_invalid_base', pltcl_calculate_log_base_n(100.0::FLOAT4, 1.0::FLOAT4)::TEXT = 'undefined';
```

#### pltcl_calculate_logarithm❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_logarithm(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_logarithm
# description: Calculates the natural logarithm (base e) of a given float4 number and returns the result as float4. If the input is less than or equal to zero, the function will return 'undefined' since the logarithm for non-positive numbers is not defined in real numbers.
# type: float4
# input: The float4 number for which to find the natural logarithm
# output: The natural logarithm of the given float4 number as float4, or 'undefined' if the input is not a positive float4

    if { $number <= 0 } {
        elog NOTICE "calculate_logarithm function called with non-positive number = $number"
        return "undefined"
    } else {
        set result [expr {log($number)}]
        elog NOTICE "calculate_logarithm function called with number = $number"
        elog NOTICE "Result of calculate_logarithm: $result"
        return $result
    }
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculate_logarithm1', pltcl_calculate_logarithm(2.7183::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculate_logarithm2', pltcl_calculate_logarithm(-1.0::FLOAT4) = 'undefined';
```

#### pltcl_calculate_logarithm_base_ten❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_logarithm_base_ten(number FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_logarithm_base_ten
# description: Calculates the logarithm base 10 of a float4 number and returns the result as float4. It assumes positive non-zero input.
# type: float4
# input: The float4 number to calculate the logarithm base 10 of
# output: The float4 result of the logarithm base 10 calculation

    if { $number <= 0 } {
        elog WARNING "calculate_logarithm_base_ten function called with non-positive number = $number"
        set result "undefined"
    } else {
        set result [expr log10($number)]
        elog NOTICE "calculate_logarithm_base_ten function called with number = $number"
        elog NOTICE "Result of calculate_logarithm_base_ten: $result"
    }
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateLogarithmBaseTen1', pltcl_calculate_logarithm_base_ten(100.0::FLOAT4) = 2.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateLogarithmBaseTen2', pltcl_calculate_logarithm_base_ten(1000.0::FLOAT4) = 3.0::FLOAT4;
```

#### pltcl_calculate_median_of_two_float4❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_median_of_two_float4(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_median_of_two_float4
# description: Calculates the median of two float4 numbers and returns the result as float4
# type: float4
# input: First float4 input value
# input: Second float4 input value
# output: Median of input1 and input2 as float4

    set median 0
    if { $input1 == $input2 } {
        set median $input1
    } else {
        set median [expr {($input1 + $input2) / 2.0}]
    }
    elog NOTICE "calculate_median_of_two_float4 function called with input1 = $input1, input2 = $input2"
    elog NOTICE "Result of calculate_median_of_two_float4: $median"
    return $median
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculate_median_of_two_float4_identical', pltcl_calculate_median_of_two_float4(10.0::FLOAT4, 10.0::FLOAT4) = 10.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculate_median_of_two_float4_different', pltcl_calculate_median_of_two_float4(10.0::FLOAT4, 20.0::FLOAT4) = 15.0::FLOAT4;

-- find_nearest_multiple_float4
```

#### pltcl_calculate_percentage_difference❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_percentage_difference(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_percentage_difference
# description: Calculates the percentage difference between two float4 values
# type: float4
# input: First float4 value
# input: Second float4 value
# output: Percentage difference as float4

    if { ![info exists value1] || $value1 eq "" } {
        set value1 0.0
    }
    if { ![info exists value2] || $value2 eq "" } {
        set value2 0.0
    }
    
    set absolute_difference [expr {abs($value1 - $value2)}]
    set average_value [expr {($value1 + $value2) / 2.0}]
    set percentage_difference [expr {($absolute_difference / $average_value) * 100.0}]
    
    elog NOTICE "calculate_percentage_difference function called with value1 = $value1, value2 = $value2"
    elog NOTICE "Result of calculate_percentage_difference: $percentage_difference"
    
    return $percentage_difference
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculatePercentageDifference1', pltcl_calculate_percentage_difference(150.0::FLOAT4, 100.0::FLOAT4) = 40.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculatePercentageDifference2', pltcl_calculate_percentage_difference(75.0::FLOAT4, 125.0::FLOAT4) = 50.0::FLOAT4;
```

#### pltcl_calculate_product_of_float4❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_product_of_float4(num1 FLOAT4, num2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_product_of_float4
# description: Calculates the product of two float4 numbers and returns the result as a float4
# type: float4
# input: The first float4 number to be multiplied
# input: The second float4 number to be multiplied
# output: The product of the two float4 inputs as a float4

    # These debug messages will use elog with the level NOTICE to output debug information
    set product [expr {$num1 * $num2}]
    elog NOTICE "calculate_product_of_float4 function called with num1 = $num1, num2 = $num2"
    elog NOTICE "Result of calculate_product_of_float4: $product"
    return $product
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_product_of_float41', pltcl_calculate_product_of_float4(3.14::FLOAT4, 1.59::FLOAT4) = 4.9916::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_product_of_float42', pltcl_calculate_product_of_float4(-5.0::FLOAT4, 2.5::FLOAT4) = -12.5::FLOAT4;
```

#### pltcl_calculate_product_of_float4❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_product_of_float4(num1 FLOAT4, num2 FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_product_of_float4
# description: Calculates the product of two float4 numbers and returns the result as a float4
# type: float4
# input: The first float4 number to be multiplied
# input: The second float4 number to be multiplied
# output: The product of the two float4 inputs as a float4

    # These debug messages will use elog with the level NOTICE to output debug information
    set product [expr {$num1 * $num2}]
    elog NOTICE "calculate_product_of_float4 function called with num1 = $num1, num2 = $num2"
    elog NOTICE "Result of calculate_product_of_float4: $product"
    return $product
$$ LANGUAGE pltcl;
```

#### pltcl_calculate_quadratic_roots❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_quadratic_roots(a FLOAT4, b FLOAT4, c FLOAT4) RETURNS FLOAT4[] AS $$
# name: calculate_quadratic_roots
# description: Calculates the roots of a quadratic equation ax^2 + bx + c = 0 using the quadratic formula and returns them as an array of float4
# type: float4
# input: float4 coefficient for x^2
# input: float4 coefficient for x
# input: float4 constant term
# output: array of float4 containing the two roots

    # Previously check if a is not zero since the quadratic formula requires a non-zero a value
    if { $a == 0 } {
        elog ERROR "The coefficient a must be non-zero."
        return {}
    }

    # Calculate the discriminant
    set discriminant [expr {($b*$b) - (4*$a*$c)}]
    elog NOTICE "calculate_quadratic_roots: discriminant = $discriminant"
    
    # Check if the discriminant is negative
    if {$discriminant < 0} {
        return {}
    }
    
    # Calculate both roots
    set sqrt_discriminant [expr {sqrt($discriminant)}]
    set root1 [expr {(-$b + $sqrt_discriminant) / (2 * $a)}]
    set root2 [expr {(-$b - $sqrt_discriminant) / (2 * $a)}]
    
    # If the discriminant is zero, only one root exists
    if {$discriminant == 0} {
        set roots [list $root1]
    } else {
        set roots [list $root1 $root2]
    }

    elog NOTICE "calculate_quadratic_roots: roots = $roots"

    return $roots
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateQuadraticRootsDistinctRealRoots', pltcl_calculate_quadratic_roots(1::FLOAT4, -5::FLOAT4, 6::FLOAT4) = ARRAY[3::FLOAT4, 2::FLOAT4];
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculateQuadraticRootsSingleRealRoot', pltcl_calculate_quadratic_roots(1::FLOAT4, -4::FLOAT4, 4::FLOAT4) = ARRAY[2::FLOAT4];
```

#### pltcl_calculate_scaled_value❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_scaled_value(value FLOAT4, factor FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_scaled_value
# description: This function takes an input float4 value and scales it by a given float4 factor.
# type: float4
# input: The original float4 value to be scaled
# input: The float4 factor by which to scale the value
# output: The scaled float4 value

    # Ensure input variables exist and are not empty
    if { ![info exists value] || $value eq "" } {
        set value 0.0
    }
    if { ![info exists factor] || $factor eq "" } {
        set factor 1.0
    }
    set scaled_value [expr {$value * $factor}]
    elog NOTICE "calculate_scaled_value function called with value = $value, factor = $factor"
    elog NOTICE "Result of calculate_scaled_value: $scaled_value"
    return $scaled_value
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_scaled_value_scaling_up', pltcl_calculate_scaled_value(1.5::FLOAT4, 2.0::FLOAT4) = 3.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_scaled_value_scaling_down', pltcl_calculate_scaled_value(3.0::FLOAT4, 0.5::FLOAT4) = 1.5::FLOAT4;
```

#### pltcl_calculate_sin❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_sin(angle FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_sin
# description: Calculates the sine of a float4 angle value (in radians) and returns the result as float4
# type: float4
# input: float4 angle in radians for which the sine will be calculated
# output: float4 representing the sine of the input angle

    # Convert degrees to radians if the input is given in degrees
    # Assuming the angle is already in radians as per input specifications
    # Calculate the sine of the angle
    set result [expr {sin($angle)}]
    # Ensure output is float4 by casting it explicitly if necessary
    set cast_result [expr {float($result)}]
    # Debugging - Log the result
    elog NOTICE "calculate_sin function called with angle = $angle"
    elog NOTICE "Result of calculate_sin: $cast_result"
    # Return the sine value
    return $cast_result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculate_sin1', pltcl_calculate_sin(0.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculate_sin2', pltcl_calculate_sin(1.5708::FLOAT4) = 1.0::FLOAT4;
```

#### pltcl_calculate_slope❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_slope(point1 float4[], point2 float4[]) RETURNS float4 AS $$
# name: calculate_slope
# description: Calculates the slope of a line passing through two points in the Cartesian coordinate system
# type: float4
# input: Coordinates (x1, y1) of the first point, type float4 array
# input: Coordinates (x2, y2) of the second point, type float4 array
# output: The slope of the line as float4

    # Verify if point1 and point2 have exactly two elements each
    if {[llength $point1] != 2 || [llength $point2] != 2} {
        elog ERROR "Input arrays must contain exactly two float4 elements each."
    }

    # Extract coordinates from the input arrays
    set x1 [lindex $point1 0]
    set y1 [lindex $point1 1]
    set x2 [lindex $point2 0]
    set y2 [lindex $point2 1]

    # Calculate deltas
    set deltaY [expr { $y2 - $y1 }]
    set deltaX [expr { $x2 - $x1 }]

    elog NOTICE "calculate_slope function called with point1 = ($x1, $y1), point2 = ($x2, $y2)"
    elog NOTICE "DeltaY: $deltaY, DeltaX: $deltaX"

    # Check for vertical line (infinite slope)
    if { $deltaX == 0 } {
        return "undefined"
    }

    # Calculate slope
    set slope [expr { $deltaY / $deltaX }]
    elog NOTICE "Calculated slope: $slope"
    return $slope
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateSlope1', pltcl_calculate_slope(ARRAY[1.0::FLOAT4, 2.0::FLOAT4], ARRAY[3.0::FLOAT4, 3.0::FLOAT4]) = 0.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_calculateSlope2', pltcl_calculate_slope(ARRAY[4.0::FLOAT4, 1.0::FLOAT4], ARRAY[4.0::FLOAT4, 3.0::FLOAT4]) IS NULL;
```

#### pltcl_calculate_thermal_expansion❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_thermal_expansion(original_length FLOAT4, temperature_change FLOAT4, coefficient_of_expansion FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_thermal_expansion
# description: Calculates the linear thermal expansion of a material given its original length, temperature change, and the material's coefficient of linear expansion
# type: float4
# input: the original length of the material before thermal expansion (float4)
# input: the change in temperature that the material undergoes (float4)
# input: the coefficient of linear expansion of the material (float4)
# output: the new length of the material after thermal expansion (float4)

    if { ![info exists original_length] || $original_length eq "" } {
        return -1; # Invalid input for original_length
    }
    if { ![info exists temperature_change] || $temperature_change eq "" } {
        return -1; # Invalid input for temperature_change
    }
    if { ![info exists coefficient_of_expansion] || $coefficient_of_expansion eq "" } {
        return -1; # Invalid input for coefficient_of_expansion
    }
    
    set length_delta [expr { $original_length * $temperature_change * $coefficient_of_expansion }]
    set new_length [expr { $original_length + $length_delta }]
    
    elog NOTICE "calculate_thermal_expansion called with original length = $original_length, temperature change = $temperature_change, coefficient of expansion = $coefficient_of_expansion"
    elog NOTICE "New length after thermal expansion: $new_length"
    
    return $new_length
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_thermal_expansion_small_change', pltcl_calculate_thermal_expansion(10.0::FLOAT4, 0.0005::FLOAT4, 0.000012::FLOAT4) = 10.00006::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_thermal_expansion_large_change', pltcl_calculate_thermal_expansion(5.0::FLOAT4, 0.05::FLOAT4, 0.000015::FLOAT4) = 5.0000375::FLOAT4;
```

#### pltcl_calculate_weight_force❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_calculate_weight_force(mass FLOAT4) RETURNS FLOAT4 AS $$
# name: calculate_weight_force
# description: Calculates the force due to weight of an object using the formula F = m * g, where m is mass in kilograms, and g is acceleration due to gravity at 9.81 m/s^2 (represented as float4)
# type: float4
# input: mass of the object as float4
# output: the weight force as float4

    set acceleration_due_to_gravity 9.81
    set weight_force [expr {$mass * $acceleration_due_to_gravity}]
    elog NOTICE "calculate_weight_force function called with mass = $mass"
    elog NOTICE "Result of calculate_weight_force: $weight_force"
    return $weight_force
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_weight_force1', pltcl_calculate_weight_force(2.0::FLOAT4) = 19.62::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'calculate_weight_force2', pltcl_calculate_weight_force(5.5::FLOAT4) = 53.955::FLOAT4;
```

#### pltcl_check_float4_equality❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_check_float4_equality(input1 FLOAT4, input2 FLOAT4) RETURNS BOOLEAN AS $$
# name: check_float4_equality
# description: Checks whether two float4 values are equal
# type: float4
# input: First float4 value to be compared
# input: Second float4 value to be compared
# output: Boolean result determining if the two float4 values are equal

    if { ![info exists input1] || ![info exists input2] } {
        return "Inputs are not properly defined"
    }
    set result [expr {$input1 == $input2}]
    elog NOTICE "check_float4_equality function called with input1 = $input1, input2 = $input2"
    elog NOTICE "Result of check_float4_equality: [expr {$result ? "true" : "false"}]"
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'check_float4_equality_equal_values', pltcl_check_float4_equality(4.0000::FLOAT4, 4.0000::FLOAT4) = TRUE;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'check_float4_equality_different_values', pltcl_check_float4_equality(4.0000::FLOAT4, -3.9999::FLOAT4) = FALSE;
```

#### pltcl_check_float4_is_positive❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_check_float4_is_positive(number float4) RETURNS float4 AS $$
# name: check_float4_is_positive
# description: Determines if a float4 input is positive
# type: float4
# input: The float4 number to check
# output: A float4 representing a boolean true or false, 1.0 for true and 0.0 for false

    # Debugging output
    elog NOTICE "check_float4_is_positive function called with number = $number"
    if {$number > 0.0} {
        set result 1.0
    } else {
        set result 0.0
    }
    # Debugging to show the result before returning
    elog NOTICE "Result of check_float4_is_positive: $result"
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_checkFloat4IsPositive1', pltcl_check_float4_is_positive(0.1::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_checkFloat4IsPositive2', pltcl_check_float4_is_positive(-0.1::FLOAT4) = 0.0::FLOAT4;
```

#### pltcl_check_float4_within_bounds❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_check_float4_within_bounds(value FLOAT4, lower_bound FLOAT4, upper_bound FLOAT4) RETURNS FLOAT4 AS $$
# name: check_float4_within_bounds
# description: Determines whether a float4 value is between two boundary float4 values (exclusive)
# type: float4
# input: the float4 value to check
# input: the lower float4 boundary
# input: the upper float4 boundary
# output: boolean represented as float4 (1.0 for true, 0.0 for false)

    if { ![info exists value] || ![info exists lower_bound] || ![info exists upper_bound] } {
        elog ERROR "Input value(s) missing. The function requires 'value', 'lower_bound', and 'upper_bound' arguments."
    }

    if { $value > $lower_bound && $value < $upper_bound } {
        elog NOTICE "check_float4_within_bounds function called with value = $value, lower_bound = $lower_bound, upper_bound = $upper_bound"
        elog NOTICE "Result of check_float4_within_bounds: 1.0 (within bounds)"
        return 1.0
    } else {
        elog NOTICE "check_float4_within_bounds function called with value = $value, lower_bound = $lower_bound, upper_bound = $upper_bound"
        elog NOTICE "Result of check_float4_within_bounds: 0.0 (outside bounds)"
        return 0.0
    }
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'check_float4_within_bounds_within', pltcl_check_float4_within_bounds(5.75::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'check_float4_within_bounds_outside', pltcl_check_float4_within_bounds(-3.14::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 0.0::FLOAT4;
```

#### pltcl_check_float4_within_tolerance✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_check_float4_within_tolerance(float4_num1 FLOAT4, float4_num2 FLOAT4, tolerance FLOAT4) RETURNS BOOLEAN AS $$
# name: check_float4_within_tolerance
# description: Checks if two float4 numbers are within a specified tolerance
# type: float4
# input: First float4 number to compare
# input: Second float4 number to compare
# input: The float4 tolerance within which the two numbers are considered equal
# output: Boolean float4 indicating if the numbers are within the tolerance

    # Check inputs
    if { ![info exists float4_num1] || $float4_num1 eq "" } {
        return false
    }
    if { ![info exists float4_num2] || $float4_num2 eq "" } {
        return false
    }
    if { ![info exists tolerance] || $tolerance eq "" } {
        return false
    }

    # Calculate absolute difference
    set abs_diff [expr {abs($float4_num1 - $float4_num2)}]
    
    # Debug message
    elog NOTICE "check_float4_within_tolerance function called with float4_num1 = $float4_num1, float4_num2 = $float4_num2, tolerance = $tolerance"
    elog NOTICE "Absolute difference: $abs_diff"
    
    # Determine if within tolerance
    set within_tolerance [expr {$abs_diff <= $tolerance ? true : false}]
    
    # Return result
    elog NOTICE "Result of check_float4_within_tolerance: $within_tolerance"
    return $within_tolerance
$$ LANGUAGE pltcl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'pltcl-float4', 'check_float4_within_tolerance_case1', pltcl_check_float4_within_tolerance(100.0::FLOAT4, 100.05::FLOAT4, 0.1::FLOAT4) = false;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'pltcl-float4', 'check_float4_within_tolerance_case2', pltcl_check_float4_within_tolerance(200.0::FLOAT4, 200.2::FLOAT4, 0.1::FLOAT4) = false;

-- calculate_percentage_difference
```

#### pltcl_clamp_value❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_clamp_value(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS FLOAT4 AS $$
# name: clamp_value
# description: Clamps a given float4 value between a minimum and maximum float4 range
# type: float4
# input: The float4 value to be clamped
# input: The minimum float4 value in the range
# input: The maximum float4 value in the range
# output: The clamped float4 value

    if { ![info exists value] || $value eq "" } {
        set nonNullableValue 0
    } else {
        set nonNullableValue $value
    }
    if { $nonNullableValue < $min_value } {
        set nonNullableValue $min_value
    } elseif { $nonNullableValue > $max_value } {
        set nonNullableValue $max_value
    }
    elog NOTICE "clamp_value function called with value = $nonNullableValue, min_value = $min_value, max_value = $max_value"
    elog NOTICE "Result of clamp_value: $nonNullableValue"
    return $nonNullableValue
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'clampValueLessThanMin', pltcl_clamp_value(2.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 3.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'clampValueWithinRange', pltcl_clamp_value(4.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 4.5::FLOAT4;
```

#### pltcl_combine_second_third_power❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_combine_second_third_power(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
# name: combine_second_third_power
# description: Combines the second power of the first float4 input with the third power of the second float4 input by adding them together.
# type: float4
# input: The first float4 input for which the second power is calculated
# input: The second float4 input for which the third power is calculated
# output: The result of adding the second power of input1 and the third power of input2, returned as float4

    # Ensure input values are provided
    if { ![info exists input1] || ![info exists input2] } {
        return "error: one or both input values are not provided"
    }

    # Calculate the powers
    set second_power [expr {$input1 * $input1}]
    set third_power [expr {$input2 * $input2 * $input2}]

    # Combine the calculated powers
    set result [expr {$second_power + $third_power}]

    # Debugging output
    elog NOTICE "combine_second_third_power function called with input1 = $input1, input2 = $input2"
    elog NOTICE "Result of combine_second_third_power: $result"

    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'combineSecondThirdPowerPositive', pltcl_combine_second_third_power(4.0::FLOAT4, 2.0::FLOAT4) = 24.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'combineSecondThirdPowerMixed', pltcl_combine_second_third_power(-1.5::FLOAT4, 3.0::FLOAT4) = 26.25::FLOAT4;
```

#### pltcl_compare_float4_values❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_compare_float4_values(value1 float4, value2 float4) RETURNS float4 AS $$
# name: compare_float4_values
# description: Compares two float4 values and determines if the first is greater than the second.
# type: float4
# input: First float4 value for comparison
# input: Second float4 value for comparison
# output: Boolean represented as float4 (1.0 for true, 0.0 for false)

    # Initialize the result with the default value.
    set result 0.0
    # Add debugging information.
    elog NOTICE "compare_float4_values function called with value1 = $value1, value2 = $value2"
    # Check if the first value is greater than the second.
    if { [expr {$value1 > $value2}] } {
        set result 1.0
    }
    # Add debugging information to log the result.
    elog NOTICE "Result of compare_float4_values: $result"
    # Return the result variable.
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_compareFloat4ValuesGreater', pltcl_compare_float4_values(3.5::FLOAT4, 2.7::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_compareFloat4ValuesNotGreater', pltcl_compare_float4_values(1.4::FLOAT4, 1.8::FLOAT4) = 0.0::FLOAT4;
```

#### pltcl_compute_float4_quotient_and_remainder❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_compute_float4_quotient_and_remainder(dividend FLOAT4, divisor FLOAT4) RETURNS JSON AS $$
# name: compute_float4_quotient_and_remainder
# description: Compute the quotient and remainder of the division of two float4 numbers
# type: float4
# input: The float4 number being divided
# input: The float4 number by which the dividend is divided
# output: A JSON object with float4 quotient and remainder

    # Ensure the divisor is not zero
    if { $divisor == 0.0 } {
        return "\"error\": \"Division by zero is not allowed\""
    }

    # Compute the quotient and remainder
    set quotient [expr {$dividend / $divisor}]
    set prod [expr {$quotient * $divisor}]
    set remainder [expr {$dividend - $prod}]

    # Format and return the result as JSON
    set result "{\"quotient\": \"$quotient\", \"remainder\": \"$remainder\"}"

    # Debugging output
    elog NOTICE "compute_float4_quotient_and_remainder function called with dividend = $dividend, divisor = $divisor"
    elog NOTICE "Result of compute_float4_quotient_and_remainder: $result"

    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'computeFloat4QuotientAndRemainder_PositiveByPositive', pltcl_compute_float4_quotient_and_remainder(8.75::FLOAT4, 2.50::FLOAT4)::JSON = '{"quotient": "3.5", "remainder": "1.25"}'::JSON;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'computeFloat4QuotientAndRemainder_NegativeByPositive', pltcl_compute_float4_quotient_and_remainder(-5.5::FLOAT4, 2.2::FLOAT4)::JSON = '{"quotient": "-2.5", "remainder": "-0.9"}'::JSON;
```

#### pltcl_compute_square_root❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_compute_square_root(input_number FLOAT4) RETURNS FLOAT4 AS $$
# name: compute_square_root
# description: Computes the square root of a given float4 input and returns the result as float4
# type: float4
# input: The float4 number to compute the square root of
# output: The float4 square root of the input number

    # Check if the input_number is non-null and non-negative
    if { ![info exists input_number] || $input_number eq "" || $input_number < 0 } {
        elog ERROR "compute_square_root function called with invalid input_number: $input_number"
        return -1; # Not a number, you may choose an appropriate error handling
    } elseif {$input_number == 0.0 } {
        elog NOTICE "compute_square_root function found square root of zero: 0"
        return 0;
    } else {
        # Using the built-in Tcl command for square root calculation.
        set result [expr {sqrt($input_number)}]
        elog NOTICE "compute_square_root function called with input_number = $input_number, computed square root: $result"
        return $result;
    }
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'compute_square_root_case1', pltcl_compute_square_root(16.0::FLOAT4) = 4.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'compute_square_root_case2', pltcl_compute_square_root(0.0::FLOAT4) = 0.0::FLOAT4;
```

#### pltcl_compute_tangent❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_compute_tangent(angle_in_radians FLOAT4) RETURNS FLOAT4 AS $$
# name: compute_tangent
# description: Computes the tangent of a float4 angle value in radians and returns the result as float4
# type: float4
# input: The angle in radians for which to compute the tangent, as a float4
# output: The tangent of the angle as float4

    # Check if the input angle is PI/2 or 3*PI/2 where the tangent is undefined
    set pi [expr {atan(1) * 4}]
    if {abs($angle_in_radians - $pi / 2) < 1.0e-6 || abs($angle_in_radians - 3 * $pi / 2) < 1.0e-6} {
        return "undefined"
    }
    # Calculate the tangent of the input angle
    set result [expr {tan($angle_in_radians)}]
    # Debug output
    elog NOTICE "FUNCTION compute_tangent-1 - Running compute_tangent function with input 'angle_in_radians' = $angle_in_radians."
    elog NOTICE "FUNCTION compute_tangent-2 - Function compute_tangent is returning 'result' = $result."
    # Return the result
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'computeTangentOfZero', pltcl_compute_tangent(0.0::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'computeTangentOfPiOverFour', pltcl_compute_tangent(0.785398163::FLOAT4)::FLOAT4 = 1.0::FLOAT4;
```

#### pltcl_convert_float4_to_negative✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_convert_float4_to_negative(number float4) RETURNS float4 AS $$
# name: convert_float4_to_negative
# description: This function converts a float4 number to its negative equivalent.
# type: float4
# input: float4 number to be negated
# output: The negative equivalent of the input as float4

    if { ![info exists number] || $number eq "" } {
        set number 0.0
    }
    set result [expr {$number < 0.0 ? $number : -$number}]
    elog NOTICE "convert_float4_to_negative function called with number = $number"
    elog NOTICE "Result of convert_float4_to_negative: $result"
    return $result
$$ LANGUAGE pltcl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'convertFloat4ToNegativePositive', pltcl_convert_float4_to_negative(0::FLOAT4) = -0.0;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'convertFloat4ToNegativeNegative', pltcl_convert_float4_to_negative(-2.0::FLOAT4) = -2.0::FLOAT4;

-- test_float4_power
```

#### pltcl_convert_to_radians✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_convert_to_radians(degrees FLOAT4) RETURNS FLOAT4 AS $$
# name: convert_to_radians
# description: Converts an angle in degrees to radians
# type: float4
# input: The angle in degrees to be converted to radians as float4
# output: The angle in radians as float4

    # Define a constant PI
    set pi 3.1415927
    
    # Check if input is valid
    if { ![info exists degrees] || $degrees eq "" } {
        set degrees 0.0
    }
    
    # Perform calculation to convert degrees to radians
    set radians [expr {$degrees * $pi / 180.0}]
    
    # Debug output
    elog NOTICE "convert_to_radians function called with degrees = $degrees"
    elog NOTICE "Result of convert_to_radians: $radians"
    
    # Return the calculated radians
    return $radians
$$ LANGUAGE pltcl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_convertToRadians1', pltcl_convert_to_radians(0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_convertToRadians2', pltcl_convert_to_radians(0::FLOAT4) = 0.0;

-- calculate_float4_inverse_ratio
```

#### pltcl_find_nearest_multiple_float4❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_find_nearest_multiple_float4(number FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
# name: find_nearest_multiple_float4
# description: Finds the nearest multiple of a divisor close to the given float4 number
# type: float4
# input: The original float4 value for which the nearest multiple is to be found
# input: The divisor float4 value whose multiple is to be found nearest to the number
# output: The nearest multiple of the divisor float4 value to the original number as float4

    if { ![info exists number] || $number eq "" } {
        set number 0
    }
    if { ![info exists divisor] || $divisor eq "" } {
        set divisor 1
    }
    set quotient [expr {double($number) / double($divisor)}]
    set rounded_quotient [expr {round(double($quotient))}]
    set nearest_multiple [expr {double($rounded_quotient) * double($divisor)}]
    elog NOTICE "find_nearest_multiple_float4 function called with number = $number, divisor = $divisor"
    elog NOTICE "Result of find_nearest_multiple_float4: $nearest_multiple"
    return $nearest_multiple
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_findNearestMultipleFloat41', pltcl_find_nearest_multiple_float4(14.2::FLOAT4, 5.0::FLOAT4) = 15.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_findNearestMultipleFloat42', pltcl_find_nearest_multiple_float4(7.7::FLOAT4, 3.5::FLOAT4) = 7.0::FLOAT4;
```

#### pltcl_float4_absolute_value_test❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_float4_absolute_value_test(number float4) RETURNS float4 AS $$
# name: float4_absolute_value_test
# description: Function to compute the absolute value of a float4 number
# type: float4
# input: A float4 value representing the number to find the absolute value for
# output: float4 absolute value of the input number

    # Ensure that 'number' has a value, otherwise set it to 0
    if { ![info exists number] || $number eq "" } {
        set number 0
    }
    # Initialize 'abs_value'
    set abs_value 0
    # If 'number' is less than zero, negate it, otherwise keep it the same
    if { $number < 0 } {
        set abs_value [expr {-$number}]
    } else {
        set abs_value $number
    }
    # Output debugging info
    elog NOTICE "float4_absolute_value_test function called with number = $number"
    elog NOTICE "Result of float4_absolute_value_test: $abs_value"
    # Return the absolute value
    return $abs_value
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'float4_absolute_value_test_negative', pltcl_float4_absolute_value_test(-123.45::FLOAT4) = 123.45::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'float4_absolute_value_test_positive', pltcl_float4_absolute_value_test(678.9::FLOAT4) = 678.9::FLOAT4;
```

#### pltcl_float4_min_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_float4_min_value(number1 FLOAT4, number2 FLOAT4) RETURNS FLOAT4 AS $$
# name: float4_min_value
# description: Finds the minimum value between two float4 numbers
# type: float4
# input: First float4 number for comparison
# input: Second float4 number for comparison
# output: Returns the minimum value as float4

    # Check for the existence of input variables and if they are not empty
    if { ![info exists number1] || $number1 eq "" } {
        set number1 0.0
    }
    if { ![info exists number2] || $number2 eq "" } {
        set number2 0.0
    }
    # Initialize min_value with the value of number1
    set min_value $number1
    # Compare and possibly reassign min_value
    if { $number2 < $min_value } {
        set min_value $number2
    }
    elog NOTICE "float4_min_value function called with number1 = $number1, number2 = $number2"
    elog NOTICE "Result of float4_min_value: $min_value"
    return $min_value
$$ LANGUAGE pltcl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'float4_min_value_mixed', pltcl_float4_min_value(-2.0::FLOAT4, 4.75::FLOAT4) = 0.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'float4_min_value_positive', pltcl_float4_min_value(3.5::FLOAT4, 7.25::FLOAT4) = 3.5::FLOAT4;

-- calculate_float4_percentage_change
```

#### pltcl_is_float4_in_decreasing_order✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_is_float4_in_decreasing_order(number1 float4, number2 float4) RETURNS boolean AS $$
# name: is_float4_in_decreasing_order
# description: Determines if the provided float4 numbers are in strictly decreasing order
# type: float4
# input: First number of type float4
# input: Second number of type float4
# output: Result of type boolean, true if number1 > number2, false otherwise

    # Check if input parameters exist
    if { ![info exists number1] || $number1 eq "" } {
        return false
    }
    if { ![info exists number2] || $number2 eq "" } {
        return false
    }

    # Determine if the numbers are in strictly decreasing order
    set result [expr {$number1 > $number2}]

    # Log the function call and result for debugging
    elog NOTICE "is_float4_in_decreasing_order function called with number1 = $number1, number2 = $number2"
    elog NOTICE "Result of is_float4_in_decreasing_order: $result"

    return $result
$$ LANGUAGE pltcl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'is_float4_in_decreasing_order1', NOT pltcl_is_float4_in_decreasing_order(6.5::FLOAT4, 3.24::FLOAT4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'is_float4_in_decreasing_order2', pltcl_is_float4_in_decreasing_order(5.5::FLOAT4, 5.5::FLOAT4) = FALSE;

-- calculate_float4_inverse_square_root
```

#### pltcl_is_float4_in_range❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_is_float4_in_range(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS BOOLEAN AS $$
# name: is_float4_in_range
# description: Determines if a float4 value falls within a specified inclusive range, defined by a minimum and maximum float4 value.
# type: float4
# input: The float4 value to check
# input: The inclusive minimum value of the range as float4
# input: The inclusive maximum value of the range as float4
# output: Returns true if the value is within the range, otherwise false

    if { ![info exists value] || ![info exists min_value] || ![info exists max_value] } {
        return "A required argument is missing or NULL"
    }
    elog NOTICE "is_float4_in_range function called with value = $value, min_value = $min_value, max_value = $max_value"
    if {$value >= $min_value && $value <= $max_value} {
        elog NOTICE "Value is within the range."
        return "true"
    } else {
        elog NOTICE "Value is outside the range."
        return "false"
    }
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'is_float4_in_range_within', pltcl_is_float4_in_range(3.5::FLOAT4, 1.0::FLOAT4, 5.0::FLOAT4) = 'true';
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'is_float4_in_range_outside', pltcl_is_float4_in_range(6.5::FLOAT4, 1.0::FLOAT4, 5.0::FLOAT4) = 'false';
```

#### pltcl_is_float4_zero❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_is_float4_zero(number float4) RETURNS boolean AS $$
# name: is_float4_zero
# description: Checks if the provided float4 number is zero
# type: float4
# input: the input float4 number to check
# output: returns true if number is 0.0, false otherwise

    # A threshold for floating-point precision issues
    set threshold 0.0001
    # Convert the number to its absolute value for comparison
    set abs_number [expr { abs($number) }]
    # Debugging message
    elog NOTICE "is_float4_zero function called with number = $number"
    # Comparison to determine if the number is zero within precision limits
    if { $abs_number <= $threshold } {
        return true
    } else {
        return false
    }
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'is_float4_zero_case_exact_zero', pltcl_is_float4_zero(0.0::FLOAT4) = TRUE;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'is_float4_zero_case_close_to_zero', pltcl_is_float4_zero(0.00001::FLOAT4) = FALSE;
```

#### pltcl_is_negative❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_is_negative(number float4) RETURNS boolean AS $$
# name: is_negative
# description: Determines if a float4 value is negative
# type: float4
# input: the float4 number to check
# output: boolean indicating if the number is negative

    elog NOTICE "is_negative function called with number = $number"
    set result [expr {$number < 0.0 ? 1 : 0}]
    elog NOTICE "Result of is_negative: $result"
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'is_negative_case1', pltcl_is_negative(-3.14::FLOAT4);
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'is_negative_case2', pltcl_is_negative(6.28::FLOAT4) = FALSE;
```

#### pltcl_normalize_float4_value❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_normalize_float4_value(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS FLOAT4 AS $$
# name: normalize_float4_value
# description: Normalize a float4 number to the range of 0 to 1 based on provided minimum and maximum values
# type: float4
# input: the float4 number to normalize
# input: the minimum float4 value of the range
# input: the maximum float4 value of the range
# output: the normalized float4 number

	if { $min_value >= $max_value } {
		return -1; # Error indicator since min_value should be less than max_value
	}
	
	# Subtract min_value from value to get the distance from the minimum
	set distance_from_min [expr {$value - $min_value}]

	# Subtract min_value from max_value to get the range size
	set range_size [expr {$max_value - $min_value}]

	# Divide the distance from minimum by the range size to get the normalized value
	set normalized_value [expr {$distance_from_min / $range_size}]

	elog NOTICE "normalize_float4_value function called with value = $value, min_value = $min_value, max_value = $max_value"
	elog NOTICE "Result of normalize_float4_value: $normalized_value"

	return $normalized_value
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'normalizeFloat4ValueWithinRange', pltcl_normalize_float4_value(10.0::FLOAT4, 0.0::FLOAT4, 20.0::FLOAT4) = 0.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'normalizeFloat4ValueAtTopOfRange', pltcl_normalize_float4_value(20.0::FLOAT4, 10.0::FLOAT4, 20.0::FLOAT4) = 1.0::FLOAT4;
```

#### pltcl_subtract_float4_values❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_subtract_float4_values(value1 float4, value2 float4) RETURNS float4 AS $$
# name: subtract_float4_values
# description: Subtracts the second float4 value from the first and returns the result as float4
# type: float4
# input: First float4 value to be used in subtraction
# input: Second float4 value to subtract from the first value
# output: Result of subtraction as float4

    if { ![info exists value1] || $value1 eq "" } {
        set value1 0.0
    }
    if { ![info exists value2] || $value2 eq "" } {
        set value2 0.0
    }
    set result [expr $value1 - $value2]
    elog NOTICE "subtract_float4_values function called with value1 = $value1, value2 = $value2"
    elog NOTICE "Result of subtract_float4_values: $result"
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'subtractFloat4ValuesPositive', pltcl_subtract_float4_values(5.7::FLOAT4, 2.3::FLOAT4) = 3.4::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'subtractFloat4ValuesNegByPos', pltcl_subtract_float4_values(-1.2::FLOAT4, 4.6::FLOAT4) = -5.8::FLOAT4;
```

#### pltcl_test_cosine_float4❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_test_cosine_float4(angle FLOAT4) RETURNS FLOAT4 AS $$
# name: test_cosine_float4
# description: Calculates the cosine of a float4 angle value in radians and returns the result as float4
# type: float4
# input: Angle in radians for which the cosine has to be calculated (float4)
# output: The cosine of the provided angle (float4)

    if { ![info exists angle] || $angle eq "" } {
        elog ERROR "Input angle is not provided or is not a valid float4."
    }

    # Assuming radians are passed correctly as per requirement.
    set cosine_result [expr {cos($angle)}]
    elog NOTICE "test_cosine_float4 function called with angle = $angle"
    elog NOTICE "Result of test_cosine_float4: $cosine_result"

    return $cosine_result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_cosine_float4_zero_radians', pltcl_test_cosine_float4(0.0::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_cosine_float4_PI_over_2_radians', pltcl_test_cosine_float4(1.5707963::FLOAT4) = 0.0::FLOAT4;
```

#### pltcl_test_float4_power❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_test_float4_power(base FLOAT4, exponent FLOAT4) RETURNS FLOAT4 AS $$
# name: test_float4_power
# description: Raises a float4 base number to the power of a float4 exponent
# type: float4
# input: float4 base number
# input: float4 exponent value
# output: float4 result of raising base to the power of exponent

    if { ![info exists base] || $base eq "" } {
        set base 0.0
    }
    if { ![info exists exponent] || $exponent eq "" } {
        set exponent 0.0
    }
    elog NOTICE "test_float4_power function called with base = $base, exponent = $exponent"
    if {$exponent == 0.0} {
        set result 1.0
    } elseif {$base == 0.0} {
        set result 0.0
    } else {
        set result [expr {double($base) ** double($exponent)}]
    }
    elog NOTICE "Result of test_float4_power: $result"
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_float4_power_non_zero_base_positive_exponent', pltcl_test_float4_power(2.0::FLOAT4, 3.0::FLOAT4) = 8.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_float4_power_non_zero_base_non_integer_exponent', pltcl_test_float4_power(9.0::FLOAT4, 0.5::FLOAT4) = 3.0::FLOAT4;
```

#### pltcl_test_float4_rounding❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_test_float4_rounding(original_value FLOAT4) RETURNS FLOAT4 AS $$
# name: test_float4_rounding
# description: This function rounds a float4 value to the nearest whole number and returns it as float4.
# type: float4
# input: A float4 value to be rounded to the nearest whole number
# output: Rounded float4 value to the nearest whole number

    if { ![info exists original_value] || $original_value eq "" } {
        elog ERROR "test_float4_rounding function called with invalid input"
    }
    set rounded_value [expr {round($original_value)}]
    elog NOTICE "test_float4_rounding function called with original_value = $original_value"
    elog NOTICE "Rounded value: $rounded_value"
    return $rounded_value
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_float4_rounding_positive', pltcl_test_float4_rounding(2.5::FLOAT4) = 3.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_float4_rounding_negative', pltcl_test_float4_rounding(-3.7::FLOAT4) = -4.0::FLOAT4;
```

#### pltcl_test_float4_truncation❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_test_float4_truncation(number FLOAT4) RETURNS FLOAT4 AS $$
# name: test_float4_truncation
# description: Truncates a float4 number, removing its decimal part.
# type: float4
# input: A float4 number to be truncated
# output: The truncated float4 number

    elog NOTICE "test_float4_truncation function called with number = $number"
    # Tcl does not have a native truncate function, so we cast to int and back to float to remove decimals
    set result [expr {float([expr {int($number)}])}]
    elog NOTICE "Result of test_float4_truncation: $result"
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_float4_truncation_positive', pltcl_test_float4_truncation(123.456::FLOAT4) = 123.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_float4_truncation_negative', pltcl_test_float4_truncation(-123.456::FLOAT4) = -123.0::FLOAT4;
```

#### pltcl_test_maximum_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_test_maximum_value(input1 float4, input2 float4) RETURNS float4 AS $$
# name: test_maximum_value
# description: Function to determine the maximum of two float4 values
# type: float4
# input: First float4 value to compare
# input: Second float4 value to compare
# output: Returns the maximum of the two float4 inputs

    if { ![info exists input1] || $input1 eq "" } {
        set input1 0
    }
    if { ![info exists input2] || $input2 eq "" } {
        set input2 0
    }
    if {$input1 >= $input2} {
        set result $input1
    } else {
        set result $input2
    }
    elog NOTICE "test_maximum_value function called with input1 = $input1, input2 = $input2"
    elog NOTICE "Result of test_maximum_value: $result"
    return $result
$$ LANGUAGE pltcl;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_maximum_value_second_greater', pltcl_test_maximum_value(NULL, NULL) = 0;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'test_maximum_value_first_greater', pltcl_test_maximum_value(12.34::FLOAT4, 9.87::FLOAT4) = 12.34::FLOAT4;

-- calculate_float4_division
```

#### pltcl_validate_even_float4❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_validate_even_float4(value FLOAT4) RETURNS BOOLEAN AS $$
# name: validate_even_float4
# description: Determines whether a float4 number represents an even number
# type: float4
# input: The float4 number to check
# output: Returns true if the number is even, otherwise false

    # Ensure that value is not null or missing
    if { ![info exists value] || $value eq "" } {
        set value 0.0
    }
    # Convert value to the nearest smaller whole number
    set int_value [expr {floor($value)}]
    # Perform a modulo operation with 2
    set result [expr {$int_value % 2 == 0}]
    # Debugging messages
    elog NOTICE "validate_even_float4 function called with value = $value"
    elog NOTICE "Converted integer value: $int_value"
    elog NOTICE "Result of validate_even_float4: $result"
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'validate_even_float4_EvenWholeNumber', pltcl_validate_even_float4(4.0::FLOAT4) = TRUE;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'validate_even_float4_OddWholeNumber', pltcl_validate_even_float4(5.0::FLOAT4) = FALSE;
```

#### pltcl_validate_float4_within_range❌
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION pltcl_validate_float4_within_range(number float4, range_min float4, range_max float4) RETURNS float4 AS $$
# name: validate_float4_within_range
# description: validate whether the float4 number falls within the exclusive range (min, max)
# type: float4
# input: the float4 number to validate
# input: the minimum float4 boundary of the range
# input: the maximum float4 boundary of the range
# output: boolean represented as float4 (1.0 for true, 0.0 for false)

    # Debugging: log inputs
    elog NOTICE "validate_float4_within_range function called with number = $number, range_min = $range_min, range_max = $range_max"

    # Check if the number is greater than range_min and less than range_max
    if { $number > $range_min && $number < $range_max } {
        set result 1.0
    } else {
        set result 0.0
    }

    # Debugging: log result
    elog NOTICE "Result of validate_float4_within_range: $result"
    return $result
$$ LANGUAGE pltcl;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'validateFloat4WithinRange_NumberWithinExclusiveRange', pltcl_validate_float4_within_range(5.5::FLOAT4, 5.0::FLOAT4, 6.0::FLOAT4) = 1.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'pltcl-float4', 'validateFloat4WithinRange_NumberOutsideExclusiveRange', pltcl_validate_float4_within_range(4.0::FLOAT4, 5.0::FLOAT4, 6.0::FLOAT4) = 0.0::FLOAT4;
```

### plv8

#### plv8_add_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_add_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
// name: add_float4_values
// description: Function that adds two float4 values and returns the result as float4
// type: float4
// input: float4 value to be added to value2
// input: float4 value to be added to value1
// output: Sum of value1 and value2 as float4

    plv8.elog(NOTICE, 'DEBUG: FUNCTION plv8_add_float4_values - Running with inputs value1 = ' + value1 + ', value2 = ' + value2);
    var sum = value1 + value2;
    plv8.elog(NOTICE, 'DEBUG: FUNCTION plv8_add_float4_values - Function is returning sum = ' + sum);
    return sum;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'addFloat4ValuesPositive', plv8_add_float4_values(1.5::FLOAT4, 2.5::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'addFloat4ValuesPosNeg', plv8_add_float4_values(-1.25::FLOAT4, 3.75::FLOAT4) = 2.5::FLOAT4;
```

#### plv8_average_of_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_average_of_float4_values(value1 float4, value2 float4) RETURNS float4 AS $$
// name: average_of_float4_values
// description: Calculates the average of two float4 values
// type: float4
// input: First float4 value
// input: Second float4 value
// output: The average value as float4

    var sum = value1 + value2;
    var average = sum / 2;
    plv8.elog(NOTICE, "average_of_float4_values function called with value1 = " + value1 + ", value2 = " + value2);
    plv8.elog(NOTICE, "Result of average_of_float4_values: " + average);
    return average;
$$ LANGUAGE plv8;
-- Test case: Average of two float4 positive numbers
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'averageOfFloat4ValuesPositive', plv8_average_of_float4_values(4.0::FLOAT4, 8.0::FLOAT4) = 6.0::FLOAT4;
-- Test case: Average of two float4 negative numbers
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'averageOfFloat4ValuesNegative', plv8_average_of_float4_values(-2.5::FLOAT4, -7.5::FLOAT4) = -5.0::FLOAT4;
```

#### plv8_calculate_arccosine✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_arccosine(value FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_arccosine
// description: Calculates the arccosine (inverse cosine) of a float4 value
// type: float4
// input: A float4 representing the cosine of an angle, range -1 to 1
// output: The arccosine of the input value as float4 in radians

    if (value < -1 || value > 1) {
        throw 'Input value out of range: must be between -1 and 1 inclusive';
    }
    
    var result = Math.acos(value);
    
    // Since we're returning FLOAT4, cast result to float with single precision
    result = parseFloat(result.toFixed(7));
    
    plv8.elog(NOTICE, "calculate_arccosine function called with value = " + value);
    plv8.elog(NOTICE, "Result of calculate_arccosine: " + result);
    
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateArccosineOf0', plv8_calculate_arccosine(0::FLOAT4) BETWEEN 1.5707::FLOAT4 AND 1.5709::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateArccosineOf1', plv8_calculate_arccosine(1::FLOAT4) BETWEEN -0.0001::FLOAT4 AND 0.0001::FLOAT4;
```

#### plv8_calculate_area_of_rectangle✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_area_of_rectangle(width FLOAT4, height FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_area_of_rectangle
// description: This function calculates the area of a rectangle given the width and height as float4 types and returns the area as float4
// type: float4
// input: float4 type representing the width of the rectangle
// input: float4 type representing the height of the rectangle
// output: float4 type representing the area of the rectangle

    plv8.elog(NOTICE, "calculate_area_of_rectangle function called with width = " + width + ", height = " + height);
    var area = width * height;
    plv8.elog(NOTICE, "Result of calculate_area_of_rectangle: " + area);
    return area;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculateAreaOfRectanglePositiveDimensions', plv8_calculate_area_of_rectangle(4.0::FLOAT4, 3.0::FLOAT4) = 12.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculateAreaOfRectangleZeroDimension', plv8_calculate_area_of_rectangle(0.0::FLOAT4, 5.0::FLOAT4) = 0.0::FLOAT4;
```

#### plv8_calculate_arithmetic_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_arithmetic_mean(value1 float4, value2 float4) RETURNS float4 AS $$
// name: calculate_arithmetic_mean
// description: Calculates arithmetic mean of two float4 values
// type: float4
// input: First float4 input value.
// input: Second float4 input value.
// output: Arithmetic mean result as float4.

    var total = value1 + value2;
    var count = 2;
    var result = total / count;
    plv8.elog(NOTICE, "calculate_arithmetic_mean function called with value1 = " + value1 + ", value2 = " + value2);
    plv8.elog(NOTICE, "Result of calculate_arithmetic_mean: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateArithmeticMeanPositives', plv8_calculate_arithmetic_mean(3.5::float4, 2.5::float4) = 3.0::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateArithmeticMeanPosNeg', plv8_calculate_arithmetic_mean(5.0::float4, -3.0::float4) = 1.0::float4;
```

#### plv8_calculate_arithmetic_progression_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_arithmetic_progression_sum(a FLOAT4, d FLOAT4, n FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_arithmetic_progression_sum
// description: Calculate the sum of the first n terms of an arithmetic progression, given the first term (a), the common difference (d), and the number of terms (n), returning the sum as float4.
// type: float4
// input: the first term of the arithmetic progression (float4)
// input: the common difference between the terms (float4)
// input: the number of terms to sum (float4)
// output: the sum of the first n terms of the arithmetic progression (float4)

    var sn;
    // Validate input values to make sure they are numbers
    if (typeof a !== 'number' || typeof d !== 'number' || typeof n !== 'number') {
        throw 'Invalid input: inputs must be numbers';
    }
    
    // Begin debug log
    plv8.elog(NOTICE, "DEBUG: FUNCTION calculate_arithmetic_progression_sum-1 - Running calculate_arithmetic_progression_sum function with inputs 'a' = " + a + ", 'd' = " + d + ", 'n' = " + n);

    // Arithmetic progression sum calculation
    sn = (n * (2 * a + (n - 1) * d)) / 2;

    // End debug log and return result
    plv8.elog(NOTICE, "DEBUG: FUNCTION calculate_arithmetic_progression_sum-2 - Function calculate_arithmetic_progression_sum is returning 'sn' = " + sn);
    return sn;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateArithmeticProgressionSum1', plv8_calculate_arithmetic_progression_sum(2.0::FLOAT4, 2.0::FLOAT4, 5.0::FLOAT4) = 30.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateArithmeticProgressionSum2', plv8_calculate_arithmetic_progression_sum(1.5::FLOAT4, 1.5::FLOAT4, 3.0::FLOAT4) = 9.0::FLOAT4;
```

#### plv8_calculate_ceil✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_ceil(number FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_ceil
// description: This function calculates and returns the smallest integer greater than or equal to the given float4 number.
// type: float4
// input: A float4 number to calculate the ceiling value for
// output: The ceiling value of the input as float4

    var ceil_value = Math.ceil(number);
    plv8.elog(NOTICE, "calculate_ceil function called with number = " + number);
    plv8.elog(NOTICE, "Result of calculate_ceil: " + ceil_value);
    return ceil_value;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateCeilPositive', plv8_calculate_ceil(3.45::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateCeilNegative', plv8_calculate_ceil(-1.78::FLOAT4) = -1.0::FLOAT4;
```

#### plv8_calculate_circumference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_circumference(radius FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_circumference
// description: Calculates the circumference of a circle given the radius as float4
// type: float4
// input: The radius of the circle as float4
// output: The circumference of the circle as float4

    const PI = 3.1415926535;
    let diameter = radius * 2;
    let circumference = diameter * PI;
    plv8.elog(NOTICE, "calculate_circumference function called with radius = " + radius);
    plv8.elog(NOTICE, "Result of calculate_circumference: " + circumference);
    return circumference;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateCircumferenceSmall', round(plv8_calculate_circumference(2.0::FLOAT4)::numeric, 11) = round(12.566370614::FLOAT4::numeric, 11);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateCircumferenceLarge', round(plv8_calculate_circumference(100.0::FLOAT4)::numeric, 11) = round(628.3185307179584::FLOAT4::numeric, 11);
```

#### plv8_calculate_decibel_level✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_decibel_level(sound_pressure FLOAT4, reference_pressure FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_decibel_level
// description: Calculates the decibel level of a sound by comparing it to a reference sound pressure level.
// type: float4
// input: The sound pressure of the sound for which to determine the decibel level, as float4.
// input: The reference sound pressure which is typically the threshold of human hearing, as float4.
// output: The decibel level of the sound compared to the reference sound pressure, as float4.

    if (sound_pressure <= 0 || reference_pressure <= 0) {
        throw 'sound_pressure and reference_pressure must be positive numbers';
    }
    
    const ratio = sound_pressure / reference_pressure;
    const decibel_level = 20 * Math.log10(ratio);
    
    plv8.elog(NOTICE, "calculate_decibel_level function called with sound_pressure = " + sound_pressure + ", reference_pressure = " + reference_pressure);
    plv8.elog(NOTICE, "Result of calculate_decibel_level: " + decibel_level);
    
    return decibel_level;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plv8-float4', 'test_calculateDecibelLevelNormal', ROUND(plv8_calculate_decibel_level(1.0::FLOAT4, 0.00002::FLOAT4)) = 94::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plv8-float4', 'test_calculateDecibelLevelThreshold', plv8_calculate_decibel_level(0.00002::FLOAT4, 0.00002::FLOAT4) = 0.0::FLOAT4;
```

#### plv8_calculate_distance_between_float4_points✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_distance_between_float4_points(x1 float4, y1 float4, x2 float4, y2 float4) RETURNS float4 AS $$
// name: calculate_distance_between_float4_points
// description: Calculates the distance between two points in 2D space using float4 for coordinates
// type: float4
// input: The x-coordinate of the first point as a float4
// input: The y-coordinate of the first point as a float4
// input: The x-coordinate of the second point as a float4
// input: The y-coordinate of the second point as a float4
// output: The distance between the two points as a float4

    var delta_x = x2 - x1;
    var delta_y = y2 - y1;
    var square_delta_x = Math.pow(delta_x, 2);
    var square_delta_y = Math.pow(delta_y, 2);
    var sum_of_squares = square_delta_x + square_delta_y;
    var distance = Math.sqrt(sum_of_squares);

    // Debugging output
    plv8.elog(NOTICE, "calculate_distance_between_float4_points function called with x1 = " + x1 + ", y1 = " + y1 + ", x2 = " + x2 + ", y2 = " + y2);
    plv8.elog(NOTICE, "Result of calculate_distance_between_float4_points: " + distance);

    return distance;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_distance_between_float4_points_same_points', plv8_calculate_distance_between_float4_points(0.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_distance_between_float4_points_different_points', plv8_calculate_distance_between_float4_points(3.0::FLOAT4, 4.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4) = 5.0::FLOAT4;
```

#### plv8_calculate_euclidean_distance✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_euclidean_distance(point1 JSON, point2 JSON) RETURNS FLOAT4 AS $$
// name: calculate_euclidean_distance
// description: Calculates the Euclidean distance between two points in 3D space.
// type: float4
// input: First point as an object with float4 x, y, z coordinates
// input: Second point as an object with float4 x, y, z coordinates
// output: The Euclidean distance between the two points as float4

    var x1 = point1.x, y1 = point1.y, z1 = point1.z;
    var x2 = point2.x, y2 = point2.y, z2 = point2.z;

    var dx = x1 - x2;
    var dy = y1 - y2;
    var dz = z1 - z2;

    var squaredDifferenceSum = dx*dx + dy*dy + dz*dz;
    var distance = Math.sqrt(squaredDifferenceSum);
    
    plv8.elog(NOTICE, "calculate_euclidean_distance function called with point1 = " + JSON.stringify(point1) + ", point2 = " + JSON.stringify(point2));
    plv8.elog(NOTICE, "Result of calculate_euclidean_distance: " + distance);
    
    return distance;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateEuclideanDistanceDiffPositions', ROUND(plv8_calculate_euclidean_distance('{"x": 1.0, "y": 2.0, "z": 3.0}', '{"x": 4.0, "y": 5.0, "z": 6.0}')::NUMERIC, 4) = ROUND(5.1962::NUMERIC, 4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateEuclideanDistanceSamePositions', plv8_calculate_euclidean_distance('{"x": 7.0, "y": 8.0, "z": 9.0}', '{"x": 7.0, "y": 8.0, "z": 9.0}') = 0.0::FLOAT4;
```

#### plv8_calculate_exponential_growth✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_exponential_growth(initial_value float, growth_rate float, time_period float) RETURNS float AS $$
// name: calculate_exponential_growth
// description: This function calculates the exponential growth based on initial value, growth rate, and time.
// type: float4
// input: Initial quantity as float4
// input: Growth rate (in percentage) as float4
// input: Time period over which to calculate as float4
// output: Returns the amount after growth as float4

    plv8.elog(NOTICE, "DEBUG: FUNCTION plv8_calculate_exponential_growth - Running calculate_exponential_growth function with inputs 'initial_value' = " + initial_value + ", 'growth_rate' = " + growth_rate + ", 'time_period' = " + time_period + ".");
    // Convert the growth rate percentage to a decimal
    var decimal_growth_rate = growth_rate / 100.0;
    // Calculate the growth factor
    var growth_factor = 1.0 + decimal_growth_rate;
    // Raise the growth factor to the power of the time period
    var powered_growth_factor = Math.pow(growth_factor, time_period);
    // Multiply the initial quantity to get the final amount
    var final_amount = initial_value * powered_growth_factor;
    // Round to nearest float4 precision and return
    var rounded_final_amount = parseFloat(final_amount.toFixed(6));
    plv8.elog(NOTICE, "DEBUG: FUNCTION plv8_calculate_exponential_growth - Function calculate_exponential_growth is returning 'rounded_final_amount' = " + rounded_final_amount + ".");
    
    return rounded_final_amount;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculateExponentialGrowth5Years', plv8_calculate_exponential_growth(1000.0::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 1159.274074;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculateExponentialGrowth10Years', plv8_calculate_exponential_growth(100.0::FLOAT4, 5.0::FLOAT4, 10.0::FLOAT4) = 162.889::FLOAT4;
```

#### plv8_calculate_float4_as_percentage_of_another✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_as_percentage_of_another(value FLOAT4, total FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_as_percentage_of_another
// description: Calculates one float4 value as a percentage of another float4 value.
// type: float4
// input: The float4 number to calculate the percentage for
// input: The float4 number representing the total or 100%
// output: The percentage of 'value' relative to 'total' as float4

    if (total === 0) {
        throw 'Total cannot be zero.';
    }
    var percentage = (value / total) * 100;
    plv8.elog(NOTICE, "calculate_float4_as_percentage_of_another function called with value = " + value + ", total = " + total);
    plv8.elog(NOTICE, "Result of calculate_float4_as_percentage_of_another: " + percentage);
    return percentage;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4AsPercentageOfAnother1', plv8_calculate_float4_as_percentage_of_another(25.0::FLOAT4, 50.0::FLOAT4) = 50.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4AsPercentageOfAnother2', plv8_calculate_float4_as_percentage_of_another(1.0::FLOAT4, 200.0::FLOAT4) = 0.5::FLOAT4;
```

#### plv8_calculate_float4_ceil✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_ceil(value FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_ceil
// description: Function to calculate the smallest integer greater than or equal to the given float4 number
// type: float4
// input: float4 value to find the ceiling value for
// output: float4 representing the smallest integer greater than or equal to the input

    var ceiling_value = Math.ceil(value);
    plv8.elog(NOTICE, "calculate_float4_ceil function called with value = " + value);
    plv8.elog(NOTICE, "Result of calculate_float4_ceil: " + ceiling_value);
    return ceiling_value;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4CeilPositive', plv8_calculate_float4_ceil(3.45::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4CeilNegative', plv8_calculate_float4_ceil(-2.8::FLOAT4) = -2.0::FLOAT4;
```

#### plv8_calculate_float4_complement✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_complement(number float4) RETURNS float4 AS $$
// name: calculate_float4_complement
// description: Calculates the complement of a float4 number with respect to 1, that is, it calculates 1 - n for a given float4 n.
// type: float4
// input: A float4 number which is the value to find the complement of.
// output: The complement of the input float4 number with respect to 1 as float4.

    plv8.elog(NOTICE, "calculate_float4_complement function called with number = " + number);
    
    // Ensure the input number is a float4 type
    if (typeof number !== 'number' || !isFinite(number)) {
        throw new Error('Input must be a finite float4 type');
    }

    // Subtract the input number from 1
    var result = 1.0 - number;

    // Return the result as a float4 type
    plv8.elog(NOTICE, "Result of calculate_float4_complement: " + result);
    
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT)
SELECT 'plv8-float4', 'test_calculateFloat4ComplementLessThanOne', 
       plv8_calculate_float4_complement(0.25::float4) = 0.75::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT)
SELECT 'plv8-float4', 'test_calculateFloat4ComplementGreaterThanOne', 
       plv8_calculate_float4_complement(1.25::float4) = -0.25::float4;
```

#### plv8_calculate_float4_division✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_division(dividend FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_division
// description: This function takes two float4 values and divides the first by the second, returning a float4.
// type: float4
// input: The float4 number to be divided
// input: The float4 number to divide by
// output: The result of the division as a float4

    plv8.elog(NOTICE, 'calculate_float4_division called with dividend = ' + dividend + ', divisor = ' + divisor);
    if (divisor === 0) {
        throw 'Division by zero is not allowed.';
    }
    var result = dividend / divisor;
    plv8.elog(NOTICE, 'Result of calculate_float4_division: ' + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_float4_division_larger_by_smaller', plv8_calculate_float4_division(10.5::FLOAT4, 2.5::FLOAT4) = 4.2::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_float4_division_smaller_by_larger', plv8_calculate_float4_division(3.3::FLOAT4, 4.4::FLOAT4) = 0.75::FLOAT4;
```

#### plv8_calculate_float4_dot_product✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_dot_product(vector1_x FLOAT4, vector1_y FLOAT4, vector2_x FLOAT4, vector2_y FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_dot_product
// description: Calculates the dot product of two 2D vectors, each vector component is a float4 type
// type: float4
// input: x component of the first vector (float4)
// input: y component of the first vector (float4)
// input: x component of the second vector (float4)
// input: y component of the second vector (float4)
// output: dot product of the two vectors (float4)

  plv8.elog(NOTICE, "calculate_float4_dot_product function called with vector1_x = " + vector1_x + ", vector1_y = " + vector1_y + ", vector2_x = " + vector2_x + ", vector2_y = " + vector2_y);
  var dot_product = (vector1_x * vector2_x) + (vector1_y * vector2_y);
  plv8.elog(NOTICE, "Result of calculate_float4_dot_product: " + dot_product);
  return dot_product;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_float4_dot_product_perpendicular', plv8_calculate_float4_dot_product(1.0::FLOAT4, 0.0::FLOAT4, 0.0::FLOAT4, 1.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_float4_dot_product_parallel', plv8_calculate_float4_dot_product(1.0::FLOAT4, 1.0::FLOAT4, 2.0::FLOAT4, 2.0::FLOAT4) = 4.0::FLOAT4;
```

#### plv8_calculate_float4_exponential_decay❌
  

[Back to result table](#result-table)

```sql
-- CREATE OR REPLACE FUNCTION plv8_calculate_float4_exponential_decay(initial_value FLOAT4, decay_rate FLOAT4, time FLOAT4) RETURNS FLOAT4 AS $$
-- // name: calculate_float4_exponential_decay
-- // description: Calculates the exponential decay based on initial value, decay rate, and time.
-- // type: float4
-- // input: Initial value of the quantity at time t0, as float4
-- // input: Decay rate, must be non-negative, as float4
-- // input: Time that has passed, as float4
-- // output: The quantity remaining after decay over the given time, as float4

--     if (decay_rate < 0) {
--         throw new Error('Decay rate must be non-negative');
--     }
--     var remaining_quantity = initial_value * Math.exp(-decay_rate * time);
--     plv8.elog(NOTICE, "calculate_float4_exponential_decay function called with initial_value = " + initial_value + ", decay_rate = " + decay_rate + ", time = " + time);
--     plv8.elog(NOTICE, "Result of calculate_float4_exponential_decay: " + remaining_quantity);
--     return remaining_quantity;
-- $$ LANGUAGE plv8;
-- 2024-02-17 00:41:22.034 +00:00 [DBG] Tests:
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4ExponentialDecay1', plv8_calculate_float4_exponential_decay(100.0::FLOAT4, 0.5::FLOAT4, 10.0::FLOAT4) = 6.73795::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4ExponentialDecay2', plv8_calculate_float4_exponential_decay(50.0::FLOAT4, 0.0::FLOAT4, 5.0::FLOAT4) = 50.0::FLOAT4;
```

#### plv8_calculate_float4_exponentiation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_exponentiation(base FLOAT4, exponent FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_exponentiation
// description: Calculates the base raised to the power of exponent, both of float4 type, and returns float4
// type: float4
// input: float4 number to be raised to the power of the exponent
// input: float4 number representing the power
// output: float4 result of the exponentiation

    plv8.elog(NOTICE, "calculate_float4_exponentiation function called with base = " + base + ", exponent = " + exponent);
    if (exponent === 0) return 1;
    if (base === 0) return 0;
    var result = Math.pow(base, exponent);
    plv8.elog(NOTICE, "Result of calculate_float4_exponentiation: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4ExponentiationPositiveBaseExponent', plv8_calculate_float4_exponentiation(2.5::FLOAT4, 3.0::FLOAT4) = 15.625::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4ExponentiationNegativeBasePositiveExponent', plv8_calculate_float4_exponentiation(-3.0::FLOAT4, 2.0::FLOAT4) = 9.0::FLOAT4;
```

#### plv8_calculate_float4_exponentiation_remainder✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_exponentiation_remainder(base FLOAT4, exponent INTEGER, divisor FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_exponentiation_remainder
// description: Calculates the remainder of the exponentiation of a float4 base raised to an integer exponent when divided by a float4 divisor.
// type: float4
// input: the base value as float4
// input: the exponent value as integer
// input: the divisor value as float4
// output: the remainder as float4

    var result;
    if (exponent < 0) {
        exponent = 0;
    }
    var exponentAsFloat4 = parseFloat(base);
    var expResult = Math.pow(exponentAsFloat4, exponent);
    result = expResult % divisor;
    
    plv8.elog(NOTICE, "calculate_float4_exponentiation_remainder function called with base = " + base + ", exponent = " + exponent + ", divisor = " + divisor);
    plv8.elog(NOTICE, "Exponentiation result: " + expResult + ", Remainder: " + result);

    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_float4_exponentiation_remainder1', ROUND(plv8_calculate_float4_exponentiation_remainder(2.5::FLOAT4, 3, 3.2::FLOAT4)::NUMERIC, 3) = 2.825::NUMERIC;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_float4_exponentiation_remainder2', plv8_calculate_float4_exponentiation_remainder(5.1::FLOAT4, -2, 2.0::FLOAT4) = 1.0::FLOAT4;
```

#### plv8_calculate_float4_factorial✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_factorial(number float4) RETURNS float4 AS $$
// name: calculate_float4_factorial
// description: Calculates the factorial of a non-negative float4 number, rounding down to the nearest whole value before computation.
// type: float4
// input: A non-negative float4 number to calculate the factorial of
// output: The factorial of the input number as float4, or 'undefined' if input is negative

  plv8.elog(NOTICE, "calculate_float4_factorial function called with number = " + number);

  // Round down the number to the nearest whole value
  var whole_number = Math.floor(number);

  // If the rounded number is less than 0, return 'undefined'
  if (whole_number < 0) {
    plv8.elog(NOTICE, "calculate_float4_factorial result: 'undefined'");
    return 'undefined'; // Assumes that 'undefined' is a valid float4 return value
  }

  // If the rounded number is 0 or 1, return 1
  if (whole_number === 0 || whole_number === 1) {
    plv8.elog(NOTICE, "calculate_float4_factorial result: 1.0");
    return 1.0;
  }

  // Initialize result as 1
  var result = 1;

  // Loop from 2 to the rounded number inclusive
  for (var i = 2; i <= whole_number; i++) {
    // Multiply result by the loop counter for each iteration
    result *= i;
  }

  // Return result
  plv8.elog(NOTICE, "calculate_float4_factorial result: " + result);
  return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plv8-float4', 'calculate_float4_factorial_case1', 
       plv8_calculate_float4_factorial(0.85::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plv8-float4', 'calculate_float4_factorial_case2', 
       plv8_calculate_float4_factorial(5.75::FLOAT4) = 120.0::FLOAT4;
```

#### plv8_calculate_float4_geometric_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_geometric_mean(value1 float4, value2 float4) RETURNS float4 AS $$
// name: calculate_float4_geometric_mean
// description: Calculates the geometric mean of two float4 numbers and returns the result as float4
// type: float4
// input: The first positive float4 value
// input: The second positive float4 value
// output: The geometric mean of input float4 values as float4

    if (value1 <= 0.0 || value2 <= 0.0) {
        throw new Error('Input values must be greater than zero.');
    }
    var product = value1 * value2;
    var result = Math.sqrt(product);
    plv8.elog(NOTICE, "calculate_float4_geometric_mean function called with value1 = " + value1 + ", value2 = " + value2);
    plv8.elog(NOTICE, "Result of calculate_float4_geometric_mean: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4GeometricMean1', plv8_calculate_float4_geometric_mean(1.0::FLOAT4, 4.0::FLOAT4) = 2.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4GeometricMean2', plv8_calculate_float4_geometric_mean(1.0::FLOAT4, 10000.0::FLOAT4) = 100.0::FLOAT4;
```

#### plv8_calculate_float4_inverse✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_inverse(numeric_value FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_inverse
// description: Calculates the multiplicative inverse (or reciprocal) of a non-zero float4 number
// type: float4
// input: The float4 number to invert
// output: The multiplicative inverse of the input as float4, or 'undefined' if the input is zero

    if (numeric_value === 0.0) {
        plv8.elog(NOTICE, "calculate_float4_inverse function called with numeric_value = 0. Calculation is undefined.");
        return undefined;
    } else {
        var inverse = 1.0 / numeric_value;
        plv8.elog(NOTICE, "calculate_float4_inverse function called with numeric_value = " + numeric_value);
        plv8.elog(NOTICE, "Result of calculate_float4_inverse: " + inverse);
        return inverse;
    }
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculate_float4_inverse_non_zero', plv8_calculate_float4_inverse(2.0::FLOAT4) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculate_float4_inverse_zero', plv8_calculate_float4_inverse(0.0::FLOAT4) IS NULL;
```

#### plv8_calculate_float4_inverse_ratio✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_inverse_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_inverse_ratio
// description: Calculates the inverse ratio of two float4 numbers, returns the result as float4.
// type: float4
// input: First float4 value, acting as the numerator
// input: Second float4 value, acting as the denominator, expected not to be zero
// output: The inverse ratio of the two float4 input values

    if (denominator === 0.0) {
        throw 'Denominator cannot be zero.';
    }
    var reciprocal = 1.0 / denominator;
    var result = reciprocal * numerator;
    plv8.elog(NOTICE, 'calculate_float4_inverse_ratio function called with numerator = ' + numerator + ', denominator = ' + denominator);
    plv8.elog(NOTICE, 'Result of calculate_float4_inverse_ratio: ' + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4InverseRatio1', plv8_calculate_float4_inverse_ratio(2.0::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4InverseRatio2', plv8_calculate_float4_inverse_ratio(0.0::FLOAT4, 3.0::FLOAT4) = 0.0::FLOAT4;
```

#### plv8_calculate_float4_inverse_square_root✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_inverse_square_root(number FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_inverse_square_root
// description: Calculate the inverse square root of a float4 number
// type: float4
// input: The float4 number for which to find the inverse square root
// output: The inverse square root of the input number as float4

  plv8.elog(NOTICE, "calculate_float4_inverse_square_root function called with number = " + number);

  if (number <= 0) {
    plv8.elog(NOTICE, "Input number is not greater than 0, returning 'undefined'.");
    return;
  }

  var inverse_sqrt = 1.0 / Math.sqrt(number);
  plv8.elog(NOTICE, "Result of calculate_float4_inverse_square_root: " + inverse_sqrt);

  return inverse_sqrt;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculateFloat4InverseSquareRootPositive', plv8_calculate_float4_inverse_square_root(4.0::FLOAT4) = 0.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculateFloat4InverseSquareRootSmallPositive', plv8_calculate_float4_inverse_square_root(0.25::FLOAT4) = 2.0::FLOAT4;
```

#### plv8_calculate_float4_linear_intercept✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_linear_intercept(x1 FLOAT4, y1 FLOAT4, x2 FLOAT4, y2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_linear_intercept
// description: Calculates the y-intercept of a line (b) given two points with float4 coordinates (x1, y1) and (x2, y2). The formula used is b = y1 - (slope * x1), where slope is the (y2 - y1) / (x2 - x1).
// type: float4
// input: The x-coordinate of the first point as float4
// input: The y-coordinate of the first point as float4
// input: The x-coordinate of the second point as float4
// input: The y-coordinate of the second point as float4
// output: The y-intercept (b) of the line as float4

  if (x1 === x2) throw 'Division by zero error: x1 should not be equal to x2.';
  
  var slope = (y2 - y1) / (x2 - x1);
  var y_intercept = y1 - (slope * x1);

  plv8.elog(NOTICE, 'DEBUG: FUNCTION plv8_calculate_float4_linear_intercept - Running with inputs x1 =', x1, ', y1 =', y1, ', x2 =', x2, ', y2 =', y2);
  plv8.elog(NOTICE, 'DEBUG: FUNCTION plv8_calculate_float4_linear_intercept - Calculated y_intercept =', y_intercept);

  return y_intercept;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_float4_linear_intercept1', plv8_calculate_float4_linear_intercept(2.0::FLOAT4, 3.0::FLOAT4, 4.0::FLOAT4, 7.0::FLOAT4) = -1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_float4_linear_intercept2', plv8_calculate_float4_linear_intercept(5.0::FLOAT4, 8.0::FLOAT4, 3.0::FLOAT4, 4.0::FLOAT4) = -2.0::FLOAT4;
```

#### plv8_calculate_float4_logarithm_base2✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_logarithm_base2(value FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_logarithm_base2
// description: Calculates the base-2 logarithm of a given float4 number and returns the result as float4.
// type: float4
// input: The float4 number for which to calculate the base-2 logarithm
// output: The base-2 logarithm of the input float4 number

    if (value <= 0) {
        throw new Error('Input value must be positive for logarithm calculation.');
    }
    var result = Math.LOG2E * Math.log(value);
    plv8.elog(NOTICE, "calculate_float4_logarithm_base2 function called with value = " + value);
    plv8.elog(NOTICE, "Result of calculate_float4_logarithm_base2: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4LogarithmBase21', (plv8_calculate_float4_logarithm_base2(8.0::FLOAT4) - 3.0::FLOAT4) < 1e-6;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4LogarithmBase22', (plv8_calculate_float4_logarithm_base2(2.0::FLOAT4) - 1.0::FLOAT4) < 1e-6;
```

#### plv8_calculate_float4_max_absolute_difference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_max_absolute_difference(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_max_absolute_difference
// description: This function calculates the maximum absolute difference between two float4 values
// type: float4
// input: The first float4 input value
// input: The second float4 input value
// output: The maximum absolute difference as float4

    var diff1 = Math.abs(input1 - input2);
    var diff2 = Math.abs(input2 - input1);
    var result = Math.max(diff1, diff2);
    plv8.elog(NOTICE, "calculate_float4_max_absolute_difference function called with input1 = " + input1 + ", input2 = " + input2);
    plv8.elog(NOTICE, "Result of calculate_float4_max_absolute_difference: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculateFloat4MaxAbsoluteDifferenceTest1', plv8_calculate_float4_max_absolute_difference(5.5::FLOAT4, 3.0::FLOAT4) = 2.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculateFloat4MaxAbsoluteDifferenceTest2', ROUND(plv8_calculate_float4_max_absolute_difference(2.2::FLOAT4, 4.8::FLOAT4)::NUMERIC, 1) = 2.6;
```

#### plv8_calculate_float4_modulo✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_modulo(dividend FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_modulo
// description: Calculates the modulo (the remainder of division) of two float4 values and returns the result as float4
// type: float4
// input: The number that is to be divided (dividend) as float4
// input: The number by which the dividend is to be divided (divisor) as float4
// output: The remainder of the division of the two float4 inputs

    if (divisor === 0) {
        plv8.elog(ERROR, "Divisor should not be zero.");
    }
    
    plv8.elog(NOTICE, "DEBUG: FUNCTION calculate_float4_modulo-1 - Running calculate_float4_modulo function with inputs dividend = " + dividend + ", divisor = " + divisor);
    
    var quotient = dividend / divisor;
    var result = dividend - (Math.floor(quotient) * divisor);
    
    plv8.elog(NOTICE, "DEBUG: FUNCTION calculate_float4_modulo-2 - Function calculate_float4_modulo is returning result = " + result);
    
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_float4_moduloPositive', plv8_calculate_float4_modulo(8.75::FLOAT4, 3.5::FLOAT4) = 1.75::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_float4_moduloNegative', plv8_calculate_float4_modulo(-5.25::FLOAT4, 2.0::FLOAT4) = 0.75::FLOAT4;
```

#### plv8_calculate_float4_percentage_change✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_percentage_change(old_value float4, new_value float4) RETURNS float4 AS $$
// name: calculate_float4_percentage_change
// description: Calculates the percentage change from float4 old_value to float4 new_value.
// type: float4
// input: The original float4 value
// input: The new float4 value to compare against the old value
// output: The percentage change as float4

    if (typeof(old_value) !== 'number' || typeof(new_value) !== 'number') {
        throw new Error('Input values must be float4 type');
    }
    if (old_value === 0) {
        throw new Error('old_value cannot be zero to avoid division by zero');
    }
    var difference = new_value - old_value;
    var percentage_change = (difference / old_value) * 100;
    plv8.elog(NOTICE, "calculate_float4_percentage_change function called with old_value = " + old_value + ", new_value = " + new_value);
    plv8.elog(NOTICE, "Result of calculate_float4_percentage_change: " + percentage_change);
    return percentage_change;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4PercentageChangeGreaterThan', plv8_calculate_float4_percentage_change(50.0::FLOAT4, 75.0::FLOAT4) = 50.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4PercentageChangeLessThan', ROUND(plv8_calculate_float4_percentage_change(75.0::FLOAT4, 50.0::FLOAT4)::NUMERIC, 4) = -33.3333::NUMERIC;
```

#### plv8_calculate_float4_precision✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_precision(number FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_precision
// description: Calculates the precision (number of decimal places) of a float4 number
// type: float4
// input: A float4 number to calculate the precision of
// output: The precision (number of decimal places) of the number as float4

    var number_str = number.toString();
    var decimal_index = number_str.indexOf('.');
    
    plv8.elog(NOTICE, "calculate_float4_precision function called with number = " + number);
    
    if (decimal_index === -1) {
        plv8.elog(NOTICE, "Result of calculate_float4_precision: " + 0.0);
        return 0.0;
    }
  
    var precision = number_str.substring(decimal_index + 1).length;
    plv8.elog(NOTICE, "Result of calculate_float4_precision: " + precision);
    return precision;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_float4_precision1', plv8_calculate_float4_precision(123.45::FLOAT4) = 14.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_float4_precision2', plv8_calculate_float4_precision(456.0::FLOAT4) = 0.0::FLOAT4;
```

#### plv8_calculate_float4_quadratic_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_quadratic_sum(num1 float4, num2 float4, num3 float4) RETURNS float4 AS $$
// name: calculate_float4_quadratic_sum
// description: Calculates the sum of squares of three float4 numbers and returns the result as float4.
// type: float4
// input: First float4 number
// input: Second float4 number
// input: Third float4 number
// output: Sum of squares of num1, num2, and num3 as float4

    var result1 = num1 * num1;
    var result2 = num2 * num2;
    var result3 = num3 * num3;
    var sum_of_squares = result1 + result2 + result3;
    
    // Debug logs
    plv8.elog(NOTICE, "calculate_float4_quadratic_sum function called with num1 = " + num1 + ", num2 = " + num2 + ", num3 = " + num3);
    plv8.elog(NOTICE, "Result of calculate_float4_quadratic_sum: " + sum_of_squares);

    return sum_of_squares;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plv8-float4', 'test_calculate_float4_quadratic_sum1', 
       plv8_calculate_float4_quadratic_sum(3.0::float4, 4.0::float4, 5.0::float4) = 50.0::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 'plv8-float4', 'test_calculate_float4_quadratic_sum2', 
       plv8_calculate_float4_quadratic_sum(-3.0::float4, 4.0::float4, -5.0::float4) = 50.0::float4;
```

#### plv8_calculate_float4_quotient_and_product✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_quotient_and_product(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4[] AS $$
// name: calculate_float4_quotient_and_product
// description: This function calculates both the quotient and the product of two float4 values and returns them as a float4 array.
// type: float4
// input: First float4 input value
// input: Second float4 input value, not equal to zero
// output: Array of float4 with the first element being the quotient and the second being the product of the inputs

    if (value2 === 0) {
        throw 'value2 cannot be zero.';
    }
    
    var results = [value1 / value2, value1 * value2];
    plv8.elog(NOTICE, 'calculate_float4_quotient_and_product function called with value1 = ' + value1 + ', value2 = ' + value2);
    plv8.elog(NOTICE, 'Quotient: ' + results[0] + ', Product: ' + results[1]);
    
    return results;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculateFloat4QuotientAndProductPositive', plv8_calculate_float4_quotient_and_product(3.5::FLOAT4, 2.0::FLOAT4) = ARRAY[1.75, 7.0]::FLOAT4[];
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculateFloat4QuotientAndProductNegByPos', plv8_calculate_float4_quotient_and_product(-4.0::FLOAT4, 2.0::FLOAT4) = ARRAY[-2.0, -8.0]::FLOAT4[];
```

#### plv8_calculate_float4_ratio✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_ratio(numerator FLOAT4, denominator FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_ratio
// description: Calculates the ratio of two float4 numbers and returns the result as float4. Ratio is the result of dividing the first float4 value by the second, provided the second is not zero.
// type: float4
// input: The numerator for the ratio calculation. Type: float4
// input: The denominator for the ratio calculation. Type: float4. Must not be zero.
// output: The calculated ratio as float4. If the denominator is zero, the function will return 'undefined'.

    plv8.elog(NOTICE, "calculate_float4_ratio function called with numerator = " + numerator + ", denominator = " + denominator);
    if (denominator === 0) {
        plv8.elog(NOTICE, "Denominator is zero, returning 'undefined'.");
        return 'undefined';
    }
    var ratio = numerator / denominator;
    plv8.elog(NOTICE, "Result of calculate_float4_ratio: " + ratio);
    return ratio;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4RatioPositive', plv8_calculate_float4_ratio(25.0::FLOAT4, 5.0::FLOAT4) = 5.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4RatioZeroDenominator', plv8_calculate_float4_ratio(10.0::FLOAT4, 0.0::FLOAT4) IS NOT DISTINCT FROM 'undefined';
```

#### plv8_calculate_float4_ratio_and_sum✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_ratio_and_sum(number1 float4, number2 float4) RETURNS json AS $$
// name: calculate_float4_ratio_and_sum
// description: Calculates the ratio of two float4 numbers and their sum
// type: float4
// input: First float4 number
// input: Second float4 number, cannot be zero as it will be used as divisor
// output: An object with the ratio and sum of the two float4 numbers

    if (number2 === 0) {
        throw 'Division by zero is not allowed';
    }
    var ratio = number1 / number2;
    var sum = number1 + number2;
    var result = {
        'ratio': ratio,
        'sum': sum
    };
    plv8.elog(NOTICE, JSON.stringify({
        message: "calculate_float4_ratio_and_sum function called with number1 = " + number1 + ", number2 = " + number2,
        result: result
    }));
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4RatioAndSumPositive', (plv8_calculate_float4_ratio_and_sum(6.0::FLOAT4, 3.0::FLOAT4) ->> 'ratio')::FLOAT4 = 2.0::FLOAT4 AND (plv8_calculate_float4_ratio_and_sum(6.0::FLOAT4, 3.0::FLOAT4) ->> 'sum')::FLOAT4 = 9.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4RatioAndSumNegative', (plv8_calculate_float4_ratio_and_sum(-8.0::FLOAT4, 4.0::FLOAT4) ->> 'ratio')::FLOAT4 = -2.0::FLOAT4 AND (plv8_calculate_float4_ratio_and_sum(-8.0::FLOAT4, 4.0::FLOAT4) ->> 'sum')::FLOAT4 = -4.0::FLOAT4;
```

#### plv8_calculate_float4_remainder✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_remainder(dividend FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_remainder
// description: Calculates the remainder of division between two float4 numbers
// type: float4
// input: float4 value representing the dividend
// input: float4 value representing the divisor
// output: float4 value representing the remainder of the division

  if (typeof dividend !== 'number' || typeof divisor !== 'number') {
    throw new Error('Input values must be float4 types.');
  }
  if (divisor === 0.0) {
    // Division by zero is not possible, return null
    plv8.elog(NOTICE, "Division by zero attempted: dividend = " + dividend + ", divisor = " + divisor);
    return null;
  }
  var remainder = dividend % divisor;
  plv8.elog(NOTICE, "Function calculate_float4_remainder called with dividend = " + dividend + ", divisor = " + divisor);
  plv8.elog(NOTICE, "Result of calculate_float4_remainder: " + remainder);
  return remainder;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4Remainder1', plv8_calculate_float4_remainder(5.0::FLOAT4, 2.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4Remainder2', plv8_calculate_float4_remainder(5.0::FLOAT4, 0.0::FLOAT4) IS NULL;
```

#### plv8_calculate_float4_rounded_average✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_rounded_average(value1 float4, value2 float4) RETURNS float4 AS $$
// name: calculate_float4_rounded_average
// description: Calculate the average of two float4 values and round it to the nearest whole number, returning the result as a float4
// type: float4
// input: The first float4 value for the average calculation
// input: The second float4 value for the average calculation
// output: The rounded average of value1 and value2 as a float4

    plv8.elog(NOTICE, "calculate_float4_rounded_average function called with value1 = " + value1 + ", value2 = " + value2);
    var average = (value1 + value2) / 2.0;
    var roundedAverage = Math.round(average);

    plv8.elog(NOTICE, "Calculated average: " + average + ", Rounded average: " + roundedAverage);
    return roundedAverage;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4RoundedAveragePositive', plv8_calculate_float4_rounded_average(25.4::FLOAT4, 34.6::FLOAT4) = 30.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateFloat4RoundedAverageMixed', plv8_calculate_float4_rounded_average(-14.8::FLOAT4, 20.2::FLOAT4) = 3.0::FLOAT4;
```

#### plv8_calculate_float4_to_power_of_integer✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_to_power_of_integer(float4_base FLOAT4, integer_exponent INTEGER) RETURNS FLOAT4 AS $$
// name: calculate_float4_to_power_of_integer
// description: This function takes a float4 base number and an integer exponent, then raises the base to the power of the exponent returning a float4 result
// type: float4
// input: float4 number serving as the base for the power operation
// input: Integer serving as the exponent for the power operation
// output: float4 result of the base raised to the power of the exponent

    plv8.elog(NOTICE, "calculate_float4_to_power_of_integer function called with float4_base = " + float4_base + ", integer_exponent = " + integer_exponent);
    var result = Math.pow(float4_base, integer_exponent);
    plv8.elog(NOTICE, "Result of calculate_float4_to_power_of_integer: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculateFloat4ToPowerOfIntegerPositive', plv8_calculate_float4_to_power_of_integer(2.5::FLOAT4, 3) = 15.625::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculateFloat4ToPowerOfIntegerZero', plv8_calculate_float4_to_power_of_integer(7.0::FLOAT4, 0) = 1.0::FLOAT4;
```

#### plv8_calculate_float4_with_exponential_notation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_float4_with_exponential_notation(number FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_float4_with_exponential_notation
// description: Converts a float4 number in exponential notation to a float4 number in standard decimal notation
// type: float4
// input: float4 number in exponential notation
// output: float4 number in standard decimal notation

  var result = parseFloat(number);
  plv8.elog(NOTICE, "calculate_float4_with_exponential_notation function called with number = " + number);
  plv8.elog(NOTICE, "Result of calculate_float4_with_exponential_notation: " + result);
  return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_float4_with_exponential_notation_small', plv8_calculate_float4_with_exponential_notation('2.5e-4'::FLOAT4) = '0.00025'::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_float4_with_exponential_notation_large', plv8_calculate_float4_with_exponential_notation('3.57e+2'::FLOAT4) = '357.0'::FLOAT4;
```

#### plv8_calculate_harmonic_mean✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_harmonic_mean(number1 FLOAT4, number2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_harmonic_mean
// description: Calculates the harmonic mean of two float4 numbers
// type: float4
// input: First float4 number
// input: Second float4 number
// output: Harmonic mean of the two float4 numbers as float4

    plv8.elog(NOTICE, "calculate_harmonic_mean function called with number1 = " + number1 + ", number2 = " + number2);
    
    if (number1 === 0 || number2 === 0) {
        return 'undefined';
    }

    var reciprocal1 = 1 / number1;
    var reciprocal2 = 1 / number2;
    var sumOfReciprocals = reciprocal1 + reciprocal2;
    var result = 2 / sumOfReciprocals;
    
    plv8.elog(NOTICE, "Result of calculate_harmonic_mean: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateHarmonicMeanPositive', plv8_calculate_harmonic_mean(4.0::FLOAT4, 8.0::FLOAT4)::TEXT = '5.3333335';
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateHarmonicMeanOneZero', plv8_calculate_harmonic_mean(0.0::FLOAT4, 5.0::FLOAT4)::TEXT = 'undefined';
```

#### plv8_calculate_hypotenuse✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_hypotenuse(a float4, b float4) RETURNS float4 AS $$
// name: calculate_hypotenuse
// description: Calculates the length of the hypotenuse of a right-angled triangle using the Pythagorean theorem
// type: float4
// input: length of side a as float4
// input: length of side b as float4
// output: length of the hypotenuse as float4

    plv8.elog(NOTICE, "calculate_hypotenuse function called with a = " + a + ", b = " + b);
    var a_squared = a * a;
    var b_squared = b * b;
    var sum = a_squared + b_squared;
    var result = Math.sqrt(sum);
    plv8.elog(NOTICE, "Result of calculate_hypotenuse: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateHypotenuse1', plv8_calculate_hypotenuse(3.0::float4, 4.0::float4) = 5.0::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateHypotenuse2', plv8_calculate_hypotenuse(5.0::float4, 12.0::float4) = 13.0::float4;
```

#### plv8_calculate_inscribed_circle_area✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_inscribed_circle_area(side_length FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_inscribed_circle_area
// description: Calculates the area of an inscribed circle within a square where each side is of float4 type length.
// type: float4
// input: The length of the side of the square of type float4
// output: The area of the inscribed circle as float4

  var radius = side_length / 2;
  var radius_squared = Math.pow(radius, 2);
  var area = radius_squared * Math.PI;
  
  plv8.elog(NOTICE, "calculate_inscribed_circle_area function called with side_length = " + side_length);
  plv8.elog(NOTICE, "Calculated radius: " + radius);
  plv8.elog(NOTICE, "Radius squared: " + radius_squared);
  plv8.elog(NOTICE, "Area of inscribed circle: " + area);

  return area;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculate_inscribed_circle_area1', ROUND(CAST(plv8_calculate_inscribed_circle_area(2.0::FLOAT4) AS NUMERIC), 2) = 3.14::NUMERIC;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculate_inscribed_circle_area2', plv8_calculate_inscribed_circle_area(5.4::FLOAT4) = 22.90231::FLOAT4;
```

#### plv8_calculate_linear_intercept✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_linear_intercept(x1 FLOAT4, y1 FLOAT4, m FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_linear_intercept
// description: Calculates the y-intercept (b) of a linear equation in the form y = mx + b using a point (x1, y1) and the slope (m)
// type: float4
// input: float4 - the x-coordinate of the point
// input: float4 - the y-coordinate of the point
// input: float4 - the slope of the line
// output: float4 - the y-intercept of the line

  plv8.elog(NOTICE, "calculate_linear_intercept function called with x1 = " + x1 + ", y1 = " + y1 + ", m = " + m);
  var b = y1 - (m * x1);
  plv8.elog(NOTICE, "Result of calculate_linear_intercept: " + b);
  return b;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculate_linear_intercept1', plv8_calculate_linear_intercept(3.0::FLOAT4, 4.0::FLOAT4, 2.0::FLOAT4) = -2.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculate_linear_intercept2', plv8_calculate_linear_intercept(-1.0::FLOAT4, -3.0::FLOAT4, -2.0::FLOAT4) = -5.0::FLOAT4;
```

#### plv8_calculate_linear_interpolation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_linear_interpolation(value1 FLOAT4, value2 FLOAT4, fraction FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_linear_interpolation
// description: Interpolates between two float4 values at a specific increment
// type: float4
// input: starting float4 value for interpolation
// input: ending float4 value for interpolation
// input: the float4 fraction representing the interpolation point between value1 and value2
// output: interpolated float4 value

    var result;
    if (fraction < 0.0 || fraction > 1.0) {
        throw new Error('Fraction must be between 0.0 and 1.0 inclusive.');
    }
    var difference = value2 - value1;
    result = value1 + (difference * fraction);
    plv8.elog(NOTICE, "calculate_linear_interpolation function called with value1 = " + value1 + ", value2 = " + value2 + ", fraction = " + fraction);
    plv8.elog(NOTICE, "Result of calculate_linear_interpolation: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateLinearInterpolationMidRange', plv8_calculate_linear_interpolation(10.75::FLOAT4, 20.5::FLOAT4, 0.5::FLOAT4) = 15.625::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateLinearInterpolationNearStart', plv8_calculate_linear_interpolation(-5.0::FLOAT4, 5.0::FLOAT4, 0.1::FLOAT4) = -4.0::FLOAT4;
```

#### plv8_calculate_log_base_n✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_log_base_n(number FLOAT4, base FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_log_base_n
// description: Calculates the logarithm of a float4 number with a float4 custom base and returns the result as float4. Rejects a base that is less than or equal to 0, or equal to 1, and a number that is less than or equal to 0.
// type: float4
// input: Value to find the logarithm of. Must be greater than 0.
// input: Base of the logarithm. Must be greater than 0 and not equal to 1.
// output: Logarithm of the number to the base provided. If the base or number is invalid, the output is 'undefined'.

    // Debugging message
    plv8.elog(NOTICE, "calculate_log_base_n function called with number = " + number + ", base = " + base);

    // Check if the input is valid
    if (base <= 0 || base === 1 || number <= 0) {
        plv8.elog(NOTICE, "Invalid input parameters");
        return 'undefined';
    }

    // Calculate the logarithm
    var result = Math.log(number) / Math.log(base);
    result = parseFloat(result.toFixed(4)); // Ensuring the result is float4

    // Debugging message with result
    plv8.elog(NOTICE, "Result of calculate_log_base_n: " + result);

    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_log_base_n_valid_base', plv8_calculate_log_base_n(32.0::FLOAT4, 2.0::FLOAT4) = 5.0::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_log_base_n_invalid_base', plv8_calculate_log_base_n(100.0::FLOAT4, 1.0::FLOAT4) = 'undefined';
```

#### plv8_calculate_logarithm✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_logarithm(number FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_logarithm
// description: Calculates the natural logarithm (base e) of a given float4 number and returns the result as float4. If the input is less than or equal to zero, the function will return 'undefined' since the logarithm for non-positive numbers is not defined in real numbers.
// type: float4
// input: The float4 number for which to find the natural logarithm
// output: The natural logarithm of the given float4 number as float4, or 'undefined' if the input is not a positive float4

    plv8.elog(NOTICE, "calculate_logarithm function called with number = " + number);
    if (number <= 0) {
        plv8.elog(NOTICE, "Input is non-positive. Logarithm is undefined.");
        return undefined;
    }
    var result = Math.log(number);
    plv8.elog(NOTICE, "Result of calculate_logarithm: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateLogarithmNonPositive', plv8_calculate_logarithm(-1.0::FLOAT4) IS NULL;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateLogarithmPositive', plv8_calculate_logarithm(2.7183::FLOAT4) = 1.0::FLOAT4;
```

#### plv8_calculate_logarithm_base_ten✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_logarithm_base_ten(number FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_logarithm_base_ten
// description: Calculates the logarithm base 10 of a float4 number and returns the result as float4. It assumes positive non-zero input.
// type: float4
// input: The float4 number to calculate the logarithm base 10 of
// output: The float4 result of the logarithm base 10 calculation

    if (number <= 0) {
        throw 'calculate_logarithm_base_ten function called with non-positive number';
    }
    var result = Math.log10(number);
    plv8.elog(NOTICE, "calculate_logarithm_base_ten function called with number = " + number);
    plv8.elog(NOTICE, "Result of calculate_logarithm_base_ten: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateLogarithmBaseTen1', plv8_calculate_logarithm_base_ten(100.0::FLOAT4) = 2.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateLogarithmBaseTen2', plv8_calculate_logarithm_base_ten(1000.0::FLOAT4) = 3.0::FLOAT4;
```

#### plv8_calculate_median_of_two_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_median_of_two_float4(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_median_of_two_float4
// description: Calculates the median of two float4 numbers and returns the result as float4
// type: float4
// input: First float4 input value
// input: Second float4 input value
// output: Median of input1 and input2 as float4

    var median = 0.0;
    if (input1 === null || input2 === null) {
        throw 'Input values cannot be null';
    }
    if (input1 === input2) {
        median = input1;
    } else {
        median = (input1 + input2) / 2.0;
    }
    plv8.elog(NOTICE, "calculate_median_of_two_float4 function called with input1 = " + input1 + ", input2 = " + input2);
    plv8.elog(NOTICE, "Result of calculate_median_of_two_float4: " + median);
    return median;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculate_median_of_two_float41', plv8_calculate_median_of_two_float4(10.0::FLOAT4, 10.0::FLOAT4) = 10.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculate_median_of_two_float42', plv8_calculate_median_of_two_float4(10.0::FLOAT4, 20.0::FLOAT4) = 15.0::FLOAT4;
```

#### plv8_calculate_percentage_difference✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_percentage_difference(value1 float4, value2 float4) RETURNS float4 AS $$
// name: calculate_percentage_difference
// description: Calculates the percentage difference between two float4 values
// type: float4
// input: First float4 value
// input: Second float4 value
// output: Percentage difference as float4

    var absolute_difference = Math.abs(value1 - value2);
    var average_value = (value1 + value2) / 2;
    var percentage_difference = (absolute_difference / average_value) * 100;
    plv8.elog(NOTICE, "calculate_percentage_difference function called with value1 = " + value1 + ", value2 = " + value2);
    plv8.elog(NOTICE, "Result of calculate_percentage_difference: " + percentage_difference);
    return percentage_difference;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculatePercentageDifference1', plv8_calculate_percentage_difference(150.0::FLOAT4, 100.0::FLOAT4) = 40.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculatePercentageDifference2', plv8_calculate_percentage_difference(75.0::FLOAT4, 125.0::FLOAT4) = 50.0::FLOAT4;
```

#### plv8_calculate_product_of_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_product_of_float4(num1 FLOAT4, num2 FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_product_of_float4
// description: Calculates the product of two float4 numbers and returns the result as a float4
// type: float4
// input: The first float4 number to be multiplied
// input: The second float4 number to be multiplied
// output: The product of the two float4 inputs as a float4

    plv8.elog(NOTICE, "calculate_product_of_float4 function called with num1 = " + num1 + ", num2 = " + num2);
    var product = num1 * num2;
    plv8.elog(NOTICE, "Result of calculate_product_of_float4: " + product);
    return product;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateProductOfFloat41', ROUND(CAST(plv8_calculate_product_of_float4(3.14::FLOAT4, 1.59::FLOAT4) AS NUMERIC), 4) = 4.9926;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateProductOfFloat42', plv8_calculate_product_of_float4(-5.0::FLOAT4, 2.5::FLOAT4) = -12.5::FLOAT4;
```

#### plv8_calculate_quadratic_roots✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_quadratic_roots(a float4, b float4, c float4) RETURNS float4[] AS $$
// name: calculate_quadratic_roots
// description: Calculates the roots of a quadratic equation ax^2 + bx + c = 0 using the quadratic formula and returns them as an array of float4
// type: float4
// input: float4 coefficient for x^2
// input: float4 coefficient for x
// input: float4 constant term
// output: array of float4 containing the two roots

    plv8.elog(NOTICE, "calculate_quadratic_roots function called with a = " + a + ", b = " + b + ", c = " + c);
    let discriminant = (b*b) - (4*a*c);
    let roots = [];

    if (discriminant < 0) {
        // Return an empty array if roots are not real numbers
        plv8.elog(NOTICE, "Discriminant is negative, no real roots.");
    } else {
        // Calculate the two roots using the quadratic formula
        let rootPart = Math.sqrt(discriminant);
        let denominator = 2 * a;
        roots.push((-b + rootPart) / denominator);
        if (discriminant > 0) {
            roots.push((-b - rootPart) / denominator);
        }
        plv8.elog(NOTICE, "Roots: " + roots.join(", "));
    }

    return roots;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateQuadraticRootsDistinctRealRoots', ARRAY[3,2]::float4[] = plv8_calculate_quadratic_roots(1::float4, -5::float4, 6::float4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateQuadraticRootsSingleRealRoot', ARRAY[2]::float4[] = plv8_calculate_quadratic_roots(1::float4, -4::float4, 4::float4);
```

#### plv8_calculate_scaled_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_scaled_value(value FLOAT4, factor FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_scaled_value
// description: This function takes an input float4 value and scales it by a given float4 factor.
// type: float4
// input: The original float4 value to be scaled
// input: The float4 factor by which to scale the value
// output: The scaled float4 value

    plv8.elog(NOTICE, "calculate_scaled_value function called with value = " + value + ", factor = " + factor);
    var result = value * factor;
    plv8.elog(NOTICE, "Result of calculate_scaled_value: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_scaled_value_up', plv8_calculate_scaled_value(1.5::FLOAT4, 2.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'calculate_scaled_value_down', plv8_calculate_scaled_value(3.0::FLOAT4, 0.5::FLOAT4) = 1.5::FLOAT4;
```

#### plv8_calculate_sin✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_sin(angle float4) RETURNS float4 AS $$
// name: calculate_sin
// description: Calculates the sine of a float4 angle value (in radians) and returns the result as float4
// type: float4
// input: float4 angle in radians for which the sine will be calculated
// output: float4 representing the sine of the input angle

    var input_angle = angle;  // Assumes that the input angle is already in radians.
    var result = Math.sin(input_angle);
    plv8.elog(NOTICE, "calculate_sin function called with angle = " + input_angle);
    plv8.elog(NOTICE, "Result of calculate_sin: " + result);
    return result;  // The floating-point nature of JS ensures that the result is float4.
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateSin1', plv8_calculate_sin(0.0::float4) = 0.0::float4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateSin2', plv8_calculate_sin(1.5708::float4) = 1.0::float4;
```

#### plv8_calculate_slope✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_slope(point1 float4[], point2 float4[]) RETURNS float4 AS $$
// name: calculate_slope
// description: Calculates the slope of a line passing through two points in the Cartesian coordinate system
// type: float4
// input: Coordinates (x1, y1) of the first point, type float4 array
// input: Coordinates (x2, y2) of the second point, type float4 array
// output: The slope of the line as float4

    if (point1.length !== 2 || point2.length !== 2) {
        throw 'Input arrays must contain exactly two elements.';
    }
    var deltaX = point2[0] - point1[0];
    var deltaY = point2[1] - point1[1];
    if (deltaX === 0) {
        return 'undefined'; // The slope is infinite/undefined for a vertical line.
    }
    var slope = deltaY / deltaX;
    plv8.elog(NOTICE, "calculate_slope function called with point1 = " + point1 + ", point2 = " + point2);
    plv8.elog(NOTICE, "Result of calculate_slope: " + slope);
    return slope;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateSlopeNonVerticalOrHorizontal', plv8_calculate_slope(ARRAY[1.0, 2.0]::FLOAT4[], ARRAY[3.0, 3.0]::FLOAT4[]) = 0.5::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculateSlopeVerticalLine', plv8_calculate_slope(ARRAY[4.0, 1.0]::FLOAT4[], ARRAY[4.0, 3.0]::FLOAT4[]) = 'undefined';
```

#### plv8_calculate_weight_force✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_calculate_weight_force(mass FLOAT4) RETURNS FLOAT4 AS $$
// name: calculate_weight_force
// description: Calculates the force due to weight of an object using the formula F = m * g, where m is mass in kilograms, and g is acceleration due to gravity at 9.81 m/s^2 (represented as float4)
// type: float4
// input: mass of the object as float4
// output: the weight force as float4

    const acceleration_due_to_gravity = 9.81;
    var weight_force = mass * acceleration_due_to_gravity;
    plv8.elog(NOTICE, "calculate_weight_force function called with mass = " + mass);
    plv8.elog(NOTICE, "Result of calculate_weight_force: " + weight_force);
    return weight_force;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculate_weight_force1', plv8_calculate_weight_force(2.0::FLOAT4) = 19.62::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_calculate_weight_force2', plv8_calculate_weight_force(5.5::FLOAT4) = 53.955::FLOAT4;
```

#### plv8_check_float4_equality✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_check_float4_equality(input1 FLOAT4, input2 FLOAT4) RETURNS BOOLEAN AS $$
// name: check_float4_equality
// description: Checks whether two float4 values are equal
// type: float4
// input: First float4 value to be compared
// input: Second float4 value to be compared
// output: Boolean result determining if the two float4 values are equal

    plv8.elog(NOTICE, 'DEBUG: FUNCTION check_float4_equality_plv8-1 - Running check_float4_equality_plv8 function with inputs input1 = ' + input1 + ', input2 = ' + input2);
    var result = input1 === input2;
    plv8.elog(NOTICE, 'DEBUG: FUNCTION check_float4_equality_plv8-2 - Function check_float4_equality_plv8 is returning result = ' + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'checkFloat4Equality1', plv8_check_float4_equality(4.0000::FLOAT4, 4.0000::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'checkFloat4Equality2', plv8_check_float4_equality(4.0000::FLOAT4, -3.9999::FLOAT4) = FALSE;
```

#### plv8_check_float4_is_positive✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_check_float4_is_positive(number float4) RETURNS float4 AS $$
// name: check_float4_is_positive
// description: Determines if a float4 input is positive
// type: float4
// input: The float4 number to check
// output: A float4 representing a boolean true or false, 1.0 for true and 0.0 for false

    plv8.elog(NOTICE, "check_float4_is_positive function called with number = " + number);
    var result = number > 0.0 ? 1.0 : 0.0;
    plv8.elog(NOTICE, "Result of check_float4_is_positive: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'check_float4_is_positive_positiveTest', plv8_check_float4_is_positive(0.1::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'check_float4_is_positive_negativeTest', plv8_check_float4_is_positive(-0.1::FLOAT4) = 0.0::FLOAT4;
```

#### plv8_check_float4_within_bounds✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_check_float4_within_bounds(value FLOAT4, lower_bound FLOAT4, upper_bound FLOAT4) RETURNS FLOAT4 AS $$
// name: check_float4_within_bounds
// description: Determines whether a float4 value is between two boundary float4 values (exclusive)
// type: float4
// input: the float4 value to check
// input: the lower float4 boundary
// input: the upper float4 boundary
// output: boolean represented as float4 (1.0 for true, 0.0 for false)

    plv8.elog(NOTICE, "check_float4_within_bounds function called with value = " + value + ", lower_bound = " + lower_bound + ", upper_bound = " + upper_bound);

    var result = (value > lower_bound && value < upper_bound) ? 1.0 : 0.0;

    plv8.elog(NOTICE, "Result of check_float4_within_bounds: " + result);

    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'checkFloat4WithinBounds1', plv8_check_float4_within_bounds(5.75::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'checkFloat4WithinBounds2', plv8_check_float4_within_bounds(-3.14::FLOAT4, 0.0::FLOAT4, 10.0::FLOAT4) = 0.0::FLOAT4;
```

#### plv8_check_float4_within_tolerance✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_check_float4_within_tolerance(float4_num1 FLOAT4, float4_num2 FLOAT4, tolerance FLOAT4) RETURNS BOOLEAN AS $$
// name: check_float4_within_tolerance
// description: Checks if two float4 numbers are within a specified tolerance
// type: float4
// input: First float4 number to compare
// input: Second float4 number to compare
// input: The float4 tolerance within which the two numbers are considered equal
// output: Boolean float4 indicating if the numbers are within the tolerance

    var within_tolerance = false;
    
    // Calculate the absolute difference between float4_num1 and float4_num2
    var difference = Math.abs(float4_num1 - float4_num2);
    
    // Check if the difference is within the tolerance
    if (difference <= tolerance) {
        within_tolerance = true;
    }
    
    // Debugging logs
    plv8.elog(NOTICE, "check_float4_within_tolerance function called with float4_num1 =", float4_num1, ", float4_num2 =", float4_num2, ", tolerance =", tolerance);
    plv8.elog(NOTICE, "The numbers are within the tolerance:", within_tolerance);
    
    return within_tolerance;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 
    'plv8-float4', 
    'checkFloat4WithinToleranceWithin', 
    plv8_check_float4_within_tolerance(100.0::FLOAT4, 100.05::FLOAT4, 0.1::FLOAT4) = true;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) 
SELECT 
    'plv8-float4', 
    'checkFloat4WithinToleranceNotWithin', 
    plv8_check_float4_within_tolerance(200.0::FLOAT4, 200.2::FLOAT4, 0.1::FLOAT4) = false;
```

#### plv8_clamp_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_clamp_value(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS FLOAT4 AS $$
// name: clamp_value
// description: Clamps a given float4 value between a minimum and maximum float4 range
// type: float4
// input: The float4 value to be clamped
// input: The minimum float4 value in the range
// input: The maximum float4 value in the range
// output: The clamped float4 value

    plv8.elog(NOTICE, "DEBUG: plv8_clamp_value - Running with value = " + value + ", min_value = " + min_value + ", max_value = " + max_value);
    if (value < min_value) {
        plv8.elog(NOTICE, "DEBUG: plv8_clamp_value - Returning min_value = " + min_value);
        return min_value;
    } else if (value > max_value) {
        plv8.elog(NOTICE, "DEBUG: plv8_clamp_value - Returning max_value = " + max_value);
        return max_value;
    } else {
        plv8.elog(NOTICE, "DEBUG: plv8_clamp_value - Returning value = " + value);
        return value;
    }
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'clamp_value_less_than_minimum', plv8_clamp_value(2.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'clamp_value_within_range', plv8_clamp_value(4.5::FLOAT4, 3.0::FLOAT4, 5.0::FLOAT4) = 4.5::FLOAT4;
```

#### plv8_combine_second_third_power✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_combine_second_third_power(input1 FLOAT4, input2 FLOAT4) RETURNS FLOAT4 AS $$
// name: combine_second_third_power
// description: Combines the second power of the first float4 input with the third power of the second float4 input by adding them together.
// type: float4
// input: The first float4 input for which the second power is calculated
// input: The second float4 input for which the third power is calculated
// output: The result of adding the second power of input1 and the third power of input2, returned as float4

    plv8.elog(NOTICE, `DEBUG: FUNCTION plv8_combine_second_third_power - Running with inputs 'input1' = ${input1}, 'input2' = ${input2}.`);
    var result = Math.pow(input1, 2) + Math.pow(input2, 3);
    plv8.elog(NOTICE, `DEBUG: FUNCTION plv8_combine_second_third_power - Result is 'result' = ${result}.`);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'combine_second_third_powerPositiveInputs', plv8_combine_second_third_power(4.0::FLOAT4, 2.0::FLOAT4) = 24.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'combine_second_third_powerPosNegInputs', plv8_combine_second_third_power(-1.5::FLOAT4, 3.0::FLOAT4) = 29.25::FLOAT4;
```

#### plv8_compare_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_compare_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
// name: compare_float4_values
// description: Compares two float4 values and determines if the first is greater than the second.
// type: float4
// input: First float4 value for comparison
// input: Second float4 value for comparison
// output: Boolean represented as float4 (1.0 for true, 0.0 for false)

    var result = 0.0;
    if (value1 > value2) {
        result = 1.0;
    }
    plv8.elog(NOTICE, "compare_float4_values function called with value1 = " + value1 + ", value2 = " + value2);
    plv8.elog(NOTICE, "Result of compare_float4_values: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_compareFloat4ValuesGreater', plv8_compare_float4_values(3.5::FLOAT4, 2.7::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_compareFloat4ValuesNotGreater', plv8_compare_float4_values(1.4::FLOAT4, 1.8::FLOAT4) = 0.0::FLOAT4;
```

#### plv8_compute_circle_area✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_compute_circle_area(radius float4) RETURNS float4 AS $$
// name: compute_circle_area
// description: This function calculates the area of a circle given the radius as a float4 type.
// type: float4
// input: The radius of the circle as a float4
// output: The area of the circle as a float4

  var pi = 3.14159;
  if (radius === null) {
      throw new Error('radius cannot be null');
  }
  var area = pi * Math.pow(radius, 2);
  plv8.elog(NOTICE, "compute_circle_area function called with radius = " + radius);
  plv8.elog(NOTICE, "Result of compute_circle_area: " + area);
  return area;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_compute_circle_area_small_radius', plv8_compute_circle_area(2.5::FLOAT4) = 19.6349375::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_compute_circle_area_large_radius', plv8_compute_circle_area(100.0::FLOAT4) = 31415.9::FLOAT4;
```

#### plv8_compute_float4_quotient_and_remainder✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_compute_float4_quotient_and_remainder(dividend float4, divisor float4) RETURNS json AS $$
// name: compute_float4_quotient_and_remainder
// description: Compute the quotient and remainder of the division of two float4 numbers
// type: float4
// input: The float4 number being divided
// input: The float4 number by which the dividend is divided
// output: A JSON object with float4 quotient and remainder

  var result = {};
  if (divisor === 0) {
    throw 'Division by zero is not allowed.';
  }
  var quotient = dividend / divisor;
  var remainder = dividend % divisor;
  result.quotient = quotient;
  result.remainder = remainder;

  plv8.elog(NOTICE, "compute_float4_quotient_and_remainder function called with dividend = " 
    + dividend + ", divisor = " + divisor);
  plv8.elog(NOTICE, "Result of compute_float4_quotient_and_remainder: quotient = " 
    + result.quotient + ", remainder = " + result.remainder);
    
  return JSON.stringify(result);
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'computeFloat4QuotientAndRemainderPositive', (plv8_compute_float4_quotient_and_remainder(8.75::FLOAT4, 2.50::FLOAT4)::json->>'quotient')::FLOAT4 = 3.5::FLOAT4 AND (plv8_compute_float4_quotient_and_remainder(8.75::FLOAT4, 2.50::FLOAT4)::json->>'remainder')::FLOAT4 = 1.25::FLOAT4;
-- INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'computeFloat4QuotientAndRemainderNegative', (plv8_compute_float4_quotient_and_remainder(-5.5::FLOAT4, 2.2::FLOAT4)::json->>'quotient')::FLOAT4 = -2.5::FLOAT4 AND (plv8_compute_float4_quotient_and_remainder(-5.5::FLOAT4, 2.2::FLOAT4)::json->>'remainder')::FLOAT4 = -0.9::FLOAT4;
```

#### plv8_compute_square_root✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_compute_square_root(input_number FLOAT4) RETURNS FLOAT4 AS $$
// name: compute_square_root
// description: Computes the square root of a given float4 input and returns the result as float4
// type: float4
// input: The float4 number to compute the square root of
// output: The float4 square root of the input number

    if (input_number < 0) {
        throw 'Error: square root of negative number is not real';
    }
    
    if (input_number === 0) {
        return 0;
    }
    
    var result = Math.sqrt(input_number);
    plv8.elog(NOTICE, "compute_square_root function called with input_number = " + input_number);
    plv8.elog(NOTICE, "Result of compute_square_root: " + result);
    
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'compute_square_root1', plv8_compute_square_root(16.0::FLOAT4) = 4.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'compute_square_root2', plv8_compute_square_root(0.0::FLOAT4) = 0.0::FLOAT4;
```

#### plv8_compute_tangent✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_compute_tangent(angle_in_radians FLOAT4) RETURNS FLOAT4 AS $$
// name: compute_tangent
// description: Computes the tangent of a float4 angle value in radians and returns the result as float4
// type: float4
// input: The angle in radians for which to compute the tangent, as a float4
// output: The tangent of the angle as float4

    var pi = Math.PI;
    if (angle_in_radians === null) {
        plv8.elog(NOTICE, "compute_tangent function called with null input");
        return null;
    }
    if (angle_in_radians === pi / 2 || angle_in_radians === 3 * pi / 2) {
        throw new Error("Input angle is not allowed to be PI/2 or 3*PI/2");
    }
    var result = Math.tan(angle_in_radians);
    plv8.elog(NOTICE, "compute_tangent function called with angle_in_radians = " + angle_in_radians);
    plv8.elog(NOTICE, "Result of compute_tangent: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_computeTangentOfZero', plv8_compute_tangent(0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_computeTangentOfPIOver4', plv8_compute_tangent(0.785398163::FLOAT4) = 1.0::FLOAT4;
```

#### plv8_convert_float4_to_negative✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_convert_float4_to_negative(number FLOAT4) RETURNS FLOAT4 AS $$
// name: convert_float4_to_negative
// description: This function converts a float4 number to its negative equivalent.
// type: float4
// input: float4 number to be negated
// output: The negative equivalent of the input as float4

    if (number === null) {
        plv8.elog(NOTICE, "convert_float4_to_negative function was called with null");
        return null;
    }

    var result;
    if (number < 0) {
        result = number;
    } else {
        result = -number;
    }

    plv8.elog(NOTICE, "convert_float4_to_negative function called with number = " + number);
    plv8.elog(NOTICE, "Result of convert_float4_to_negative: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_convert_float4_to_negative1', plv8_convert_float4_to_negative(3.5::FLOAT4) = -3.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_convert_float4_to_negative2', plv8_convert_float4_to_negative(-2.0::FLOAT4) = -2.0::FLOAT4;
```

#### plv8_convert_to_radians✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_convert_to_radians(degrees FLOAT4) RETURNS FLOAT4 AS $$
// name: convert_to_radians
// description: Converts an angle in degrees to radians
// type: float4
// input: The angle in degrees to be converted to radians as float4
// output: The angle in radians as float4

    const PI = 3.1415927;
    plv8.elog(NOTICE, "convert_to_radians function called with degrees = " + degrees);
    var radians = (degrees * PI) / 180.0;
    plv8.elog(NOTICE, "Result of convert_to_radians: " + radians);
    return radians;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_convertToRadiansCase1', plv8_convert_to_radians(0.0::FLOAT4) = 0.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_convertToRadiansCase2', plv8_convert_to_radians(180.0::FLOAT4) = 3.1415927::FLOAT4;
```

#### plv8_find_nearest_multiple_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_find_nearest_multiple_float4(number FLOAT4, divisor FLOAT4) RETURNS FLOAT4 AS $$
// name: find_nearest_multiple_float4
// description: Finds the nearest multiple of a divisor close to the given float4 number
// type: float4
// input: The original float4 value for which the nearest multiple is to be found
// input: The divisor float4 value whose multiple is to be found nearest to the number
// output: The nearest multiple of the divisor float4 value to the original number as float4

    var quotient = number / divisor;
    var rounded_quotient = Math.round(quotient);
    var nearest_multiple = rounded_quotient * divisor;
    plv8.elog(NOTICE, "find_nearest_multiple_float4 function called with number = " + number + ", divisor = " + divisor);
    plv8.elog(NOTICE, "Result of find_nearest_multiple_float4: " + nearest_multiple);
    return nearest_multiple;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'find_nearest_multiple_float4_case1', plv8_find_nearest_multiple_float4(14.2::FLOAT4, 5.0::FLOAT4) = 15.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'find_nearest_multiple_float4_case2', plv8_find_nearest_multiple_float4(7.7::FLOAT4, 3.5::FLOAT4) = 7.0::FLOAT4;
```

#### plv8_float4_absolute_value_test✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_float4_absolute_value_test(number FLOAT4) RETURNS FLOAT4 AS $$
// name: float4_absolute_value_test
// description: Function to compute the absolute value of a float4 number
// type: float4
// input: A float4 value representing the number to find the absolute value for
// output: float4 absolute value of the input number

    var abs_value; // Initialize variable of type float4
    if (number < 0) {
        abs_value = number * -1; // Make number positive
    } else {
        abs_value = number; // Number is already positive or zero
    }
    plv8.elog(NOTICE, "float4_absolute_value_test function called with number = " + number);
    plv8.elog(NOTICE, "Result of float4_absolute_value_test: " + abs_value);
    return abs_value; // Return the absolute value
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'float4_absolute_value_test_negative', plv8_float4_absolute_value_test(-123.45::FLOAT4) = 123.45::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'float4_absolute_value_test_positive', plv8_float4_absolute_value_test(678.9::FLOAT4) = 678.9::FLOAT4;
```

#### plv8_float4_min_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_float4_min_value(number1 FLOAT4, number2 FLOAT4) RETURNS FLOAT4 AS $$
// name: float4_min_value
// description: Finds the minimum value between two float4 numbers
// type: float4
// input: First float4 number for comparison
// input: Second float4 number for comparison
// output: Returns the minimum value as float4

    var min_value = number1; // Initialize min_value with the first input number
    if (number2 < min_value) { // Compare the second number with min_value
        min_value = number2; // If it's less, assign it to min_value
    }
    // Debugging: log messages in plv8
    plv8.elog(NOTICE, "float4_min_value function called with number1 = " + number1 + ", number2 = " + number2);
    plv8.elog(NOTICE, "Result of float4_min_value: " + min_value);
    return min_value; // Return min_value as the result
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'float4_min_valuePositive', plv8_float4_min_value(3.5::FLOAT4, 7.25::FLOAT4) = 3.5::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'float4_min_valueNegByPos', plv8_float4_min_value(-2.0::FLOAT4, 4.75::FLOAT4) = -2.0::FLOAT4;
```

#### plv8_is_float4_in_decreasing_order✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_is_float4_in_decreasing_order(number1 FLOAT4, number2 FLOAT4) RETURNS BOOLEAN AS $$
// name: is_float4_in_decreasing_order
// description: Determines if the provided float4 numbers are in strictly decreasing order
// type: float4
// input: First number of type float4
// input: Second number of type float4
// output: Result of type boolean, true if number1 > number2, false otherwise

    plv8.elog(NOTICE, "is_float4_in_decreasing_order function called with number1 = " + number1 + ", number2 = " + number2);
    var result = number1 > number2;
    plv8.elog(NOTICE, "Result of is_float4_in_decreasing_order: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'is_float4_in_decreasing_order_case1', plv8_is_float4_in_decreasing_order(6.5::FLOAT4, 3.24::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'is_float4_in_decreasing_order_case2', plv8_is_float4_in_decreasing_order(5.5::FLOAT4, 5.5::FLOAT4) = FALSE;
```

#### plv8_is_float4_in_range✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_is_float4_in_range(value FLOAT4, min_value FLOAT4, max_value FLOAT4) RETURNS BOOLEAN AS $$
// name: is_float4_in_range
// description: Determines if a float4 value falls within a specified inclusive range, defined by a minimum and maximum float4 value.
// type: float4
// input: The float4 value to check
// input: The inclusive minimum value of the range as float4
// input: The inclusive maximum value of the range as float4
// output: Returns true if the value is within the range, otherwise false

    plv8.elog(NOTICE, "is_float4_in_range function called with value = " + value + ", min_value = " + min_value + ", max_value = " + max_value);
    var is_in_range = value >= min_value && value <= max_value;
    plv8.elog(NOTICE, "Result of is_float4_in_range: " + is_in_range);
    return is_in_range;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'is_float4_in_range_within', plv8_is_float4_in_range(3.5::FLOAT4, 1.0::FLOAT4, 5.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'is_float4_in_range_outside', plv8_is_float4_in_range(6.5::FLOAT4, 1.0::FLOAT4, 5.0::FLOAT4) = FALSE;
```

#### plv8_is_float4_zero✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_is_float4_zero(number float4) RETURNS boolean AS $$
// name: is_float4_zero
// description: Checks if the provided float4 number is zero
// type: float4
// input: the input float4 number to check
// output: returns true if number is 0.0, false otherwise

    var threshold = 0.0001;
    var absNumber = Math.abs(number);
    plv8.elog(NOTICE, "is_float4_zero function called with number = " + number);
    var isZero = absNumber <= threshold;
    plv8.elog(NOTICE, "Result of is_float4_zero: " + isZero);
    return isZero;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'is_float4_zero_case1', plv8_is_float4_zero(0.0::FLOAT4);
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'is_float4_zero_case2', plv8_is_float4_zero(0.00001::FLOAT4);
```

#### plv8_is_negative✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_is_negative(number float4) RETURNS boolean AS $$
// name: is_negative
// description: Determines if a float4 value is negative
// type: float4
// input: the float4 number to check
// output: boolean indicating if the number is negative

    plv8.elog(NOTICE, "is_negative function called with number = " + number);
    var isNegative = number < 0;
    plv8.elog(NOTICE, "Result of is_negative: " + isNegative);
    return isNegative;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'is_negativeTestNegative', plv8_is_negative(-3.14::FLOAT4) = true;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'is_negativeTestNotNegative', plv8_is_negative(6.28::FLOAT4) = false;
```

#### plv8_normalize_float4_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_normalize_float4_value(value float4, min_value float4, max_value float4) RETURNS float4 AS $$
// name: normalize_float4_value
// description: Normalize a float4 number to the range of 0 to 1 based on provided minimum and maximum values
// type: float4
// input: the float4 number to normalize
// input: the minimum float4 value of the range
// input: the maximum float4 value of the range
// output: the normalized float4 number

    if (min_value >= max_value) {
        throw new Error('min_value must be less than max_value');
    }
    
    var distance = value - min_value;
    var range = max_value - min_value;
    var result = distance / range;
    
    plv8.elog(NOTICE, "normalize_float4_value function called with value = " + value + ", min_value = " + min_value + ", max_value = " + max_value);
    plv8.elog(NOTICE, "Result of normalize_float4_value: " + result);
    
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'normalize_float4_value_within_range', plv8_normalize_float4_value(10.0, 0.0, 20.0) = 0.5;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'normalize_float4_value_at_top_of_range', plv8_normalize_float4_value(20.0, 10.0, 20.0) = 1.0;
```

#### plv8_subtract_float4_values✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_subtract_float4_values(value1 FLOAT4, value2 FLOAT4) RETURNS FLOAT4 AS $$
// name: subtract_float4_values
// description: Subtracts the second float4 value from the first and returns the result as float4
// type: float4
// input: First float4 value to be used in subtraction
// input: Second float4 value to subtract from the first value
// output: Result of subtraction as float4

    var result = value1 - value2;
    plv8.elog(NOTICE, "subtract_float4_values function called with value1 = " + value1 + ", value2 = " + value2);
    plv8.elog(NOTICE, "Result of subtract_float4_values: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'subtract_float4_values_positive', ROUND(plv8_subtract_float4_values(5.7::FLOAT4, 2.3::FLOAT4)::NUMERIC, 1) = 3.4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'subtract_float4_values_neg_from_pos', plv8_subtract_float4_values(-1.2::FLOAT4, 4.6::FLOAT4) = -5.8::FLOAT4;
```

#### plv8_test_cosine_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_test_cosine_float4(angle FLOAT4) RETURNS FLOAT4 AS $$
// name: test_cosine_float4
// description: Calculates the cosine of a float4 angle value in radians and returns the result as float4
// type: float4
// input: Angle in radians for which the cosine has to be calculated (float4)
// output: The cosine of the provided angle (float4)

    var result = Math.cos(angle);
    plv8.elog(NOTICE, "test_cosine_float4 function called with angle = " + angle);
    plv8.elog(NOTICE, "Result of test_cosine_float4: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_cosine_of_zero_radians', plv8_test_cosine_float4(0.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_cosine_of_PI_over_2_radians', abs(plv8_test_cosine_float4(1.5707963::FLOAT4)) < 1e-6::FLOAT4;
```

#### plv8_test_float4_power✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_test_float4_power(base FLOAT4, exponent FLOAT4) RETURNS FLOAT4 AS $$
// name: test_float4_power
// description: Raises a float4 base number to the power of a float4 exponent
// type: float4
// input: float4 base number
// input: float4 exponent value
// output: float4 result of raising base to the power of exponent

    var result = null;

    // Input validation
    if (base === null || exponent === null) {
        throw 'Both base and exponent must be provided';
    }

    // Check if the exponent is 0, if so return 1.0
    if (exponent === 0) {
        result = 1.0;
    } else if (base === 0) {
        // Check if the base is 0, if so return 0.0
        result = 0.0;
    } else {
        // Raise the base to the power of exponent and store in result,
        result = Math.pow(base, exponent);    
    }

    // Debugging logs
    plv8.elog(NOTICE, "test_float4_power function called with base = " + base + ", exponent = " + exponent);
    plv8.elog(NOTICE, "Result of test_float4_power: " + result);

    // Return the result as float4
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_float4_power_non_zero_base_positive_exponent', plv8_test_float4_power(2.0::FLOAT4, 3.0::FLOAT4) = 8.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_float4_power_non_zero_base_non_integer_exponent', plv8_test_float4_power(9.0::FLOAT4, 0.5::FLOAT4) = 3.0::FLOAT4;
```

#### plv8_test_float4_rounding✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_test_float4_rounding(original_value float4) RETURNS float4 AS $$
// name: test_float4_rounding
// description: This function rounds a float4 value to the nearest whole number and returns it as float4.
// type: float4
// input: A float4 value to be rounded to the nearest whole number
// output: Rounded float4 value to the nearest whole number

    var rounded_value = Math.round(original_value);
    plv8.elog(NOTICE, "test_float4_rounding function called with original_value = " + original_value);
    plv8.elog(NOTICE, "Result of test_float4_rounding: " + rounded_value);
    return rounded_value;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_float4_rounding_positive', plv8_test_float4_rounding(2.5::FLOAT4) = 3.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_float4_rounding_negative', plv8_test_float4_rounding(-3.7::FLOAT4) = -4.0::FLOAT4;
```

#### plv8_test_float4_truncation✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_test_float4_truncation(number float4) RETURNS float4 AS $$
// name: test_float4_truncation
// description: Truncates a float4 number, removing its decimal part.
// type: float4
// input: A float4 number to be truncated
// output: The truncated float4 number

    var truncated_number = Math.trunc(number);
    plv8.elog(NOTICE, "Function test_float4_truncation: Input number = " + number + ", Truncated number = " + truncated_number);
    return truncated_number;
$$ LANGUAGE plv8;
-- Test case 1: Truncating a positive float4 number
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_float4_truncation_Positive', plv8_test_float4_truncation(123.456::FLOAT4) = 123.0::FLOAT4;
-- Test case 2: Truncating a negative float4 number
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_float4_truncation_Negative', plv8_test_float4_truncation(-123.456::FLOAT4) = -123.0::FLOAT4;
```

#### plv8_test_increment_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_test_increment_float4(number FLOAT4, increment FLOAT4) RETURNS FLOAT4 AS $$
// name: test_increment_float4
// description: This function increments a float4 value by a float4 increment and returns the result as float4.
// type: float4
// input: The float4 number to be incremented
// input: The float4 value to increment the number by
// output: The incremented float4 value

    var result = number + increment;
    plv8.elog(NOTICE, "test_increment_float4 function called with number = " + number + ", increment = " + increment);
    plv8.elog(NOTICE, "Result of test_increment_float4: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_increment_float4_Positive', plv8_test_increment_float4(8.25::FLOAT4, 1.75::FLOAT4) = 10.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_increment_float4_NegByPos', plv8_test_increment_float4(-3.5::FLOAT4, 4.0::FLOAT4) = 0.5::FLOAT4;
```

#### plv8_test_maximum_value✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_test_maximum_value(input1 float4, input2 float4) RETURNS float4 AS $$
// name: test_maximum_value
// description: Function to determine the maximum of two float4 values
// type: float4
// input: First float4 value to compare
// input: Second float4 value to compare
// output: Returns the maximum of the two float4 inputs

    plv8.elog(NOTICE, "test_maximum_value function called with input1 = " + input1 + ", input2 = " + input2);
    var result = input1 >= input2 ? input1 : input2;
    plv8.elog(NOTICE, "Result of test_maximum_value: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_maximum_value_first_greater', plv8_test_maximum_value(12.34::FLOAT4, 9.87::FLOAT4) = 12.34::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'test_maximum_value_second_greater', plv8_test_maximum_value(-3.21::FLOAT4, 4.56::FLOAT4) = 4.56::FLOAT4;
```

#### plv8_validate_even_float4✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_validate_even_float4(value FLOAT4) RETURNS BOOLEAN AS $$
// name: validate_even_float4
// description: Determines whether a float4 number represents an even number
// type: float4
// input: The float4 number to check
// output: Returns true if the number is even, otherwise false

    // Transform the float4 input to the nearest smaller whole number if it is not already whole.
    var wholeNumber = Math.floor(value);

    // Perform a modulo operation with 2 on the whole number.
    var isEven = wholeNumber % 2 === 0;

    // Debugging logs
    plv8.elog(NOTICE, "validate_even_float4 function called with value = " + value);
    plv8.elog(NOTICE, "Nearest whole number: " + wholeNumber);
    plv8.elog(NOTICE, "Is the number even: " + isEven);

    // Return true if the result is 0, otherwise return false.
    return isEven;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'validate_even_float4_EvenWholeNumber', plv8_validate_even_float4(4.0::FLOAT4) = TRUE;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'validate_even_float4_OddWholeNumber', plv8_validate_even_float4(5.0::FLOAT4) = FALSE;
```

#### plv8_validate_float4_within_range✅
  

[Back to result table](#result-table)

```sql
CREATE OR REPLACE FUNCTION plv8_validate_float4_within_range(number FLOAT4, range_min FLOAT4, range_max FLOAT4) RETURNS FLOAT4 AS $$
// name: validate_float4_within_range
// description: validate whether the float4 number falls within the exclusive range (min, max)
// type: float4
// input: the float4 number to validate
// input: the minimum float4 boundary of the range
// input: the maximum float4 boundary of the range
// output: boolean represented as float4 (1.0 for true, 0.0 for false)

    plv8.elog(NOTICE, "validate_float4_within_range function called with number = " + number + ", range_min = " + range_min + ", range_max = " + range_max);
    var result = (number > range_min && number < range_max) ? 1.0 : 0.0;
    plv8.elog(NOTICE, "Result of validate_float4_within_range: " + result);
    return result;
$$ LANGUAGE plv8;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'validateFloat4WithinRangeCase1', plv8_validate_float4_within_range(5.5::FLOAT4, 5.0::FLOAT4, 6.0::FLOAT4) = 1.0::FLOAT4;
INSERT INTO LLM_TESTS (FEATURE, TEST_NAME, RESULT) SELECT 'plv8-float4', 'validateFloat4WithinRangeCase2', plv8_validate_float4_within_range(4.0::FLOAT4, 5.0::FLOAT4, 6.0::FLOAT4) = 0.0::FLOAT4;
```



## Tests by feature

This section includes the tests grouped by feature.




## Tests by type

his section includes the tests grouped by type.
